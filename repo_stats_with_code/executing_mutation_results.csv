Repo Name,Function Name,original_code,Description,Mutant Index,Mutant Code,Test Case,Test Result,Passed Count,Failed Count,Failed Tests,Failure Reasons
executing,only,"def only(it):
    if isinstance(it, Sized):
        if len(it) != 1:
            raise NotOneValueFound('Expected one value, found %s' % len(it))
        return list(it)[0]
    lst = tuple(islice(it, 2))
    if len(lst) == 0:
        raise NotOneValueFound('Expected one value, found 0')
    if len(lst) > 1:
        raise NotOneValueFound('Expected one value, found several', lst)
    return lst[0]","The function 'only' is designed to extract a single value from an iterable object. It checks if the iterable contains only one value and returns that value. If the iterable contains more than one value or no values at all, it raises an exception indicating the issue.",1,"def only(it):
    if len(it) == 1:
        return next(iter(it))
    else:
        raise ValueError(""Iterable must contain exactly one value"")","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,only,"def only(it):
    if isinstance(it, Sized):
        if len(it) != 1:
            raise NotOneValueFound('Expected one value, found %s' % len(it))
        return list(it)[0]
    lst = tuple(islice(it, 2))
    if len(lst) == 0:
        raise NotOneValueFound('Expected one value, found 0')
    if len(lst) > 1:
        raise NotOneValueFound('Expected one value, found several', lst)
    return lst[0]","The function 'only' is designed to extract a single value from an iterable object. It checks if the iterable contains only one value and returns that value. If the iterable contains more than one value or no values at all, it raises an exception indicating the issue.",2,"def only(it):
    result = None
    count = 0
    
    for val in it:
        result = val
        count += 1
        if count > 1:
            raise ValueError(""Iterable contains more than one value"")
    
    if count == 0:
        raise ValueError(""Iterable is empty"")
    
    return result","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,only,"def only(it):
    if isinstance(it, Sized):
        if len(it) != 1:
            raise NotOneValueFound('Expected one value, found %s' % len(it))
        return list(it)[0]
    lst = tuple(islice(it, 2))
    if len(lst) == 0:
        raise NotOneValueFound('Expected one value, found 0')
    if len(lst) > 1:
        raise NotOneValueFound('Expected one value, found several', lst)
    return lst[0]","The function 'only' is designed to extract a single value from an iterable object. It checks if the iterable contains only one value and returns that value. If the iterable contains more than one value or no values at all, it raises an exception indicating the issue.",3,"def only(it):
    if len(it) == 1:
        return next(iter(it))
    elif len(it) > 1:
        raise ValueError(""Iterable contains more than one value"")
    else:
        raise ValueError(""Iterable is empty"")","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,walk_both_instructions,"def walk_both_instructions(original_instructions, original_start, instructions, start):
    """"""
    Yields matching indices and instructions from the new and original instructions,
    leaving out changes made by the sentinel transformation.
    """"""
    original_iter = islice(enumerate(original_instructions), original_start, None)
    new_iter = non_sentinel_instructions(instructions, start)
    inverted_comparison = False
    while True:
        try:
            original_i, original_inst = next(original_iter)
            new_i, new_inst = next(new_iter)
        except StopIteration:
            return
        if inverted_comparison and original_inst.opname != new_inst.opname == 'UNARY_NOT':
            new_i, new_inst = next(new_iter)
        inverted_comparison = original_inst.opname == new_inst.opname in ('CONTAINS_OP', 'IS_OP') and original_inst.arg != new_inst.arg
        yield (original_i, original_inst, new_i, new_inst)","The goal of the function `walk_both_instructions` is to compare two sets of instructions, one original and one modified, and yield matching indices and instructions while ignoring changes made by a specific transformation. This function is designed to iterate through the instructions from both sets, skipping certain comparisons based on the type of instructions and their arguments. The function aims to identify and return matching instructions between the original and modified sets while taking into account the specified transformation.",1,"def walk_both_instructions(original_instructions, original_start, instructions, start):
    original_index = original_start
    index = start
    
    while original_index < len(original_instructions) and index < len(instructions):
        original_instruction = original_instructions[original_index]
        instruction = instructions[index]
        
        if original_instruction == instruction:
            yield original_index, instruction
            original_index += 1
            index += 1
        else:
            original_index += 1","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,walk_both_instructions,"def walk_both_instructions(original_instructions, original_start, instructions, start):
    """"""
    Yields matching indices and instructions from the new and original instructions,
    leaving out changes made by the sentinel transformation.
    """"""
    original_iter = islice(enumerate(original_instructions), original_start, None)
    new_iter = non_sentinel_instructions(instructions, start)
    inverted_comparison = False
    while True:
        try:
            original_i, original_inst = next(original_iter)
            new_i, new_inst = next(new_iter)
        except StopIteration:
            return
        if inverted_comparison and original_inst.opname != new_inst.opname == 'UNARY_NOT':
            new_i, new_inst = next(new_iter)
        inverted_comparison = original_inst.opname == new_inst.opname in ('CONTAINS_OP', 'IS_OP') and original_inst.arg != new_inst.arg
        yield (original_i, original_inst, new_i, new_inst)","The goal of the function `walk_both_instructions` is to compare two sets of instructions, one original and one modified, and yield matching indices and instructions while ignoring changes made by a specific transformation. This function is designed to iterate through the instructions from both sets, skipping certain comparisons based on the type of instructions and their arguments. The function aims to identify and return matching instructions between the original and modified sets while taking into account the specified transformation.",2,"def walk_both_instructions(original_instructions, original_start, instructions, start):
    original_index = original_start
    index = start
    
    while original_index < len(original_instructions) and index < len(instructions):
        original_instruction = original_instructions[original_index]
        instruction = instructions[index]
        
        if original_instruction[0] == 'skip' or instruction[0] == 'skip':
            original_index += 1
            index += 1
            continue
        
        if original_instruction == instruction:
            yield original_index, instruction
            original_index += 1
            index += 1
        else:
            index += 1","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,walk_both_instructions,"def walk_both_instructions(original_instructions, original_start, instructions, start):
    """"""
    Yields matching indices and instructions from the new and original instructions,
    leaving out changes made by the sentinel transformation.
    """"""
    original_iter = islice(enumerate(original_instructions), original_start, None)
    new_iter = non_sentinel_instructions(instructions, start)
    inverted_comparison = False
    while True:
        try:
            original_i, original_inst = next(original_iter)
            new_i, new_inst = next(new_iter)
        except StopIteration:
            return
        if inverted_comparison and original_inst.opname != new_inst.opname == 'UNARY_NOT':
            new_i, new_inst = next(new_iter)
        inverted_comparison = original_inst.opname == new_inst.opname in ('CONTAINS_OP', 'IS_OP') and original_inst.arg != new_inst.arg
        yield (original_i, original_inst, new_i, new_inst)","The goal of the function `walk_both_instructions` is to compare two sets of instructions, one original and one modified, and yield matching indices and instructions while ignoring changes made by a specific transformation. This function is designed to iterate through the instructions from both sets, skipping certain comparisons based on the type of instructions and their arguments. The function aims to identify and return matching instructions between the original and modified sets while taking into account the specified transformation.",3,"def walk_both_instructions(original_instructions, original_start, instructions, start):
    original_index = original_start
    index = start
    
    while original_index < len(original_instructions) and index < len(instructions):
        original_instruction = original_instructions[original_index]
        instruction = instructions[index]
        
        if original_instruction[0] == instruction[0]:
            yield original_index, index, instruction
            original_index += 1
            index += 1
        else:
            if original_instruction[0] == ""transform"":
                original_index += 1
            if instruction[0] == ""transform"":
                index += 1
            if original_instruction[0] != ""transform"" and instruction[0] != ""transform"":
                original_index += 1
                index += 1","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,attr_names_match,"def attr_names_match(attr, argval):
    """"""
    Checks that the user-visible attr (from ast) can correspond to
    the argval in the bytecode, i.e. the real attribute fetched internally,
    which may be mangled for private attributes.
    """"""
    if attr == argval:
        return True
    if not attr.startswith('__'):
        return False
    return bool(re.match('^_\\w+%s$' % attr, argval))","The function `attr_names_match` compares a user-visible attribute to an internal attribute in bytecode, accounting for possible mangling of private attributes. It checks if the attributes match directly or if the user-visible attribute is a mangled version of the internal attribute, returning True if they correspond and False if they do not.",1,"def attr_names_match(attr, argval):
    if attr == argval:
        return True
    elif attr.startswith(""_"") and not argval.startswith(""_""):
        if f""_{argval}"" == attr:
            return True
    elif not attr.startswith(""_"") and argval.startswith(""_""):
        if f""_{attr}"" == argval:
            return True
    
    return False","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,attr_names_match,"def attr_names_match(attr, argval):
    """"""
    Checks that the user-visible attr (from ast) can correspond to
    the argval in the bytecode, i.e. the real attribute fetched internally,
    which may be mangled for private attributes.
    """"""
    if attr == argval:
        return True
    if not attr.startswith('__'):
        return False
    return bool(re.match('^_\\w+%s$' % attr, argval))","The function `attr_names_match` compares a user-visible attribute to an internal attribute in bytecode, accounting for possible mangling of private attributes. It checks if the attributes match directly or if the user-visible attribute is a mangled version of the internal attribute, returning True if they correspond and False if they do not.",2,"def attr_names_match(attr, argval):
    if attr == argval:
        return True
    elif attr.startswith(""_"") and argval == f""_{attr.__class__.__name__}{attr}"":
        return True
    else:
        return False","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,attr_names_match,"def attr_names_match(attr, argval):
    """"""
    Checks that the user-visible attr (from ast) can correspond to
    the argval in the bytecode, i.e. the real attribute fetched internally,
    which may be mangled for private attributes.
    """"""
    if attr == argval:
        return True
    if not attr.startswith('__'):
        return False
    return bool(re.match('^_\\w+%s$' % attr, argval))","The function `attr_names_match` compares a user-visible attribute to an internal attribute in bytecode, accounting for possible mangling of private attributes. It checks if the attributes match directly or if the user-visible attribute is a mangled version of the internal attribute, returning True if they correspond and False if they do not.",3,"def attr_names_match(attr, argval):
    if attr == argval:
        return True
    elif attr.startswith('_') and not argval.startswith('_'):
        if attr[1:] == argval:
            return True
    elif not attr.startswith('_') and argval.startswith('_'):
        if '_' + attr == argval:
            return True
    return False","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,for_filename,"@classmethod
def for_filename(cls, filename, module_globals=None, use_cache=True):
    if isinstance(filename, Path):
        filename = str(filename)

    def get_lines():
        return linecache.getlines(cast(str, filename), module_globals)
    entry = linecache.cache.get(filename)
    linecache.checkcache(filename)
    lines = get_lines()
    if entry is not None and (not lines):
        linecache.cache[filename] = entry
        lines = get_lines()
    return cls._for_filename_and_lines(filename, tuple(lines))","This function, named ""for_filename"", is designed to read and cache lines from a specified file. It takes the filename as input and optionally module_globals, and uses linecache to retrieve the lines from the file. The function checks if the lines are already cached and uses the cache if available, otherwise it caches the lines and returns them. This function is likely part of a class, as it utilizes a class attribute ""_for_filename_and_lines"". It serves the purpose of efficiently retrieving and caching lines from a file for further processing within the context of the class.",1,"def for_filename(cls, filename, module_globals, use_cache):
    if use_cache and filename in cls._for_filename_and_lines:
        return cls._for_filename_and_lines[filename]
    else:
        lines = linecache.getlines(filename, module_globals)
        cls._for_filename_and_lines[filename] = lines
        return lines","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,for_filename,"@classmethod
def for_filename(cls, filename, module_globals=None, use_cache=True):
    if isinstance(filename, Path):
        filename = str(filename)

    def get_lines():
        return linecache.getlines(cast(str, filename), module_globals)
    entry = linecache.cache.get(filename)
    linecache.checkcache(filename)
    lines = get_lines()
    if entry is not None and (not lines):
        linecache.cache[filename] = entry
        lines = get_lines()
    return cls._for_filename_and_lines(filename, tuple(lines))","This function, named ""for_filename"", is designed to read and cache lines from a specified file. It takes the filename as input and optionally module_globals, and uses linecache to retrieve the lines from the file. The function checks if the lines are already cached and uses the cache if available, otherwise it caches the lines and returns them. This function is likely part of a class, as it utilizes a class attribute ""_for_filename_and_lines"". It serves the purpose of efficiently retrieving and caching lines from a file for further processing within the context of the class.",2,"def for_filename(cls, filename, module_globals=None, use_cache=True):
    if not hasattr(cls, ""_for_filename_and_lines""):
        cls._for_filename_and_lines = {}

    if use_cache and filename in cls._for_filename_and_lines:
        return cls._for_filename_and_lines[filename]
    
    lines = linecache.getlines(filename, module_globals)
    cls._for_filename_and_lines[filename] = lines
    
    return lines","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,for_filename,"@classmethod
def for_filename(cls, filename, module_globals=None, use_cache=True):
    if isinstance(filename, Path):
        filename = str(filename)

    def get_lines():
        return linecache.getlines(cast(str, filename), module_globals)
    entry = linecache.cache.get(filename)
    linecache.checkcache(filename)
    lines = get_lines()
    if entry is not None and (not lines):
        linecache.cache[filename] = entry
        lines = get_lines()
    return cls._for_filename_and_lines(filename, tuple(lines))","This function, named ""for_filename"", is designed to read and cache lines from a specified file. It takes the filename as input and optionally module_globals, and uses linecache to retrieve the lines from the file. The function checks if the lines are already cached and uses the cache if available, otherwise it caches the lines and returns them. This function is likely part of a class, as it utilizes a class attribute ""_for_filename_and_lines"". It serves the purpose of efficiently retrieving and caching lines from a file for further processing within the context of the class.",3,"def for_filename(cls, filename, module_globals, use_cache):
    if use_cache and filename in cls._for_filename_and_lines:
        return cls._for_filename_and_lines[filename]
    
    lines = linecache.getlines(filename, module_globals)
    cls._for_filename_and_lines[filename] = lines
    
    return lines","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,_for_filename_and_lines,"@classmethod
def _for_filename_and_lines(cls, filename, lines):
    source_cache = cls._class_local('__source_cache_with_lines', {})
    try:
        return source_cache[filename, lines]
    except KeyError:
        pass
    result = source_cache[filename, lines] = cls(filename, lines)
    return result","This function is designed to retrieve or create an instance of the class based on a given filename and lines. It utilizes a class attribute to cache instances for faster retrieval in subsequent calls. If an instance with the same filename and lines already exists in the cache, it returns that instance; otherwise, it creates a new instance, adds it to the cache, and returns it.",1,"def _for_filename_and_lines(cls, filename, lines):
    if not hasattr(cls, '_instances'):
        cls._instances = {}
    
    key = (filename, lines)
    
    if key in cls._instances:
        return cls._instances[key]
    else:
        instance = cls.__new__(cls)
        instance.filename = filename
        instance.lines = lines
        cls._instances[key] = instance
        return instance","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,_for_filename_and_lines,"@classmethod
def _for_filename_and_lines(cls, filename, lines):
    source_cache = cls._class_local('__source_cache_with_lines', {})
    try:
        return source_cache[filename, lines]
    except KeyError:
        pass
    result = source_cache[filename, lines] = cls(filename, lines)
    return result","This function is designed to retrieve or create an instance of the class based on a given filename and lines. It utilizes a class attribute to cache instances for faster retrieval in subsequent calls. If an instance with the same filename and lines already exists in the cache, it returns that instance; otherwise, it creates a new instance, adds it to the cache, and returns it.",2,"def _for_filename_and_lines(cls, filename, lines):
    if not hasattr(cls, 'instances'):
        cls.instances = {}
    
    key = (filename, tuple(lines))
    
    if key in cls.instances:
        return cls.instances[key]
    else:
        instance = cls(filename, lines)
        cls.instances[key] = instance
        return instance","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,_for_filename_and_lines,"@classmethod
def _for_filename_and_lines(cls, filename, lines):
    source_cache = cls._class_local('__source_cache_with_lines', {})
    try:
        return source_cache[filename, lines]
    except KeyError:
        pass
    result = source_cache[filename, lines] = cls(filename, lines)
    return result","This function is designed to retrieve or create an instance of the class based on a given filename and lines. It utilizes a class attribute to cache instances for faster retrieval in subsequent calls. If an instance with the same filename and lines already exists in the cache, it returns that instance; otherwise, it creates a new instance, adds it to the cache, and returns it.",3,"def _for_filename_and_lines(cls, filename, lines):
    if not hasattr(cls, 'instances'):
        cls.instances = {}
    
    key = (filename, lines)
    if key in cls.instances:
        return cls.instances[key]
    else:
        instance = cls(filename, lines)
        cls.instances[key] = instance
        return instance","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,executing,"@classmethod
def executing(cls, frame_or_tb):
    """"""
        Returns an `Executing` object representing the operation
        currently executing in the given frame or traceback object.
        """"""
    if isinstance(frame_or_tb, types.TracebackType):
        tb = frame_or_tb
        frame = tb.tb_frame
        lineno = tb.tb_lineno
        lasti = tb.tb_lasti
    else:
        frame = frame_or_tb
        lineno = frame.f_lineno
        lasti = frame.f_lasti
    code = frame.f_code
    key = (code, id(code), lasti)
    executing_cache = cls._class_local('__executing_cache', {})
    args = executing_cache.get(key)
    if not args:
        node = stmts = decorator = None
        source = cls.for_frame(frame)
        tree = source.tree
        if tree:
            try:
                stmts = source.statements_at_line(lineno)
                if stmts:
                    if is_ipython_cell_code(code):
                        decorator, node = find_node_ipython(frame, lasti, stmts, source)
                    else:
                        node_finder = NodeFinder(frame, stmts, tree, lasti, source)
                        node = node_finder.result
                        decorator = node_finder.decorator
                if node:
                    new_stmts = {statement_containing_node(node)}
                    assert_(new_stmts <= stmts)
                    stmts = new_stmts
            except Exception:
                if TESTING:
                    raise
        executing_cache[key] = args = (source, node, stmts, decorator)
    return Executing(frame, *args)","The goal of the `executing` function is to return an `Executing` object that represents the operation currently executing in a given frame or traceback object. The function checks the frame or traceback object provided to determine the relevant information such as the frame code, line number, and last instruction. It then uses this information to retrieve or create a cache entry for the executing operation, including the source, node, statements, and decorator involved in the execution. The function ultimately returns the `Executing` object based on the provided frame and the cached or newly generated information.

This function appears to be a class method as it uses `cls` to access class attributes and methods within the implementation. It interacts with the class context by utilizing a class-local cache (`__executing_cache`) to store and retrieve information about the executing operations. The function leverages class attributes and potentially other methods to gather information about the executing operation and construct the `Executing` object.",1,"def executing(cls, frame_or_tb):
    executing_obj = cls.__executing_cache.get(frame_or_tb, None)
    if executing_obj is None:
        # Logic to retrieve or create the executing object
        executing_obj = Executing(frame_or_tb)
        cls.__executing_cache[frame_or_tb] = executing_obj
    return executing_obj","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,executing,"@classmethod
def executing(cls, frame_or_tb):
    """"""
        Returns an `Executing` object representing the operation
        currently executing in the given frame or traceback object.
        """"""
    if isinstance(frame_or_tb, types.TracebackType):
        tb = frame_or_tb
        frame = tb.tb_frame
        lineno = tb.tb_lineno
        lasti = tb.tb_lasti
    else:
        frame = frame_or_tb
        lineno = frame.f_lineno
        lasti = frame.f_lasti
    code = frame.f_code
    key = (code, id(code), lasti)
    executing_cache = cls._class_local('__executing_cache', {})
    args = executing_cache.get(key)
    if not args:
        node = stmts = decorator = None
        source = cls.for_frame(frame)
        tree = source.tree
        if tree:
            try:
                stmts = source.statements_at_line(lineno)
                if stmts:
                    if is_ipython_cell_code(code):
                        decorator, node = find_node_ipython(frame, lasti, stmts, source)
                    else:
                        node_finder = NodeFinder(frame, stmts, tree, lasti, source)
                        node = node_finder.result
                        decorator = node_finder.decorator
                if node:
                    new_stmts = {statement_containing_node(node)}
                    assert_(new_stmts <= stmts)
                    stmts = new_stmts
            except Exception:
                if TESTING:
                    raise
        executing_cache[key] = args = (source, node, stmts, decorator)
    return Executing(frame, *args)","The goal of the `executing` function is to return an `Executing` object that represents the operation currently executing in a given frame or traceback object. The function checks the frame or traceback object provided to determine the relevant information such as the frame code, line number, and last instruction. It then uses this information to retrieve or create a cache entry for the executing operation, including the source, node, statements, and decorator involved in the execution. The function ultimately returns the `Executing` object based on the provided frame and the cached or newly generated information.

This function appears to be a class method as it uses `cls` to access class attributes and methods within the implementation. It interacts with the class context by utilizing a class-local cache (`__executing_cache`) to store and retrieve information about the executing operations. The function leverages class attributes and potentially other methods to gather information about the executing operation and construct the `Executing` object.",2,"def executing(cls, frame_or_tb):
    executing_obj = cls.__executing_cache.get(frame_or_tb, None)
    
    if executing_obj is None:
        # Generate executing object based on frame_or_tb
        # Some implementation here
        
        executing_obj = Executing(...)  # Constructing Executing object
        
        cls.__executing_cache[frame_or_tb] = executing_obj  # Storing in cache
    
    return executing_obj","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,executing,"@classmethod
def executing(cls, frame_or_tb):
    """"""
        Returns an `Executing` object representing the operation
        currently executing in the given frame or traceback object.
        """"""
    if isinstance(frame_or_tb, types.TracebackType):
        tb = frame_or_tb
        frame = tb.tb_frame
        lineno = tb.tb_lineno
        lasti = tb.tb_lasti
    else:
        frame = frame_or_tb
        lineno = frame.f_lineno
        lasti = frame.f_lasti
    code = frame.f_code
    key = (code, id(code), lasti)
    executing_cache = cls._class_local('__executing_cache', {})
    args = executing_cache.get(key)
    if not args:
        node = stmts = decorator = None
        source = cls.for_frame(frame)
        tree = source.tree
        if tree:
            try:
                stmts = source.statements_at_line(lineno)
                if stmts:
                    if is_ipython_cell_code(code):
                        decorator, node = find_node_ipython(frame, lasti, stmts, source)
                    else:
                        node_finder = NodeFinder(frame, stmts, tree, lasti, source)
                        node = node_finder.result
                        decorator = node_finder.decorator
                if node:
                    new_stmts = {statement_containing_node(node)}
                    assert_(new_stmts <= stmts)
                    stmts = new_stmts
            except Exception:
                if TESTING:
                    raise
        executing_cache[key] = args = (source, node, stmts, decorator)
    return Executing(frame, *args)","The goal of the `executing` function is to return an `Executing` object that represents the operation currently executing in a given frame or traceback object. The function checks the frame or traceback object provided to determine the relevant information such as the frame code, line number, and last instruction. It then uses this information to retrieve or create a cache entry for the executing operation, including the source, node, statements, and decorator involved in the execution. The function ultimately returns the `Executing` object based on the provided frame and the cached or newly generated information.

This function appears to be a class method as it uses `cls` to access class attributes and methods within the implementation. It interacts with the class context by utilizing a class-local cache (`__executing_cache`) to store and retrieve information about the executing operations. The function leverages class attributes and potentially other methods to gather information about the executing operation and construct the `Executing` object.",3,"def executing(cls, frame_or_tb):
    executing_obj = cls.__executing_cache.get(frame_or_tb)
    if executing_obj:
        return executing_obj
    
    frame_code = frame_or_tb.f_code if hasattr(frame_or_tb, 'f_code') else None
    line_number = frame_or_tb.f_lineno if hasattr(frame_or_tb, 'f_lineno') else None
    last_instruction = frame_or_tb.f_lasti if hasattr(frame_or_tb, 'f_lasti') else None
    
    source = frame_code.co_filename if frame_code else None
    node = frame_code.co_name if frame_code else None
    statements = frame_code.co_consts if frame_code else None
    decorator = frame_code.co_varnames if frame_code else None
    
    executing_obj = Executing(source, node, statements, decorator)
    cls.__executing_cache[frame_or_tb] = executing_obj
    
    return executing_obj","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,_class_local,"@classmethod
def _class_local(cls, name, default):
    """"""
        Returns an attribute directly associated with this class
        (as opposed to subclasses), setting default if necessary
        """"""
    result = cls.__dict__.get(name, default)
    setattr(cls, name, result)
    return result","This function is designed to retrieve an attribute directly associated with a class, rather than its subclasses. If the attribute is not found, it will set a default value for the attribute. This function interacts with the class context by accessing the class dictionary to check for the attribute and set it if necessary.",1,"def _class_local(cls, name, default):
    if hasattr(cls, name):
        return getattr(cls, name)
    else:
        setattr(cls, name, default)
        return default","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,_class_local,"@classmethod
def _class_local(cls, name, default):
    """"""
        Returns an attribute directly associated with this class
        (as opposed to subclasses), setting default if necessary
        """"""
    result = cls.__dict__.get(name, default)
    setattr(cls, name, result)
    return result","This function is designed to retrieve an attribute directly associated with a class, rather than its subclasses. If the attribute is not found, it will set a default value for the attribute. This function interacts with the class context by accessing the class dictionary to check for the attribute and set it if necessary.",2,"def _class_local(cls, name, default):
    if hasattr(cls, name):
        return getattr(cls, name)
    else:
        setattr(cls, name, default)
        return default","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,_class_local,"@classmethod
def _class_local(cls, name, default):
    """"""
        Returns an attribute directly associated with this class
        (as opposed to subclasses), setting default if necessary
        """"""
    result = cls.__dict__.get(name, default)
    setattr(cls, name, result)
    return result","This function is designed to retrieve an attribute directly associated with a class, rather than its subclasses. If the attribute is not found, it will set a default value for the attribute. This function interacts with the class context by accessing the class dictionary to check for the attribute and set it if necessary.",3,"def _class_local(cls, name, default):
    if name in cls.__dict__:
        return getattr(cls, name)
    else:
        setattr(cls, name, default)
        return default","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,asttext,"def asttext(self):
    """"""
        Returns an ASTText object for getting the source of specific AST nodes.

        See http://asttokens.readthedocs.io/en/latest/api-index.html
        """"""
    from asttokens import ASTText
    if self._asttext is None:
        self._asttext = ASTText(self.text, tree=self.tree, filename=self.filename)
    return self._asttext","This function aims to return an ASTText object that allows for obtaining the source of specific AST nodes. The ASTText object is created using the input text, AST tree, and filename. If the ASTText object has not been initialized yet, it will be created and returned. This function is useful for working with abstract syntax trees and accessing source code information related to specific nodes.",1,"def asttext(self):
    if self.ast_text_obj is None:
        self.ast_text_obj = ASTText(self.input_text, self.ast_tree, self.filename)
    return self.ast_text_obj","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,asttext,"def asttext(self):
    """"""
        Returns an ASTText object for getting the source of specific AST nodes.

        See http://asttokens.readthedocs.io/en/latest/api-index.html
        """"""
    from asttokens import ASTText
    if self._asttext is None:
        self._asttext = ASTText(self.text, tree=self.tree, filename=self.filename)
    return self._asttext","This function aims to return an ASTText object that allows for obtaining the source of specific AST nodes. The ASTText object is created using the input text, AST tree, and filename. If the ASTText object has not been initialized yet, it will be created and returned. This function is useful for working with abstract syntax trees and accessing source code information related to specific nodes.",2,"def asttext(self):
    if not hasattr(self, 'ASTText'):
        self.ASTText = ASTText(self.input_text, self.ast_tree, self.filename)
    return self.ASTText","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,asttext,"def asttext(self):
    """"""
        Returns an ASTText object for getting the source of specific AST nodes.

        See http://asttokens.readthedocs.io/en/latest/api-index.html
        """"""
    from asttokens import ASTText
    if self._asttext is None:
        self._asttext = ASTText(self.text, tree=self.tree, filename=self.filename)
    return self._asttext","This function aims to return an ASTText object that allows for obtaining the source of specific AST nodes. The ASTText object is created using the input text, AST tree, and filename. If the ASTText object has not been initialized yet, it will be created and returned. This function is useful for working with abstract syntax trees and accessing source code information related to specific nodes.",3,"def asttext(self):
    if not hasattr(self, 'ASTText_object'):
        self.ASTText_object = ASTText(self.input_text, self.AST_tree, self.filename)
    return self.ASTText_object","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,asttokens,"def asttokens(self):
    """"""
        Returns an ASTTokens object for getting the source of specific AST nodes.

        See http://asttokens.readthedocs.io/en/latest/api-index.html
        """"""
    import asttokens
    if self._asttokens is None:
        if hasattr(asttokens, 'ASTText'):
            self._asttokens = self.asttext().asttokens
        else:
            self._asttokens = asttokens.ASTTokens(self.text, tree=self.tree, filename=self.filename)
    return self._asttokens","This function is designed to return an ASTTokens object, which can be used to obtain the source code associated with specific nodes in an Abstract Syntax Tree (AST). The function checks if an ASTTokens object has already been created for the current context and returns it if available, otherwise it creates a new ASTTokens object using the text, tree, and filename attributes of the current context. This can be useful for analyzing and working with the source code at a more granular level within the AST.",1,"def asttokens(self):
    if hasattr(self, 'ast_tokens'):
        return self.ast_tokens
    else:
        self.ast_tokens = ASTTokens(text=self.text, tree=self.tree, filename=self.filename)
        return self.ast_tokens","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,asttokens,"def asttokens(self):
    """"""
        Returns an ASTTokens object for getting the source of specific AST nodes.

        See http://asttokens.readthedocs.io/en/latest/api-index.html
        """"""
    import asttokens
    if self._asttokens is None:
        if hasattr(asttokens, 'ASTText'):
            self._asttokens = self.asttext().asttokens
        else:
            self._asttokens = asttokens.ASTTokens(self.text, tree=self.tree, filename=self.filename)
    return self._asttokens","This function is designed to return an ASTTokens object, which can be used to obtain the source code associated with specific nodes in an Abstract Syntax Tree (AST). The function checks if an ASTTokens object has already been created for the current context and returns it if available, otherwise it creates a new ASTTokens object using the text, tree, and filename attributes of the current context. This can be useful for analyzing and working with the source code at a more granular level within the AST.",2,"def asttokens(self):
    if hasattr(self, 'asttokens_obj'):
        return self.asttokens_obj
    else:
        self.asttokens_obj = ASTTokens(text=self.text, tree=self.tree, filename=self.filename)
        return self.asttokens_obj","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,asttokens,"def asttokens(self):
    """"""
        Returns an ASTTokens object for getting the source of specific AST nodes.

        See http://asttokens.readthedocs.io/en/latest/api-index.html
        """"""
    import asttokens
    if self._asttokens is None:
        if hasattr(asttokens, 'ASTText'):
            self._asttokens = self.asttext().asttokens
        else:
            self._asttokens = asttokens.ASTTokens(self.text, tree=self.tree, filename=self.filename)
    return self._asttokens","This function is designed to return an ASTTokens object, which can be used to obtain the source code associated with specific nodes in an Abstract Syntax Tree (AST). The function checks if an ASTTokens object has already been created for the current context and returns it if available, otherwise it creates a new ASTTokens object using the text, tree, and filename attributes of the current context. This can be useful for analyzing and working with the source code at a more granular level within the AST.",3,"def asttokens(self):
    if hasattr(self, 'ast_tokens'):
        return self.ast_tokens
    else:
        self.ast_tokens = ASTTokens(text=self.text, tree=self.tree, filename=self.filename)
        return self.ast_tokens","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,add_qualname,"def add_qualname(self, node, name=None):
    name = name or node.name
    self.stack.append(name)
    if getattr(node, 'decorator_list', ()):
        lineno = node.decorator_list[0].lineno
    else:
        lineno = node.lineno
    self.qualnames.setdefault((name, lineno), '.'.join(self.stack))","The goal of the function `add_qualname` is to add a qualified name to a stack based on a given node's name. 
If the node has a decorator list, it considers the first decorator's line number for the qualified name, 
otherwise, it uses the node's line number. The qualified name is then stored in a dictionary based on the node's name and line number. 
This function helps in organizing and managing qualified names within a specific context.",1,"def add_qualname(self, node, name):
    qual_name = """"
    if hasattr(node, 'decorator_list') and node.decorator_list:
        qual_name = f""{node.decorator_list[0].lineno}_{name}""
    else:
        qual_name = f""{node.lineno}_{name}""
    
    self.qual_names[name] = qual_name","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,add_qualname,"def add_qualname(self, node, name=None):
    name = name or node.name
    self.stack.append(name)
    if getattr(node, 'decorator_list', ()):
        lineno = node.decorator_list[0].lineno
    else:
        lineno = node.lineno
    self.qualnames.setdefault((name, lineno), '.'.join(self.stack))","The goal of the function `add_qualname` is to add a qualified name to a stack based on a given node's name. 
If the node has a decorator list, it considers the first decorator's line number for the qualified name, 
otherwise, it uses the node's line number. The qualified name is then stored in a dictionary based on the node's name and line number. 
This function helps in organizing and managing qualified names within a specific context.",2,"def add_qualname(self, node, name):
    qual_name = name + '_' + str(node.lineno) if hasattr(node, 'decorator_list') and node.decorator_list else name + '_' + str(node.lineno)
    self.qualname_dict[name] = qual_name","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,add_qualname,"def add_qualname(self, node, name=None):
    name = name or node.name
    self.stack.append(name)
    if getattr(node, 'decorator_list', ()):
        lineno = node.decorator_list[0].lineno
    else:
        lineno = node.lineno
    self.qualnames.setdefault((name, lineno), '.'.join(self.stack))","The goal of the function `add_qualname` is to add a qualified name to a stack based on a given node's name. 
If the node has a decorator list, it considers the first decorator's line number for the qualified name, 
otherwise, it uses the node's line number. The qualified name is then stored in a dictionary based on the node's name and line number. 
This function helps in organizing and managing qualified names within a specific context.",3,"def add_qualname(self, node, name):
    if node.decorator_list:
        line_number = node.decorator_list[0].lineno
    else:
        line_number = node.lineno
    
    qualified_name = f""{name}_{line_number}""
    
    if name not in self.qualname_dict:
        self.qualname_dict[name] = {}
        
    self.qualname_dict[name][line_number] = qualified_name","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,visit_FunctionDef,"def visit_FunctionDef(self, node, name=None):
    assert isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.Lambda)), node
    self.add_qualname(node, name)
    self.stack.append('<locals>')
    children = []
    if isinstance(node, ast.Lambda):
        children = [node.body]
    else:
        children = node.body
    for child in children:
        self.visit(child)
    self.stack.pop()
    self.stack.pop()
    for field, child in ast.iter_fields(node):
        if field == 'body':
            continue
        if isinstance(child, ast.AST):
            self.visit(child)
        elif isinstance(child, list):
            for grandchild in child:
                if isinstance(grandchild, ast.AST):
                    self.visit(grandchild)","The goal of the `visit_FunctionDef` function is to traverse the abstract syntax tree (AST) representation of a function definition and its body. This function is likely a method within a class that handles the analysis or manipulation of Python code. It recursively visits the nodes within the function definition, including any nested functions or expressions, while keeping track of the context within the code. It adds the function's qualified name to a stack, visits the body of the function, and then removes the function's context from the stack after processing it. The function also iterates over the fields of the function definition, skipping the body field, and recursively visits any child nodes found within these fields.",1,"def visit_FunctionDef(self, node, name):
    self.stack.append(name)
    
    for field, value in ast.iter_fields(node):
        if field == 'body':
            continue
        
        if isinstance(value, ast.AST):
            self.generic_visit(value)
        elif isinstance(value, list):
            for item in value:
                if isinstance(item, ast.AST):
                    self.generic_visit(item)
    
    self.stack.pop()","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,visit_FunctionDef,"def visit_FunctionDef(self, node, name=None):
    assert isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.Lambda)), node
    self.add_qualname(node, name)
    self.stack.append('<locals>')
    children = []
    if isinstance(node, ast.Lambda):
        children = [node.body]
    else:
        children = node.body
    for child in children:
        self.visit(child)
    self.stack.pop()
    self.stack.pop()
    for field, child in ast.iter_fields(node):
        if field == 'body':
            continue
        if isinstance(child, ast.AST):
            self.visit(child)
        elif isinstance(child, list):
            for grandchild in child:
                if isinstance(grandchild, ast.AST):
                    self.visit(grandchild)","The goal of the `visit_FunctionDef` function is to traverse the abstract syntax tree (AST) representation of a function definition and its body. This function is likely a method within a class that handles the analysis or manipulation of Python code. It recursively visits the nodes within the function definition, including any nested functions or expressions, while keeping track of the context within the code. It adds the function's qualified name to a stack, visits the body of the function, and then removes the function's context from the stack after processing it. The function also iterates over the fields of the function definition, skipping the body field, and recursively visits any child nodes found within these fields.",2,"def visit_FunctionDef(self, node, name):
    self.function_stack.append(name)
    
    for field, value in ast.iter_fields(node):
        if field == 'body':
            continue
        
        if isinstance(value, list):
            for item in value:
                if isinstance(item, ast.AST):
                    self.visit(item, name)
        elif isinstance(value, ast.AST):
            self.visit(value, name)
    
    self.visit(node.body, name)
    
    self.function_stack.remove(name)","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,visit_FunctionDef,"def visit_FunctionDef(self, node, name=None):
    assert isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.Lambda)), node
    self.add_qualname(node, name)
    self.stack.append('<locals>')
    children = []
    if isinstance(node, ast.Lambda):
        children = [node.body]
    else:
        children = node.body
    for child in children:
        self.visit(child)
    self.stack.pop()
    self.stack.pop()
    for field, child in ast.iter_fields(node):
        if field == 'body':
            continue
        if isinstance(child, ast.AST):
            self.visit(child)
        elif isinstance(child, list):
            for grandchild in child:
                if isinstance(grandchild, ast.AST):
                    self.visit(grandchild)","The goal of the `visit_FunctionDef` function is to traverse the abstract syntax tree (AST) representation of a function definition and its body. This function is likely a method within a class that handles the analysis or manipulation of Python code. It recursively visits the nodes within the function definition, including any nested functions or expressions, while keeping track of the context within the code. It adds the function's qualified name to a stack, visits the body of the function, and then removes the function's context from the stack after processing it. The function also iterates over the fields of the function definition, skipping the body field, and recursively visits any child nodes found within these fields.",3,"def visit_FunctionDef(self, node, name):
    stack.append(name)
    
    for field, value in ast.iter_fields(node):
        if field != 'body':
            if isinstance(value, list):
                for item in value:
                    if isinstance(item, ast.AST):
                        self.visit(item, name)
            elif isinstance(value, ast.AST):
                self.visit(value, name)
    
    for stmt in node.body:
        self.visit(stmt, name)
    
    stack.pop()","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,visit_ClassDef,"def visit_ClassDef(self, node):
    assert isinstance(node, ast.ClassDef)
    self.add_qualname(node)
    self.generic_visit(node)
    self.stack.pop()","The goal of this function is to visit a class definition node in an abstract syntax tree (AST) and perform certain operations, such as adding the class name to a list and then removing it from the stack after visiting the node. This function is part of a larger codebase that analyzes Python code and manipulates its structure based on the AST.",1,"def visit_ClassDef(self, node):
    class_name = node.name
    self.class_names.append(class_name)
    self.stack.remove(node)","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,visit_ClassDef,"def visit_ClassDef(self, node):
    assert isinstance(node, ast.ClassDef)
    self.add_qualname(node)
    self.generic_visit(node)
    self.stack.pop()","The goal of this function is to visit a class definition node in an abstract syntax tree (AST) and perform certain operations, such as adding the class name to a list and then removing it from the stack after visiting the node. This function is part of a larger codebase that analyzes Python code and manipulates its structure based on the AST.",2,"def visit_ClassDef(self, node):
    class_name = node.name
    self.class_names.append(class_name)
    self.stack.pop()","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,visit_ClassDef,"def visit_ClassDef(self, node):
    assert isinstance(node, ast.ClassDef)
    self.add_qualname(node)
    self.generic_visit(node)
    self.stack.pop()","The goal of this function is to visit a class definition node in an abstract syntax tree (AST) and perform certain operations, such as adding the class name to a list and then removing it from the stack after visiting the node. This function is part of a larger codebase that analyzes Python code and manipulates its structure based on the AST.",3,"def visit_ClassDef(self, node):
    class_name = node.name
    self.class_names.append(class_name)
    # Perform certain operations here
    self.class_names.remove(class_name)","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,find_decorator,"def find_decorator(self, stmts):
    stmt = only(stmts)
    assert_(isinstance(stmt, (ast.ClassDef, function_node_types)))
    decorators = stmt.decorator_list
    assert_(decorators)
    line_instructions = [inst for inst in self.clean_instructions(self.code) if inst.lineno == self.frame.f_lineno]
    last_decorator_instruction_index = [i for i, inst in enumerate(line_instructions) if inst.opname == 'CALL_FUNCTION'][-1]
    assert_(line_instructions[last_decorator_instruction_index + 1].opname.startswith('STORE_'))
    decorator_instructions = line_instructions[last_decorator_instruction_index - len(decorators) + 1:last_decorator_instruction_index + 1]
    assert_({inst.opname for inst in decorator_instructions} == {'CALL_FUNCTION'})
    decorator_index = decorator_instructions.index(self.instruction)
    decorator = decorators[::-1][decorator_index]
    self.decorator = decorator
    self.result = stmt",The function `find_decorator` is designed to identify the decorator of a specific statement within a given set of statements. It checks the decorators of the statement and matches them with corresponding instructions in the code to accurately determine the decorator being used. This function helps in understanding which decorator is applied to a specific statement in Python code.,1,"def find_decorator(self, stmts):
    for stmt in stmts:
        if stmt.startswith('@'):
            return stmt.split('(')[0].lstrip('@').strip()","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,find_decorator,"def find_decorator(self, stmts):
    stmt = only(stmts)
    assert_(isinstance(stmt, (ast.ClassDef, function_node_types)))
    decorators = stmt.decorator_list
    assert_(decorators)
    line_instructions = [inst for inst in self.clean_instructions(self.code) if inst.lineno == self.frame.f_lineno]
    last_decorator_instruction_index = [i for i, inst in enumerate(line_instructions) if inst.opname == 'CALL_FUNCTION'][-1]
    assert_(line_instructions[last_decorator_instruction_index + 1].opname.startswith('STORE_'))
    decorator_instructions = line_instructions[last_decorator_instruction_index - len(decorators) + 1:last_decorator_instruction_index + 1]
    assert_({inst.opname for inst in decorator_instructions} == {'CALL_FUNCTION'})
    decorator_index = decorator_instructions.index(self.instruction)
    decorator = decorators[::-1][decorator_index]
    self.decorator = decorator
    self.result = stmt",The function `find_decorator` is designed to identify the decorator of a specific statement within a given set of statements. It checks the decorators of the statement and matches them with corresponding instructions in the code to accurately determine the decorator being used. This function helps in understanding which decorator is applied to a specific statement in Python code.,2,"def find_decorator(self, stmts):
    for stmt in stmts:
        if hasattr(stmt, '__decorators__'):
            return stmt.__decorators__
    return None","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,find_decorator,"def find_decorator(self, stmts):
    stmt = only(stmts)
    assert_(isinstance(stmt, (ast.ClassDef, function_node_types)))
    decorators = stmt.decorator_list
    assert_(decorators)
    line_instructions = [inst for inst in self.clean_instructions(self.code) if inst.lineno == self.frame.f_lineno]
    last_decorator_instruction_index = [i for i, inst in enumerate(line_instructions) if inst.opname == 'CALL_FUNCTION'][-1]
    assert_(line_instructions[last_decorator_instruction_index + 1].opname.startswith('STORE_'))
    decorator_instructions = line_instructions[last_decorator_instruction_index - len(decorators) + 1:last_decorator_instruction_index + 1]
    assert_({inst.opname for inst in decorator_instructions} == {'CALL_FUNCTION'})
    decorator_index = decorator_instructions.index(self.instruction)
    decorator = decorators[::-1][decorator_index]
    self.decorator = decorator
    self.result = stmt",The function `find_decorator` is designed to identify the decorator of a specific statement within a given set of statements. It checks the decorators of the statement and matches them with corresponding instructions in the code to accurately determine the decorator being used. This function helps in understanding which decorator is applied to a specific statement in Python code.,3,"def find_decorator(self, stmts):
    for stmt in stmts:
        if '@' in stmt:
            return stmt.split('@')[1].strip()","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,find_codes,"def find_codes(self, root_code):
    checks = [attrgetter('co_firstlineno'), attrgetter('co_freevars'), attrgetter('co_cellvars'), lambda c: is_ipython_cell_code_name(c.co_name) or c.co_name]
    if not self.is_pytest:
        checks += [attrgetter('co_names'), attrgetter('co_varnames')]

    def matches(c):
        return all((f(c) == f(self.code) for f in checks))
    code_options = []
    if matches(root_code):
        code_options.append(root_code)

    def finder(code):
        for const in code.co_consts:
            if not inspect.iscode(const):
                continue
            if matches(const):
                code_options.append(const)
            finder(const)
    finder(root_code)
    return code_options","The `find_codes` function aims to search for specific code objects within a given root code object based on certain criteria. It iterates through the constants of the root code object, checking if each constant meets the specified criteria. If a constant matches the criteria, it is added to a list of code options. The function ultimately returns a list of code objects that meet the criteria.

If this function is part of a class, it likely interacts with class attributes or methods to access the necessary information for comparison and filtering of code objects. The function may rely on class attributes to determine additional checks or conditions for code object matching.",1,"def find_codes(self, root_code):
    code_options = []
    
    for constant in root_code.constants:
        if constant.meets_criteria():
            code_options.append(constant)
    
    return code_options","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,find_codes,"def find_codes(self, root_code):
    checks = [attrgetter('co_firstlineno'), attrgetter('co_freevars'), attrgetter('co_cellvars'), lambda c: is_ipython_cell_code_name(c.co_name) or c.co_name]
    if not self.is_pytest:
        checks += [attrgetter('co_names'), attrgetter('co_varnames')]

    def matches(c):
        return all((f(c) == f(self.code) for f in checks))
    code_options = []
    if matches(root_code):
        code_options.append(root_code)

    def finder(code):
        for const in code.co_consts:
            if not inspect.iscode(const):
                continue
            if matches(const):
                code_options.append(const)
            finder(const)
    finder(root_code)
    return code_options","The `find_codes` function aims to search for specific code objects within a given root code object based on certain criteria. It iterates through the constants of the root code object, checking if each constant meets the specified criteria. If a constant matches the criteria, it is added to a list of code options. The function ultimately returns a list of code objects that meet the criteria.

If this function is part of a class, it likely interacts with class attributes or methods to access the necessary information for comparison and filtering of code objects. The function may rely on class attributes to determine additional checks or conditions for code object matching.",2,"def find_codes(self, root_code):
    code_options = []
    
    for constant in root_code.constants:
        if constant.meets_criteria():
            code_options.append(constant)
            
    return code_options","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,find_codes,"def find_codes(self, root_code):
    checks = [attrgetter('co_firstlineno'), attrgetter('co_freevars'), attrgetter('co_cellvars'), lambda c: is_ipython_cell_code_name(c.co_name) or c.co_name]
    if not self.is_pytest:
        checks += [attrgetter('co_names'), attrgetter('co_varnames')]

    def matches(c):
        return all((f(c) == f(self.code) for f in checks))
    code_options = []
    if matches(root_code):
        code_options.append(root_code)

    def finder(code):
        for const in code.co_consts:
            if not inspect.iscode(const):
                continue
            if matches(const):
                code_options.append(const)
            finder(const)
    finder(root_code)
    return code_options","The `find_codes` function aims to search for specific code objects within a given root code object based on certain criteria. It iterates through the constants of the root code object, checking if each constant meets the specified criteria. If a constant matches the criteria, it is added to a list of code options. The function ultimately returns a list of code objects that meet the criteria.

If this function is part of a class, it likely interacts with class attributes or methods to access the necessary information for comparison and filtering of code objects. The function may rely on class attributes to determine additional checks or conditions for code object matching.",3,"def find_codes(self, root_code):
    code_options = []
    
    for constant in root_code.constants:
        if constant.meets_criteria():
            code_options.append(constant)
    
    return code_options","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,mangled_name,"def mangled_name(node: EnhancedAST) -> str:
    """"""

    Parameters:
        node: the node which should be mangled
        name: the name of the node

    Returns:
        The mangled name of `node`
    """"""
    if isinstance(node, ast.Attribute):
        name = node.attr
    elif isinstance(node, ast.Name):
        name = node.id
    elif isinstance(node, ast.alias):
        name = node.asname or node.name.split('.')[0]
    elif isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)):
        name = node.name
    elif isinstance(node, ast.ExceptHandler):
        assert node.name
        name = node.name
    elif sys.version_info >= (3, 12) and isinstance(node, ast.TypeVar):
        name = node.name
    else:
        raise TypeError('no node to mangle for type ' + repr(type(node)))
    if name.startswith('__') and (not name.endswith('__')):
        parent, child = (node.parent, node)
        while not (isinstance(parent, ast.ClassDef) and child not in parent.bases):
            if not hasattr(parent, 'parent'):
                break
            parent, child = (parent.parent, parent)
        else:
            class_name = parent.name.lstrip('_')
            if class_name != '':
                return '_' + class_name + name
    return name","The goal of the `mangled_name` function is to return a mangled name for a given node in an Enhanced Abstract Syntax Tree (AST). The function checks the type of the node and determines the appropriate mangled name based on certain criteria. If the node is of a specific type, such as `Attribute`, `Name`, `FunctionDef`, `ClassDef`, `ExceptHandler`, or `TypeVar`, the function retrieves the name associated with the node. If the name starts with '__' but does not end with '__', the function prefixes the name with the parent class name to create a mangled name. This mangled name is then returned as the output of the function.",1,"def mangled_name(node):
    if isinstance(node, (ast.Attribute, ast.Name, ast.FunctionDef, ast.ClassDef, ast.ExceptHandler, ast.TypeVar)):
        name = getattr(node, 'id', None)
        if name and name.startswith('__') and not name.endswith('__'):
            parent_name = getattr(node, 'parent_class_name', None)
            if parent_name:
                return f""{parent_name}_{name}""
    return None","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,mangled_name,"def mangled_name(node: EnhancedAST) -> str:
    """"""

    Parameters:
        node: the node which should be mangled
        name: the name of the node

    Returns:
        The mangled name of `node`
    """"""
    if isinstance(node, ast.Attribute):
        name = node.attr
    elif isinstance(node, ast.Name):
        name = node.id
    elif isinstance(node, ast.alias):
        name = node.asname or node.name.split('.')[0]
    elif isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)):
        name = node.name
    elif isinstance(node, ast.ExceptHandler):
        assert node.name
        name = node.name
    elif sys.version_info >= (3, 12) and isinstance(node, ast.TypeVar):
        name = node.name
    else:
        raise TypeError('no node to mangle for type ' + repr(type(node)))
    if name.startswith('__') and (not name.endswith('__')):
        parent, child = (node.parent, node)
        while not (isinstance(parent, ast.ClassDef) and child not in parent.bases):
            if not hasattr(parent, 'parent'):
                break
            parent, child = (parent.parent, parent)
        else:
            class_name = parent.name.lstrip('_')
            if class_name != '':
                return '_' + class_name + name
    return name","The goal of the `mangled_name` function is to return a mangled name for a given node in an Enhanced Abstract Syntax Tree (AST). The function checks the type of the node and determines the appropriate mangled name based on certain criteria. If the node is of a specific type, such as `Attribute`, `Name`, `FunctionDef`, `ClassDef`, `ExceptHandler`, or `TypeVar`, the function retrieves the name associated with the node. If the name starts with '__' but does not end with '__', the function prefixes the name with the parent class name to create a mangled name. This mangled name is then returned as the output of the function.",2,"def mangled_name(node):
    if isinstance(node, (Attribute, Name, FunctionDef, ClassDef, ExceptHandler, TypeVar)):
        name = getattr(node, 'id', None)
        if name and name.startswith('__') and not name.endswith('__'):
            parent_name = getattr(node, 'parent_class_name', None)
            if parent_name:
                return f""{parent_name}_{name}""
    return None","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,mangled_name,"def mangled_name(node: EnhancedAST) -> str:
    """"""

    Parameters:
        node: the node which should be mangled
        name: the name of the node

    Returns:
        The mangled name of `node`
    """"""
    if isinstance(node, ast.Attribute):
        name = node.attr
    elif isinstance(node, ast.Name):
        name = node.id
    elif isinstance(node, ast.alias):
        name = node.asname or node.name.split('.')[0]
    elif isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)):
        name = node.name
    elif isinstance(node, ast.ExceptHandler):
        assert node.name
        name = node.name
    elif sys.version_info >= (3, 12) and isinstance(node, ast.TypeVar):
        name = node.name
    else:
        raise TypeError('no node to mangle for type ' + repr(type(node)))
    if name.startswith('__') and (not name.endswith('__')):
        parent, child = (node.parent, node)
        while not (isinstance(parent, ast.ClassDef) and child not in parent.bases):
            if not hasattr(parent, 'parent'):
                break
            parent, child = (parent.parent, parent)
        else:
            class_name = parent.name.lstrip('_')
            if class_name != '':
                return '_' + class_name + name
    return name","The goal of the `mangled_name` function is to return a mangled name for a given node in an Enhanced Abstract Syntax Tree (AST). The function checks the type of the node and determines the appropriate mangled name based on certain criteria. If the node is of a specific type, such as `Attribute`, `Name`, `FunctionDef`, `ClassDef`, `ExceptHandler`, or `TypeVar`, the function retrieves the name associated with the node. If the name starts with '__' but does not end with '__', the function prefixes the name with the parent class name to create a mangled name. This mangled name is then returned as the output of the function.",3,"def mangled_name(node):
    if isinstance(node, (Attribute, Name, FunctionDef, ClassDef, ExceptHandler, TypeVar)):
        name = getattr(node, 'name', None)
        if name and name.startswith('__') and not name.endswith('__'):
            parent_class = getattr(node, 'parent_class', None)  # Assuming parent_class is a valid attribute to retrieve
            if parent_class:
                return f""{parent_class}_{name}""
    return None","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,fix_result,"def fix_result(self, node: EnhancedAST, instruction: dis.Instruction) -> EnhancedAST:
    if sys.version_info >= (3, 12, 5) and instruction.opname in ('GET_ITER', 'FOR_ITER') and isinstance(node.parent, ast.For) and (node is node.parent.iter):
        return node.parent
    if sys.version_info >= (3, 12, 6) and instruction.opname in ('GET_ITER', 'FOR_ITER') and isinstance(node.parent.parent, (ast.ListComp, ast.SetComp, ast.DictComp, ast.GeneratorExp)) and isinstance(node.parent, ast.comprehension) and (node is node.parent.iter):
        return node.parent.parent
    if sys.version_info >= (3, 12, 6) and instruction.opname == 'CALL':
        before = self.instruction_before(instruction)
        if before is not None and before.opname == 'LOAD_CONST' and (before.positions == instruction.positions) and isinstance(node.parent, ast.withitem) and (node is node.parent.context_expr):
            return node.parent.parent
    if sys.version_info >= (3, 12, 6) and instruction.opname == 'BEFORE_WITH' and isinstance(node.parent, ast.withitem) and (node is node.parent.context_expr):
        return node.parent.parent
    return node","The goal of the `fix_result` function is to manipulate an EnhancedAST node based on certain conditions involving the instruction associated with it. These conditions include checking the Python version, the type of instruction, the parent nodes of the current node, and specific relationships within the abstract syntax tree. The function aims to return a modified or fixed version of the EnhancedAST node based on these conditions. It is designed to optimize or correct certain aspects of the abstract syntax tree representation.",1,"def fix_result(self, node, instruction):
    if instruction == ""assignment"":
        if self.python_version == 3:
            if node.parent.type == ""function_def"":
                new_node = self.modify_node(node)
                return new_node
            else:
                return node
        else:
            return node
    elif instruction == ""comparison"":
        if self.python_version == 3:
            if node.parent.type == ""if_statement"":
                new_node = self.modify_node(node)
                return new_node
            else:
                return node
        else:
            return node
    else:
        return node","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,fix_result,"def fix_result(self, node: EnhancedAST, instruction: dis.Instruction) -> EnhancedAST:
    if sys.version_info >= (3, 12, 5) and instruction.opname in ('GET_ITER', 'FOR_ITER') and isinstance(node.parent, ast.For) and (node is node.parent.iter):
        return node.parent
    if sys.version_info >= (3, 12, 6) and instruction.opname in ('GET_ITER', 'FOR_ITER') and isinstance(node.parent.parent, (ast.ListComp, ast.SetComp, ast.DictComp, ast.GeneratorExp)) and isinstance(node.parent, ast.comprehension) and (node is node.parent.iter):
        return node.parent.parent
    if sys.version_info >= (3, 12, 6) and instruction.opname == 'CALL':
        before = self.instruction_before(instruction)
        if before is not None and before.opname == 'LOAD_CONST' and (before.positions == instruction.positions) and isinstance(node.parent, ast.withitem) and (node is node.parent.context_expr):
            return node.parent.parent
    if sys.version_info >= (3, 12, 6) and instruction.opname == 'BEFORE_WITH' and isinstance(node.parent, ast.withitem) and (node is node.parent.context_expr):
        return node.parent.parent
    return node","The goal of the `fix_result` function is to manipulate an EnhancedAST node based on certain conditions involving the instruction associated with it. These conditions include checking the Python version, the type of instruction, the parent nodes of the current node, and specific relationships within the abstract syntax tree. The function aims to return a modified or fixed version of the EnhancedAST node based on these conditions. It is designed to optimize or correct certain aspects of the abstract syntax tree representation.",2,"def fix_result(self, node, instruction):
    if node.type == 'if' and instruction == 'check_version':
        if self.python_version > 3:
            node.value = 'True'
        else:
            node.value = 'False'
    elif node.type == 'for' and instruction == 'optimize_loop':
        if 'parent_node' in node.parents:
            node.value = 'optimized'
    elif node.type == 'function' and instruction == 'fix_structure':
        if 'relationship' in node.parents:
            node.value = 'fixed'
    return node","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,fix_result,"def fix_result(self, node: EnhancedAST, instruction: dis.Instruction) -> EnhancedAST:
    if sys.version_info >= (3, 12, 5) and instruction.opname in ('GET_ITER', 'FOR_ITER') and isinstance(node.parent, ast.For) and (node is node.parent.iter):
        return node.parent
    if sys.version_info >= (3, 12, 6) and instruction.opname in ('GET_ITER', 'FOR_ITER') and isinstance(node.parent.parent, (ast.ListComp, ast.SetComp, ast.DictComp, ast.GeneratorExp)) and isinstance(node.parent, ast.comprehension) and (node is node.parent.iter):
        return node.parent.parent
    if sys.version_info >= (3, 12, 6) and instruction.opname == 'CALL':
        before = self.instruction_before(instruction)
        if before is not None and before.opname == 'LOAD_CONST' and (before.positions == instruction.positions) and isinstance(node.parent, ast.withitem) and (node is node.parent.context_expr):
            return node.parent.parent
    if sys.version_info >= (3, 12, 6) and instruction.opname == 'BEFORE_WITH' and isinstance(node.parent, ast.withitem) and (node is node.parent.context_expr):
        return node.parent.parent
    return node","The goal of the `fix_result` function is to manipulate an EnhancedAST node based on certain conditions involving the instruction associated with it. These conditions include checking the Python version, the type of instruction, the parent nodes of the current node, and specific relationships within the abstract syntax tree. The function aims to return a modified or fixed version of the EnhancedAST node based on these conditions. It is designed to optimize or correct certain aspects of the abstract syntax tree representation.",3,"def fix_result(self, node, instruction):
    # Check Python version
    python_version = sys.version_info
    if python_version.major >= 3:
        if isinstance(node, EnhancedAST):
            if instruction == ""condition"":
                if self.parent_nodes(node) == ""parent"":
                    if self.check_relationships(node) == ""specific_relationship"":
                        # Perform manipulation on the node
                        node.value = ""modified_value""
                        return node
    return node","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,known_issues,"def known_issues(self, node: EnhancedAST, instruction: dis.Instruction) -> None:
    if instruction.opname in ('COMPARE_OP', 'IS_OP', 'CONTAINS_OP') and isinstance(node, types_cmp_issue):
        if isinstance(node, types_cmp_issue_fix):
            comparisons = [n for n in ast.walk(node.test) if isinstance(n, ast.Compare) and len(n.ops) > 1]
            assert_(comparisons, 'expected at least one comparison')
            if len(comparisons) == 1:
                node = self.result = cast(EnhancedAST, comparisons[0])
            else:
                raise KnownIssue('multiple chain comparison inside %s can not be fixed' % node)
        else:
            raise KnownIssue('chain comparison inside %s can not be fixed' % node)
    if sys.version_info[:3] == (3, 11, 1) and isinstance(node, ast.Compare) and (instruction.opname == 'CALL') and any((isinstance(n, ast.Assert) for n in node_and_parents(node))):
        raise KnownIssue('known bug in 3.11.1 https://github.com/python/cpython/issues/95921')
    if isinstance(node, ast.Assert):
        raise KnownIssue('assert')
    if any((isinstance(n, ast.pattern) for n in node_and_parents(node))):
        raise KnownIssue('pattern matching ranges seems to be wrong')
    if sys.version_info >= (3, 12) and isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and (node.func.id == 'super'):
        func = node.parent
        while hasattr(func, 'parent') and (not isinstance(func, (ast.AsyncFunctionDef, ast.FunctionDef))):
            func = func.parent
        first_arg = None
        if hasattr(func, 'args'):
            args = [*func.args.posonlyargs, *func.args.args]
            if args:
                first_arg = args[0].arg
        if (instruction.opname, instruction.argval) in [('LOAD_DEREF', '__class__'), ('LOAD_FAST', first_arg), ('LOAD_DEREF', first_arg)]:
            raise KnownIssue('super optimization')
    if self.is_except_cleanup(instruction, node):
        raise KnownIssue('exeption cleanup does not belong to the last node in a except block')
    if instruction.opname == 'STORE_NAME' and instruction.argval == '__classcell__':
        raise KnownIssue('store __classcell__')
    if instruction.opname == 'CALL' and (not isinstance(node, ast.Call)) and any((isinstance(p, ast.Assert) for p in parents(node))) and (sys.version_info >= (3, 11, 2)):
        raise KnownIssue('exception generation maps to condition')
    if sys.version_info >= (3, 13):
        if instruction.opname in ('STORE_FAST_STORE_FAST', 'STORE_FAST_LOAD_FAST', 'LOAD_FAST_LOAD_FAST'):
            raise KnownIssue(f'can not map {instruction.opname} to two ast nodes')
        if instruction.opname == 'LOAD_FAST' and instruction.argval == '__class__':
            raise KnownIssue(f'loading of __class__ is accociated with a random node at the end of a class if you use super()')
        if instruction.opname == 'COMPARE_OP' and isinstance(node, ast.UnaryOp) and isinstance(node.operand, ast.Compare) and isinstance(node.op, ast.Not):
            self.result = node.operand","The function `known_issues` is designed to identify and handle various known issues or bugs within Python code. It checks for specific conditions and raises a `KnownIssue` exception if any of these issues are encountered. The function examines the AST nodes and instruction details to determine the presence of issues such as chain comparisons, assert statements, pattern matching inaccuracies, super optimization problems, exception cleanup positioning, and more. It also considers different Python versions to address version-specific problems. The function plays a crucial role in detecting and managing known issues within Python code during static analysis or optimization processes.",1,"def known_issues(self, node, instruction):
    if ""chain comparisons"" in node or ""assert statements"" in instruction:
        raise KnownIssue(""Known issue encountered"")
    elif ""pattern matching inaccuracies"" in node or ""super optimization problems"" in instruction:
        raise KnownIssue(""Known issue encountered"")
    elif ""exception cleanup positioning"" in node:
        raise KnownIssue(""Known issue encountered"")
    else:
        return ""No known issues detected""","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,known_issues,"def known_issues(self, node: EnhancedAST, instruction: dis.Instruction) -> None:
    if instruction.opname in ('COMPARE_OP', 'IS_OP', 'CONTAINS_OP') and isinstance(node, types_cmp_issue):
        if isinstance(node, types_cmp_issue_fix):
            comparisons = [n for n in ast.walk(node.test) if isinstance(n, ast.Compare) and len(n.ops) > 1]
            assert_(comparisons, 'expected at least one comparison')
            if len(comparisons) == 1:
                node = self.result = cast(EnhancedAST, comparisons[0])
            else:
                raise KnownIssue('multiple chain comparison inside %s can not be fixed' % node)
        else:
            raise KnownIssue('chain comparison inside %s can not be fixed' % node)
    if sys.version_info[:3] == (3, 11, 1) and isinstance(node, ast.Compare) and (instruction.opname == 'CALL') and any((isinstance(n, ast.Assert) for n in node_and_parents(node))):
        raise KnownIssue('known bug in 3.11.1 https://github.com/python/cpython/issues/95921')
    if isinstance(node, ast.Assert):
        raise KnownIssue('assert')
    if any((isinstance(n, ast.pattern) for n in node_and_parents(node))):
        raise KnownIssue('pattern matching ranges seems to be wrong')
    if sys.version_info >= (3, 12) and isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and (node.func.id == 'super'):
        func = node.parent
        while hasattr(func, 'parent') and (not isinstance(func, (ast.AsyncFunctionDef, ast.FunctionDef))):
            func = func.parent
        first_arg = None
        if hasattr(func, 'args'):
            args = [*func.args.posonlyargs, *func.args.args]
            if args:
                first_arg = args[0].arg
        if (instruction.opname, instruction.argval) in [('LOAD_DEREF', '__class__'), ('LOAD_FAST', first_arg), ('LOAD_DEREF', first_arg)]:
            raise KnownIssue('super optimization')
    if self.is_except_cleanup(instruction, node):
        raise KnownIssue('exeption cleanup does not belong to the last node in a except block')
    if instruction.opname == 'STORE_NAME' and instruction.argval == '__classcell__':
        raise KnownIssue('store __classcell__')
    if instruction.opname == 'CALL' and (not isinstance(node, ast.Call)) and any((isinstance(p, ast.Assert) for p in parents(node))) and (sys.version_info >= (3, 11, 2)):
        raise KnownIssue('exception generation maps to condition')
    if sys.version_info >= (3, 13):
        if instruction.opname in ('STORE_FAST_STORE_FAST', 'STORE_FAST_LOAD_FAST', 'LOAD_FAST_LOAD_FAST'):
            raise KnownIssue(f'can not map {instruction.opname} to two ast nodes')
        if instruction.opname == 'LOAD_FAST' and instruction.argval == '__class__':
            raise KnownIssue(f'loading of __class__ is accociated with a random node at the end of a class if you use super()')
        if instruction.opname == 'COMPARE_OP' and isinstance(node, ast.UnaryOp) and isinstance(node.operand, ast.Compare) and isinstance(node.op, ast.Not):
            self.result = node.operand","The function `known_issues` is designed to identify and handle various known issues or bugs within Python code. It checks for specific conditions and raises a `KnownIssue` exception if any of these issues are encountered. The function examines the AST nodes and instruction details to determine the presence of issues such as chain comparisons, assert statements, pattern matching inaccuracies, super optimization problems, exception cleanup positioning, and more. It also considers different Python versions to address version-specific problems. The function plays a crucial role in detecting and managing known issues within Python code during static analysis or optimization processes.",2,"def known_issues(self, node, instruction):
    if check_chain_comparisons(node):
        raise KnownIssue(""Chain comparisons detected"")
    
    if check_assert_statements(node):
        raise KnownIssue(""Assert statements found"")
    
    if check_pattern_matching(node):
        raise KnownIssue(""Pattern matching inaccuracies"")
    
    if check_super_optimization(node):
        raise KnownIssue(""Super optimization problems"")
    
    if check_exception_cleanup(node):
        raise KnownIssue(""Exception cleanup positioning issue"")
    
    if check_version_specific_problems(node):
        raise KnownIssue(""Version-specific problems detected"")
    
    # Additional known issues checks can be added here
    
    return True","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,known_issues,"def known_issues(self, node: EnhancedAST, instruction: dis.Instruction) -> None:
    if instruction.opname in ('COMPARE_OP', 'IS_OP', 'CONTAINS_OP') and isinstance(node, types_cmp_issue):
        if isinstance(node, types_cmp_issue_fix):
            comparisons = [n for n in ast.walk(node.test) if isinstance(n, ast.Compare) and len(n.ops) > 1]
            assert_(comparisons, 'expected at least one comparison')
            if len(comparisons) == 1:
                node = self.result = cast(EnhancedAST, comparisons[0])
            else:
                raise KnownIssue('multiple chain comparison inside %s can not be fixed' % node)
        else:
            raise KnownIssue('chain comparison inside %s can not be fixed' % node)
    if sys.version_info[:3] == (3, 11, 1) and isinstance(node, ast.Compare) and (instruction.opname == 'CALL') and any((isinstance(n, ast.Assert) for n in node_and_parents(node))):
        raise KnownIssue('known bug in 3.11.1 https://github.com/python/cpython/issues/95921')
    if isinstance(node, ast.Assert):
        raise KnownIssue('assert')
    if any((isinstance(n, ast.pattern) for n in node_and_parents(node))):
        raise KnownIssue('pattern matching ranges seems to be wrong')
    if sys.version_info >= (3, 12) and isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and (node.func.id == 'super'):
        func = node.parent
        while hasattr(func, 'parent') and (not isinstance(func, (ast.AsyncFunctionDef, ast.FunctionDef))):
            func = func.parent
        first_arg = None
        if hasattr(func, 'args'):
            args = [*func.args.posonlyargs, *func.args.args]
            if args:
                first_arg = args[0].arg
        if (instruction.opname, instruction.argval) in [('LOAD_DEREF', '__class__'), ('LOAD_FAST', first_arg), ('LOAD_DEREF', first_arg)]:
            raise KnownIssue('super optimization')
    if self.is_except_cleanup(instruction, node):
        raise KnownIssue('exeption cleanup does not belong to the last node in a except block')
    if instruction.opname == 'STORE_NAME' and instruction.argval == '__classcell__':
        raise KnownIssue('store __classcell__')
    if instruction.opname == 'CALL' and (not isinstance(node, ast.Call)) and any((isinstance(p, ast.Assert) for p in parents(node))) and (sys.version_info >= (3, 11, 2)):
        raise KnownIssue('exception generation maps to condition')
    if sys.version_info >= (3, 13):
        if instruction.opname in ('STORE_FAST_STORE_FAST', 'STORE_FAST_LOAD_FAST', 'LOAD_FAST_LOAD_FAST'):
            raise KnownIssue(f'can not map {instruction.opname} to two ast nodes')
        if instruction.opname == 'LOAD_FAST' and instruction.argval == '__class__':
            raise KnownIssue(f'loading of __class__ is accociated with a random node at the end of a class if you use super()')
        if instruction.opname == 'COMPARE_OP' and isinstance(node, ast.UnaryOp) and isinstance(node.operand, ast.Compare) and isinstance(node.op, ast.Not):
            self.result = node.operand","The function `known_issues` is designed to identify and handle various known issues or bugs within Python code. It checks for specific conditions and raises a `KnownIssue` exception if any of these issues are encountered. The function examines the AST nodes and instruction details to determine the presence of issues such as chain comparisons, assert statements, pattern matching inaccuracies, super optimization problems, exception cleanup positioning, and more. It also considers different Python versions to address version-specific problems. The function plays a crucial role in detecting and managing known issues within Python code during static analysis or optimization processes.",3,"def known_issues(self, node, instruction):
    try:
        if check_chain_comparisons(node):
            raise KnownIssue(""Chain comparisons detected"")
        if check_assert_statements(node):
            raise KnownIssue(""Assert statements detected"")
        if check_pattern_matching(node):
            raise KnownIssue(""Pattern matching inaccuracies detected"")
        if check_super_optimization(node):
            raise KnownIssue(""Super optimization problems detected"")
        if check_exception_cleanup(node):
            raise KnownIssue(""Exception cleanup positioning detected"")
        # Add more checks for other known issues
        
    except KnownIssue as e:
        print(f""Known issue detected: {e}"")
        # Handle the known issue accordingly","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,verify,"def verify(self, node: EnhancedAST, instruction: dis.Instruction) -> None:
    """"""
        checks if this node could gererate this instruction
        """"""
    op_name = instruction.opname
    extra_filter: Callable[[EnhancedAST], bool] = lambda e: True
    ctx: Type = type(None)

    def inst_match(opnames: Union[str, Sequence[str]], **kwargs: Any) -> bool:
        """"""
            match instruction

            Parameters:
                opnames: (str|Seq[str]): inst.opname has to be equal to or in `opname`
                **kwargs: every arg has to match inst.arg

            Returns:
                True if all conditions match the instruction

            """"""
        if isinstance(opnames, str):
            opnames = [opnames]
        return instruction.opname in opnames and kwargs == {k: getattr(instruction, k) for k in kwargs}

    def node_match(node_type: Union[Type, Tuple[Type, ...]], **kwargs: Any) -> bool:
        """"""
            match the ast-node

            Parameters:
                node_type: type of the node
                **kwargs: every `arg` has to be equal `node.arg`
                        or `node.arg` has to be an instance of `arg` if it is a type.
            """"""
        return isinstance(node, node_type) and all((isinstance(getattr(node, k), v) if isinstance(v, type) else getattr(node, k) == v for k, v in kwargs.items()))
    if op_name == 'CACHE':
        return
    if inst_match('CALL') and node_match((ast.With, ast.AsyncWith)):
        return
    if inst_match(('CALL', 'LOAD_FAST')) and node_match((ast.ListComp, ast.GeneratorExp, ast.SetComp, ast.DictComp)):
        return
    if sys.version_info >= (3, 12) and inst_match(('LOAD_FAST_AND_CLEAR', 'STORE_FAST')) and node_match((ast.ListComp, ast.SetComp, ast.DictComp)):
        return
    if inst_match(('CALL', 'CALL_FUNCTION_EX')) and node_match((ast.ClassDef, ast.Call)):
        return
    if inst_match(('COMPARE_OP', 'IS_OP', 'CONTAINS_OP')) and node_match(ast.Compare):
        return
    if inst_match('LOAD_NAME', argval='__annotations__') and node_match(ast.AnnAssign):
        return
    if (inst_match('LOAD_METHOD', argval='join') or inst_match('LOAD_ATTR', argval='join') or inst_match(('CALL', 'BUILD_STRING'))) and node_match(ast.BinOp, left=ast.Constant, op=ast.Mod) and isinstance(cast(ast.Constant, cast(ast.BinOp, node).left).value, str):
        return
    if inst_match('STORE_SUBSCR') and node_match(ast.AnnAssign):
        return
    if inst_match(('DELETE_NAME', 'DELETE_FAST')) and node_match(ast.Name, id=instruction.argval, ctx=ast.Del):
        return
    if inst_match('BUILD_STRING') and (node_match(ast.JoinedStr) or node_match(ast.BinOp, op=ast.Mod)):
        return
    if inst_match(('BEFORE_WITH', 'WITH_EXCEPT_START')) and node_match(ast.With):
        return
    if inst_match(('STORE_NAME', 'STORE_GLOBAL'), argval='__doc__') and node_match(ast.Constant):
        return
    if inst_match(('STORE_NAME', 'STORE_FAST', 'STORE_GLOBAL', 'STORE_DEREF')) and node_match(ast.ExceptHandler) and (instruction.argval == mangled_name(node)):
        return
    if inst_match(('STORE_NAME', 'STORE_FAST', 'STORE_DEREF', 'STORE_GLOBAL')) and node_match((ast.Import, ast.ImportFrom)) and any((mangled_name(cast(EnhancedAST, alias)) == instruction.argval for alias in cast(ast.Import, node).names)):
        return
    if inst_match(('STORE_FAST', 'STORE_DEREF', 'STORE_NAME', 'STORE_GLOBAL')) and (node_match((ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)) or node_match(ast.Name, ctx=ast.Store)) and (instruction.argval == mangled_name(node)):
        return
    if False:
        if inst_match(('STORE_FAST', 'STORE_NAME')) and node_match(ast.MatchAs, name=instruction.argval):
            return
        if inst_match('COMPARE_OP', argval='==') and node_match(ast.MatchSequence):
            return
        if inst_match('COMPARE_OP', argval='==') and node_match(ast.MatchValue):
            return
    if inst_match('BINARY_OP') and node_match(ast.AugAssign, op=op_type_map[instruction.argrepr.removesuffix('=')]):
        return
    if node_match(ast.Attribute, ctx=ast.Del) and inst_match('DELETE_ATTR', argval=mangled_name(node)):
        return
    if inst_match(('JUMP_IF_TRUE_OR_POP', 'JUMP_IF_FALSE_OR_POP', 'POP_JUMP_IF_TRUE', 'POP_JUMP_IF_FALSE')) and node_match(ast.BoolOp):
        return
    if inst_match('DELETE_SUBSCR') and node_match(ast.Subscript, ctx=ast.Del):
        return
    if (node_match(ast.Name, ctx=ast.Load) or (node_match(ast.Name, ctx=ast.Store) and isinstance(node.parent, ast.AugAssign))) and inst_match(('LOAD_NAME', 'LOAD_FAST', 'LOAD_FAST_CHECK', 'LOAD_GLOBAL', 'LOAD_DEREF', 'LOAD_FROM_DICT_OR_DEREF'), argval=mangled_name(node)):
        return
    if node_match(ast.Name, ctx=ast.Del) and inst_match(('DELETE_NAME', 'DELETE_GLOBAL', 'DELETE_DEREF'), argval=mangled_name(node)):
        return
    if node_match(ast.Constant) and inst_match('LOAD_CONST', argval=cast(ast.Constant, node).value):
        return
    if node_match((ast.ListComp, ast.SetComp, ast.DictComp, ast.GeneratorExp, ast.For)) and inst_match(('GET_ITER', 'FOR_ITER')):
        return
    if sys.version_info >= (3, 12):
        if node_match(ast.UnaryOp, op=ast.UAdd) and inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_UNARY_POSITIVE'):
            return
        if node_match(ast.Subscript) and inst_match('BINARY_SLICE'):
            return
        if node_match(ast.ImportFrom) and inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_IMPORT_STAR'):
            return
        if (node_match(ast.Yield) or isinstance(node.parent, ast.GeneratorExp)) and inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_ASYNC_GEN_WRAP'):
            return
        if node_match(ast.Name) and inst_match('LOAD_DEREF', argval='__classdict__'):
            return
        if node_match(ast.TypeVar) and (inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_TYPEVAR') or inst_match('CALL_INTRINSIC_2', argrepr='INTRINSIC_TYPEVAR_WITH_BOUND') or inst_match('CALL_INTRINSIC_2', argrepr='INTRINSIC_TYPEVAR_WITH_CONSTRAINTS') or inst_match(('STORE_FAST', 'STORE_DEREF'), argrepr=mangled_name(node))):
            return
        if node_match(ast.TypeVarTuple) and (inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_TYPEVARTUPLE') or inst_match(('STORE_FAST', 'STORE_DEREF'), argrepr=node.name)):
            return
        if node_match(ast.ParamSpec) and (inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_PARAMSPEC') or inst_match(('STORE_FAST', 'STORE_DEREF'), argrepr=node.name)):
            return
        if node_match(ast.TypeAlias):
            if inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_TYPEALIAS') or inst_match(('STORE_NAME', 'STORE_FAST', 'STORE_DEREF'), argrepr=node.name.id) or inst_match('CALL'):
                return
        if node_match(ast.ClassDef) and node.type_params:
            if inst_match(('STORE_DEREF', 'LOAD_DEREF', 'LOAD_FROM_DICT_OR_DEREF'), argrepr='.type_params'):
                return
            if inst_match(('STORE_FAST', 'LOAD_FAST'), argrepr='.generic_base'):
                return
            if inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_SUBSCRIPT_GENERIC'):
                return
            if inst_match('LOAD_DEREF', argval='__classdict__'):
                return
        if node_match((ast.FunctionDef, ast.AsyncFunctionDef)) and node.type_params:
            if inst_match('CALL'):
                return
            if inst_match('CALL_INTRINSIC_2', argrepr='INTRINSIC_SET_FUNCTION_TYPE_PARAMS'):
                return
            if inst_match('LOAD_FAST', argval='.defaults'):
                return
            if inst_match('LOAD_FAST', argval='.kwdefaults'):
                return
        if inst_match('STORE_NAME', argval='__classdictcell__'):
            return
        if node_match(ast.JoinedStr) and (inst_match('LOAD_ATTR', argval='join') or inst_match(('LIST_APPEND', 'CALL'))):
            return
        if node_match(ast.FormattedValue) and inst_match('FORMAT_VALUE'):
            return
    if sys.version_info >= (3, 13):
        if inst_match('NOP'):
            return
        if inst_match('TO_BOOL') and node_match(ast.BoolOp):
            return
        if inst_match('CALL_KW') and node_match((ast.Call, ast.ClassDef)):
            return
        if inst_match('LOAD_FAST', argval='.type_params'):
            return
        if inst_match('LOAD_FAST', argval='__classdict__'):
            return
        if inst_match('LOAD_FAST') and node_match((ast.FunctionDef, ast.ClassDef, ast.TypeAlias, ast.TypeVar, ast.Lambda, ast.AsyncFunctionDef)):
            return
        if inst_match('LOAD_FAST') and node_match(ast.TypeAlias) and (node.name.id == instruction.argval):
            return
        if inst_match('STORE_NAME', argval='__static_attributes__'):
            return
        if inst_match('LOAD_FAST') and isinstance(node.parent, ast.TypeVar):
            return
    typ: Type = type(None)
    op_type: Type = type(None)
    if op_name.startswith(('BINARY_SUBSCR', 'SLICE+')):
        typ = ast.Subscript
        ctx = ast.Load
    elif op_name.startswith('BINARY_'):
        typ = ast.BinOp
        op_type = op_type_map[instruction.argrepr]
        extra_filter = lambda e: isinstance(cast(ast.BinOp, e).op, op_type)
    elif op_name.startswith('UNARY_'):
        typ = ast.UnaryOp
        op_type = dict(UNARY_POSITIVE=ast.UAdd, UNARY_NEGATIVE=ast.USub, UNARY_NOT=ast.Not, UNARY_INVERT=ast.Invert)[op_name]
        extra_filter = lambda e: isinstance(cast(ast.UnaryOp, e).op, op_type)
    elif op_name in ('LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD', 'LOAD_SUPER_ATTR'):
        typ = ast.Attribute
        ctx = ast.Load
        extra_filter = lambda e: mangled_name(e) == instruction.argval
    elif op_name in ('LOAD_NAME', 'LOAD_GLOBAL', 'LOAD_FAST', 'LOAD_DEREF', 'LOAD_CLASSDEREF'):
        typ = ast.Name
        ctx = ast.Load
        extra_filter = lambda e: cast(ast.Name, e).id == instruction.argval
    elif op_name in ('COMPARE_OP', 'IS_OP', 'CONTAINS_OP'):
        typ = ast.Compare
        extra_filter = lambda e: len(cast(ast.Compare, e).ops) == 1
    elif op_name.startswith(('STORE_SLICE', 'STORE_SUBSCR')):
        ctx = ast.Store
        typ = ast.Subscript
    elif op_name.startswith('STORE_ATTR'):
        ctx = ast.Store
        typ = ast.Attribute
        extra_filter = lambda e: mangled_name(e) == instruction.argval
    node_ctx = getattr(node, 'ctx', None)
    ctx_match = ctx is not type(None) or not hasattr(node, 'ctx') or isinstance(node_ctx, ctx)
    if isinstance(node, typ) and ctx_match and extra_filter(node):
        return
    title = 'ast.%s is not created from %s' % (type(node).__name__, instruction.opname)
    raise VerifierFailure(title, node, instruction)","The function `verify` checks if a given EnhancedAST node could generate a specific dis.Instruction. It matches the properties of the node and the instruction to determine if they correspond to each other based on predefined conditions. If a match is found, the function returns, otherwise, it raises a `VerifierFailure` with details about the mismatch. The function utilizes various helper methods to compare instruction types, node types, and their properties to perform the verification process.",1,"def verify(self, node, instruction):
    if self.compare_instruction_type(node, instruction) and \
       self.compare_node_type(node, instruction) and \
       self.compare_properties(node, instruction):
        return
    else:
        raise VerifierFailure(""Mismatch between node and instruction"")","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,verify,"def verify(self, node: EnhancedAST, instruction: dis.Instruction) -> None:
    """"""
        checks if this node could gererate this instruction
        """"""
    op_name = instruction.opname
    extra_filter: Callable[[EnhancedAST], bool] = lambda e: True
    ctx: Type = type(None)

    def inst_match(opnames: Union[str, Sequence[str]], **kwargs: Any) -> bool:
        """"""
            match instruction

            Parameters:
                opnames: (str|Seq[str]): inst.opname has to be equal to or in `opname`
                **kwargs: every arg has to match inst.arg

            Returns:
                True if all conditions match the instruction

            """"""
        if isinstance(opnames, str):
            opnames = [opnames]
        return instruction.opname in opnames and kwargs == {k: getattr(instruction, k) for k in kwargs}

    def node_match(node_type: Union[Type, Tuple[Type, ...]], **kwargs: Any) -> bool:
        """"""
            match the ast-node

            Parameters:
                node_type: type of the node
                **kwargs: every `arg` has to be equal `node.arg`
                        or `node.arg` has to be an instance of `arg` if it is a type.
            """"""
        return isinstance(node, node_type) and all((isinstance(getattr(node, k), v) if isinstance(v, type) else getattr(node, k) == v for k, v in kwargs.items()))
    if op_name == 'CACHE':
        return
    if inst_match('CALL') and node_match((ast.With, ast.AsyncWith)):
        return
    if inst_match(('CALL', 'LOAD_FAST')) and node_match((ast.ListComp, ast.GeneratorExp, ast.SetComp, ast.DictComp)):
        return
    if sys.version_info >= (3, 12) and inst_match(('LOAD_FAST_AND_CLEAR', 'STORE_FAST')) and node_match((ast.ListComp, ast.SetComp, ast.DictComp)):
        return
    if inst_match(('CALL', 'CALL_FUNCTION_EX')) and node_match((ast.ClassDef, ast.Call)):
        return
    if inst_match(('COMPARE_OP', 'IS_OP', 'CONTAINS_OP')) and node_match(ast.Compare):
        return
    if inst_match('LOAD_NAME', argval='__annotations__') and node_match(ast.AnnAssign):
        return
    if (inst_match('LOAD_METHOD', argval='join') or inst_match('LOAD_ATTR', argval='join') or inst_match(('CALL', 'BUILD_STRING'))) and node_match(ast.BinOp, left=ast.Constant, op=ast.Mod) and isinstance(cast(ast.Constant, cast(ast.BinOp, node).left).value, str):
        return
    if inst_match('STORE_SUBSCR') and node_match(ast.AnnAssign):
        return
    if inst_match(('DELETE_NAME', 'DELETE_FAST')) and node_match(ast.Name, id=instruction.argval, ctx=ast.Del):
        return
    if inst_match('BUILD_STRING') and (node_match(ast.JoinedStr) or node_match(ast.BinOp, op=ast.Mod)):
        return
    if inst_match(('BEFORE_WITH', 'WITH_EXCEPT_START')) and node_match(ast.With):
        return
    if inst_match(('STORE_NAME', 'STORE_GLOBAL'), argval='__doc__') and node_match(ast.Constant):
        return
    if inst_match(('STORE_NAME', 'STORE_FAST', 'STORE_GLOBAL', 'STORE_DEREF')) and node_match(ast.ExceptHandler) and (instruction.argval == mangled_name(node)):
        return
    if inst_match(('STORE_NAME', 'STORE_FAST', 'STORE_DEREF', 'STORE_GLOBAL')) and node_match((ast.Import, ast.ImportFrom)) and any((mangled_name(cast(EnhancedAST, alias)) == instruction.argval for alias in cast(ast.Import, node).names)):
        return
    if inst_match(('STORE_FAST', 'STORE_DEREF', 'STORE_NAME', 'STORE_GLOBAL')) and (node_match((ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)) or node_match(ast.Name, ctx=ast.Store)) and (instruction.argval == mangled_name(node)):
        return
    if False:
        if inst_match(('STORE_FAST', 'STORE_NAME')) and node_match(ast.MatchAs, name=instruction.argval):
            return
        if inst_match('COMPARE_OP', argval='==') and node_match(ast.MatchSequence):
            return
        if inst_match('COMPARE_OP', argval='==') and node_match(ast.MatchValue):
            return
    if inst_match('BINARY_OP') and node_match(ast.AugAssign, op=op_type_map[instruction.argrepr.removesuffix('=')]):
        return
    if node_match(ast.Attribute, ctx=ast.Del) and inst_match('DELETE_ATTR', argval=mangled_name(node)):
        return
    if inst_match(('JUMP_IF_TRUE_OR_POP', 'JUMP_IF_FALSE_OR_POP', 'POP_JUMP_IF_TRUE', 'POP_JUMP_IF_FALSE')) and node_match(ast.BoolOp):
        return
    if inst_match('DELETE_SUBSCR') and node_match(ast.Subscript, ctx=ast.Del):
        return
    if (node_match(ast.Name, ctx=ast.Load) or (node_match(ast.Name, ctx=ast.Store) and isinstance(node.parent, ast.AugAssign))) and inst_match(('LOAD_NAME', 'LOAD_FAST', 'LOAD_FAST_CHECK', 'LOAD_GLOBAL', 'LOAD_DEREF', 'LOAD_FROM_DICT_OR_DEREF'), argval=mangled_name(node)):
        return
    if node_match(ast.Name, ctx=ast.Del) and inst_match(('DELETE_NAME', 'DELETE_GLOBAL', 'DELETE_DEREF'), argval=mangled_name(node)):
        return
    if node_match(ast.Constant) and inst_match('LOAD_CONST', argval=cast(ast.Constant, node).value):
        return
    if node_match((ast.ListComp, ast.SetComp, ast.DictComp, ast.GeneratorExp, ast.For)) and inst_match(('GET_ITER', 'FOR_ITER')):
        return
    if sys.version_info >= (3, 12):
        if node_match(ast.UnaryOp, op=ast.UAdd) and inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_UNARY_POSITIVE'):
            return
        if node_match(ast.Subscript) and inst_match('BINARY_SLICE'):
            return
        if node_match(ast.ImportFrom) and inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_IMPORT_STAR'):
            return
        if (node_match(ast.Yield) or isinstance(node.parent, ast.GeneratorExp)) and inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_ASYNC_GEN_WRAP'):
            return
        if node_match(ast.Name) and inst_match('LOAD_DEREF', argval='__classdict__'):
            return
        if node_match(ast.TypeVar) and (inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_TYPEVAR') or inst_match('CALL_INTRINSIC_2', argrepr='INTRINSIC_TYPEVAR_WITH_BOUND') or inst_match('CALL_INTRINSIC_2', argrepr='INTRINSIC_TYPEVAR_WITH_CONSTRAINTS') or inst_match(('STORE_FAST', 'STORE_DEREF'), argrepr=mangled_name(node))):
            return
        if node_match(ast.TypeVarTuple) and (inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_TYPEVARTUPLE') or inst_match(('STORE_FAST', 'STORE_DEREF'), argrepr=node.name)):
            return
        if node_match(ast.ParamSpec) and (inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_PARAMSPEC') or inst_match(('STORE_FAST', 'STORE_DEREF'), argrepr=node.name)):
            return
        if node_match(ast.TypeAlias):
            if inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_TYPEALIAS') or inst_match(('STORE_NAME', 'STORE_FAST', 'STORE_DEREF'), argrepr=node.name.id) or inst_match('CALL'):
                return
        if node_match(ast.ClassDef) and node.type_params:
            if inst_match(('STORE_DEREF', 'LOAD_DEREF', 'LOAD_FROM_DICT_OR_DEREF'), argrepr='.type_params'):
                return
            if inst_match(('STORE_FAST', 'LOAD_FAST'), argrepr='.generic_base'):
                return
            if inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_SUBSCRIPT_GENERIC'):
                return
            if inst_match('LOAD_DEREF', argval='__classdict__'):
                return
        if node_match((ast.FunctionDef, ast.AsyncFunctionDef)) and node.type_params:
            if inst_match('CALL'):
                return
            if inst_match('CALL_INTRINSIC_2', argrepr='INTRINSIC_SET_FUNCTION_TYPE_PARAMS'):
                return
            if inst_match('LOAD_FAST', argval='.defaults'):
                return
            if inst_match('LOAD_FAST', argval='.kwdefaults'):
                return
        if inst_match('STORE_NAME', argval='__classdictcell__'):
            return
        if node_match(ast.JoinedStr) and (inst_match('LOAD_ATTR', argval='join') or inst_match(('LIST_APPEND', 'CALL'))):
            return
        if node_match(ast.FormattedValue) and inst_match('FORMAT_VALUE'):
            return
    if sys.version_info >= (3, 13):
        if inst_match('NOP'):
            return
        if inst_match('TO_BOOL') and node_match(ast.BoolOp):
            return
        if inst_match('CALL_KW') and node_match((ast.Call, ast.ClassDef)):
            return
        if inst_match('LOAD_FAST', argval='.type_params'):
            return
        if inst_match('LOAD_FAST', argval='__classdict__'):
            return
        if inst_match('LOAD_FAST') and node_match((ast.FunctionDef, ast.ClassDef, ast.TypeAlias, ast.TypeVar, ast.Lambda, ast.AsyncFunctionDef)):
            return
        if inst_match('LOAD_FAST') and node_match(ast.TypeAlias) and (node.name.id == instruction.argval):
            return
        if inst_match('STORE_NAME', argval='__static_attributes__'):
            return
        if inst_match('LOAD_FAST') and isinstance(node.parent, ast.TypeVar):
            return
    typ: Type = type(None)
    op_type: Type = type(None)
    if op_name.startswith(('BINARY_SUBSCR', 'SLICE+')):
        typ = ast.Subscript
        ctx = ast.Load
    elif op_name.startswith('BINARY_'):
        typ = ast.BinOp
        op_type = op_type_map[instruction.argrepr]
        extra_filter = lambda e: isinstance(cast(ast.BinOp, e).op, op_type)
    elif op_name.startswith('UNARY_'):
        typ = ast.UnaryOp
        op_type = dict(UNARY_POSITIVE=ast.UAdd, UNARY_NEGATIVE=ast.USub, UNARY_NOT=ast.Not, UNARY_INVERT=ast.Invert)[op_name]
        extra_filter = lambda e: isinstance(cast(ast.UnaryOp, e).op, op_type)
    elif op_name in ('LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD', 'LOAD_SUPER_ATTR'):
        typ = ast.Attribute
        ctx = ast.Load
        extra_filter = lambda e: mangled_name(e) == instruction.argval
    elif op_name in ('LOAD_NAME', 'LOAD_GLOBAL', 'LOAD_FAST', 'LOAD_DEREF', 'LOAD_CLASSDEREF'):
        typ = ast.Name
        ctx = ast.Load
        extra_filter = lambda e: cast(ast.Name, e).id == instruction.argval
    elif op_name in ('COMPARE_OP', 'IS_OP', 'CONTAINS_OP'):
        typ = ast.Compare
        extra_filter = lambda e: len(cast(ast.Compare, e).ops) == 1
    elif op_name.startswith(('STORE_SLICE', 'STORE_SUBSCR')):
        ctx = ast.Store
        typ = ast.Subscript
    elif op_name.startswith('STORE_ATTR'):
        ctx = ast.Store
        typ = ast.Attribute
        extra_filter = lambda e: mangled_name(e) == instruction.argval
    node_ctx = getattr(node, 'ctx', None)
    ctx_match = ctx is not type(None) or not hasattr(node, 'ctx') or isinstance(node_ctx, ctx)
    if isinstance(node, typ) and ctx_match and extra_filter(node):
        return
    title = 'ast.%s is not created from %s' % (type(node).__name__, instruction.opname)
    raise VerifierFailure(title, node, instruction)","The function `verify` checks if a given EnhancedAST node could generate a specific dis.Instruction. It matches the properties of the node and the instruction to determine if they correspond to each other based on predefined conditions. If a match is found, the function returns, otherwise, it raises a `VerifierFailure` with details about the mismatch. The function utilizes various helper methods to compare instruction types, node types, and their properties to perform the verification process.",2,"def verify(self, node, instruction):
    if node.type != instruction.type:
        raise VerifierFailure(""Node type does not match Instruction type"")
    
    if node.properties != instruction.properties:
        raise VerifierFailure(""Node properties do not match Instruction properties"")
    
    if not self.compare_instruction_types(node, instruction):
        raise VerifierFailure(""Instruction types do not match"")
    
    if not self.compare_node_types(node, instruction):
        raise VerifierFailure(""Node types do not match"")
    
    return ""Verification successful""","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,verify,"def verify(self, node: EnhancedAST, instruction: dis.Instruction) -> None:
    """"""
        checks if this node could gererate this instruction
        """"""
    op_name = instruction.opname
    extra_filter: Callable[[EnhancedAST], bool] = lambda e: True
    ctx: Type = type(None)

    def inst_match(opnames: Union[str, Sequence[str]], **kwargs: Any) -> bool:
        """"""
            match instruction

            Parameters:
                opnames: (str|Seq[str]): inst.opname has to be equal to or in `opname`
                **kwargs: every arg has to match inst.arg

            Returns:
                True if all conditions match the instruction

            """"""
        if isinstance(opnames, str):
            opnames = [opnames]
        return instruction.opname in opnames and kwargs == {k: getattr(instruction, k) for k in kwargs}

    def node_match(node_type: Union[Type, Tuple[Type, ...]], **kwargs: Any) -> bool:
        """"""
            match the ast-node

            Parameters:
                node_type: type of the node
                **kwargs: every `arg` has to be equal `node.arg`
                        or `node.arg` has to be an instance of `arg` if it is a type.
            """"""
        return isinstance(node, node_type) and all((isinstance(getattr(node, k), v) if isinstance(v, type) else getattr(node, k) == v for k, v in kwargs.items()))
    if op_name == 'CACHE':
        return
    if inst_match('CALL') and node_match((ast.With, ast.AsyncWith)):
        return
    if inst_match(('CALL', 'LOAD_FAST')) and node_match((ast.ListComp, ast.GeneratorExp, ast.SetComp, ast.DictComp)):
        return
    if sys.version_info >= (3, 12) and inst_match(('LOAD_FAST_AND_CLEAR', 'STORE_FAST')) and node_match((ast.ListComp, ast.SetComp, ast.DictComp)):
        return
    if inst_match(('CALL', 'CALL_FUNCTION_EX')) and node_match((ast.ClassDef, ast.Call)):
        return
    if inst_match(('COMPARE_OP', 'IS_OP', 'CONTAINS_OP')) and node_match(ast.Compare):
        return
    if inst_match('LOAD_NAME', argval='__annotations__') and node_match(ast.AnnAssign):
        return
    if (inst_match('LOAD_METHOD', argval='join') or inst_match('LOAD_ATTR', argval='join') or inst_match(('CALL', 'BUILD_STRING'))) and node_match(ast.BinOp, left=ast.Constant, op=ast.Mod) and isinstance(cast(ast.Constant, cast(ast.BinOp, node).left).value, str):
        return
    if inst_match('STORE_SUBSCR') and node_match(ast.AnnAssign):
        return
    if inst_match(('DELETE_NAME', 'DELETE_FAST')) and node_match(ast.Name, id=instruction.argval, ctx=ast.Del):
        return
    if inst_match('BUILD_STRING') and (node_match(ast.JoinedStr) or node_match(ast.BinOp, op=ast.Mod)):
        return
    if inst_match(('BEFORE_WITH', 'WITH_EXCEPT_START')) and node_match(ast.With):
        return
    if inst_match(('STORE_NAME', 'STORE_GLOBAL'), argval='__doc__') and node_match(ast.Constant):
        return
    if inst_match(('STORE_NAME', 'STORE_FAST', 'STORE_GLOBAL', 'STORE_DEREF')) and node_match(ast.ExceptHandler) and (instruction.argval == mangled_name(node)):
        return
    if inst_match(('STORE_NAME', 'STORE_FAST', 'STORE_DEREF', 'STORE_GLOBAL')) and node_match((ast.Import, ast.ImportFrom)) and any((mangled_name(cast(EnhancedAST, alias)) == instruction.argval for alias in cast(ast.Import, node).names)):
        return
    if inst_match(('STORE_FAST', 'STORE_DEREF', 'STORE_NAME', 'STORE_GLOBAL')) and (node_match((ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)) or node_match(ast.Name, ctx=ast.Store)) and (instruction.argval == mangled_name(node)):
        return
    if False:
        if inst_match(('STORE_FAST', 'STORE_NAME')) and node_match(ast.MatchAs, name=instruction.argval):
            return
        if inst_match('COMPARE_OP', argval='==') and node_match(ast.MatchSequence):
            return
        if inst_match('COMPARE_OP', argval='==') and node_match(ast.MatchValue):
            return
    if inst_match('BINARY_OP') and node_match(ast.AugAssign, op=op_type_map[instruction.argrepr.removesuffix('=')]):
        return
    if node_match(ast.Attribute, ctx=ast.Del) and inst_match('DELETE_ATTR', argval=mangled_name(node)):
        return
    if inst_match(('JUMP_IF_TRUE_OR_POP', 'JUMP_IF_FALSE_OR_POP', 'POP_JUMP_IF_TRUE', 'POP_JUMP_IF_FALSE')) and node_match(ast.BoolOp):
        return
    if inst_match('DELETE_SUBSCR') and node_match(ast.Subscript, ctx=ast.Del):
        return
    if (node_match(ast.Name, ctx=ast.Load) or (node_match(ast.Name, ctx=ast.Store) and isinstance(node.parent, ast.AugAssign))) and inst_match(('LOAD_NAME', 'LOAD_FAST', 'LOAD_FAST_CHECK', 'LOAD_GLOBAL', 'LOAD_DEREF', 'LOAD_FROM_DICT_OR_DEREF'), argval=mangled_name(node)):
        return
    if node_match(ast.Name, ctx=ast.Del) and inst_match(('DELETE_NAME', 'DELETE_GLOBAL', 'DELETE_DEREF'), argval=mangled_name(node)):
        return
    if node_match(ast.Constant) and inst_match('LOAD_CONST', argval=cast(ast.Constant, node).value):
        return
    if node_match((ast.ListComp, ast.SetComp, ast.DictComp, ast.GeneratorExp, ast.For)) and inst_match(('GET_ITER', 'FOR_ITER')):
        return
    if sys.version_info >= (3, 12):
        if node_match(ast.UnaryOp, op=ast.UAdd) and inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_UNARY_POSITIVE'):
            return
        if node_match(ast.Subscript) and inst_match('BINARY_SLICE'):
            return
        if node_match(ast.ImportFrom) and inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_IMPORT_STAR'):
            return
        if (node_match(ast.Yield) or isinstance(node.parent, ast.GeneratorExp)) and inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_ASYNC_GEN_WRAP'):
            return
        if node_match(ast.Name) and inst_match('LOAD_DEREF', argval='__classdict__'):
            return
        if node_match(ast.TypeVar) and (inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_TYPEVAR') or inst_match('CALL_INTRINSIC_2', argrepr='INTRINSIC_TYPEVAR_WITH_BOUND') or inst_match('CALL_INTRINSIC_2', argrepr='INTRINSIC_TYPEVAR_WITH_CONSTRAINTS') or inst_match(('STORE_FAST', 'STORE_DEREF'), argrepr=mangled_name(node))):
            return
        if node_match(ast.TypeVarTuple) and (inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_TYPEVARTUPLE') or inst_match(('STORE_FAST', 'STORE_DEREF'), argrepr=node.name)):
            return
        if node_match(ast.ParamSpec) and (inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_PARAMSPEC') or inst_match(('STORE_FAST', 'STORE_DEREF'), argrepr=node.name)):
            return
        if node_match(ast.TypeAlias):
            if inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_TYPEALIAS') or inst_match(('STORE_NAME', 'STORE_FAST', 'STORE_DEREF'), argrepr=node.name.id) or inst_match('CALL'):
                return
        if node_match(ast.ClassDef) and node.type_params:
            if inst_match(('STORE_DEREF', 'LOAD_DEREF', 'LOAD_FROM_DICT_OR_DEREF'), argrepr='.type_params'):
                return
            if inst_match(('STORE_FAST', 'LOAD_FAST'), argrepr='.generic_base'):
                return
            if inst_match('CALL_INTRINSIC_1', argrepr='INTRINSIC_SUBSCRIPT_GENERIC'):
                return
            if inst_match('LOAD_DEREF', argval='__classdict__'):
                return
        if node_match((ast.FunctionDef, ast.AsyncFunctionDef)) and node.type_params:
            if inst_match('CALL'):
                return
            if inst_match('CALL_INTRINSIC_2', argrepr='INTRINSIC_SET_FUNCTION_TYPE_PARAMS'):
                return
            if inst_match('LOAD_FAST', argval='.defaults'):
                return
            if inst_match('LOAD_FAST', argval='.kwdefaults'):
                return
        if inst_match('STORE_NAME', argval='__classdictcell__'):
            return
        if node_match(ast.JoinedStr) and (inst_match('LOAD_ATTR', argval='join') or inst_match(('LIST_APPEND', 'CALL'))):
            return
        if node_match(ast.FormattedValue) and inst_match('FORMAT_VALUE'):
            return
    if sys.version_info >= (3, 13):
        if inst_match('NOP'):
            return
        if inst_match('TO_BOOL') and node_match(ast.BoolOp):
            return
        if inst_match('CALL_KW') and node_match((ast.Call, ast.ClassDef)):
            return
        if inst_match('LOAD_FAST', argval='.type_params'):
            return
        if inst_match('LOAD_FAST', argval='__classdict__'):
            return
        if inst_match('LOAD_FAST') and node_match((ast.FunctionDef, ast.ClassDef, ast.TypeAlias, ast.TypeVar, ast.Lambda, ast.AsyncFunctionDef)):
            return
        if inst_match('LOAD_FAST') and node_match(ast.TypeAlias) and (node.name.id == instruction.argval):
            return
        if inst_match('STORE_NAME', argval='__static_attributes__'):
            return
        if inst_match('LOAD_FAST') and isinstance(node.parent, ast.TypeVar):
            return
    typ: Type = type(None)
    op_type: Type = type(None)
    if op_name.startswith(('BINARY_SUBSCR', 'SLICE+')):
        typ = ast.Subscript
        ctx = ast.Load
    elif op_name.startswith('BINARY_'):
        typ = ast.BinOp
        op_type = op_type_map[instruction.argrepr]
        extra_filter = lambda e: isinstance(cast(ast.BinOp, e).op, op_type)
    elif op_name.startswith('UNARY_'):
        typ = ast.UnaryOp
        op_type = dict(UNARY_POSITIVE=ast.UAdd, UNARY_NEGATIVE=ast.USub, UNARY_NOT=ast.Not, UNARY_INVERT=ast.Invert)[op_name]
        extra_filter = lambda e: isinstance(cast(ast.UnaryOp, e).op, op_type)
    elif op_name in ('LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD', 'LOAD_SUPER_ATTR'):
        typ = ast.Attribute
        ctx = ast.Load
        extra_filter = lambda e: mangled_name(e) == instruction.argval
    elif op_name in ('LOAD_NAME', 'LOAD_GLOBAL', 'LOAD_FAST', 'LOAD_DEREF', 'LOAD_CLASSDEREF'):
        typ = ast.Name
        ctx = ast.Load
        extra_filter = lambda e: cast(ast.Name, e).id == instruction.argval
    elif op_name in ('COMPARE_OP', 'IS_OP', 'CONTAINS_OP'):
        typ = ast.Compare
        extra_filter = lambda e: len(cast(ast.Compare, e).ops) == 1
    elif op_name.startswith(('STORE_SLICE', 'STORE_SUBSCR')):
        ctx = ast.Store
        typ = ast.Subscript
    elif op_name.startswith('STORE_ATTR'):
        ctx = ast.Store
        typ = ast.Attribute
        extra_filter = lambda e: mangled_name(e) == instruction.argval
    node_ctx = getattr(node, 'ctx', None)
    ctx_match = ctx is not type(None) or not hasattr(node, 'ctx') or isinstance(node_ctx, ctx)
    if isinstance(node, typ) and ctx_match and extra_filter(node):
        return
    title = 'ast.%s is not created from %s' % (type(node).__name__, instruction.opname)
    raise VerifierFailure(title, node, instruction)","The function `verify` checks if a given EnhancedAST node could generate a specific dis.Instruction. It matches the properties of the node and the instruction to determine if they correspond to each other based on predefined conditions. If a match is found, the function returns, otherwise, it raises a `VerifierFailure` with details about the mismatch. The function utilizes various helper methods to compare instruction types, node types, and their properties to perform the verification process.",3,"def verify(self, node, instruction):
    if self.compare_instruction_type(node, instruction) and self.compare_node_type(node, instruction):
        if self.compare_properties(node, instruction):
            return
        else:
            raise VerifierFailure(""Properties mismatch"")
    else:
        raise VerifierFailure(""Types mismatch"")","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,find_node,"def find_node(self, index: int, match_positions: Sequence[str]=('lineno', 'end_lineno', 'col_offset', 'end_col_offset'), typ: tuple[Type, ...]=(ast.expr, ast.stmt, ast.excepthandler, ast.pattern, *extra_node_types)) -> EnhancedAST:
    instruction = self.instruction(index)
    assert instruction is not None
    position = instruction.positions
    assert position is not None and position.lineno is not None
    return only((cast(EnhancedAST, node) for node in self.source._nodes_by_line[position.lineno] if isinstance(node, typ) if not isinstance(node, ast.Expr) if not isinstance(node, ast.MatchValue) if all((getattr(position, attr) == getattr(node, attr) for attr in match_positions))))",The function `find_node` aims to locate a specific node within an EnhancedAST object based on the provided index and matching positions. It searches for a node that matches the specified criteria such as node type and certain position attributes. This function is crucial for retrieving and analyzing nodes within the EnhancedAST object for further processing or manipulation.,1,"def find_node(self, index, match_positions, typ):
    for node in self.nodes:
        if node.index == index and node.position in match_positions and node.type == typ:
            return node
    return None","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,find_node,"def find_node(self, index: int, match_positions: Sequence[str]=('lineno', 'end_lineno', 'col_offset', 'end_col_offset'), typ: tuple[Type, ...]=(ast.expr, ast.stmt, ast.excepthandler, ast.pattern, *extra_node_types)) -> EnhancedAST:
    instruction = self.instruction(index)
    assert instruction is not None
    position = instruction.positions
    assert position is not None and position.lineno is not None
    return only((cast(EnhancedAST, node) for node in self.source._nodes_by_line[position.lineno] if isinstance(node, typ) if not isinstance(node, ast.Expr) if not isinstance(node, ast.MatchValue) if all((getattr(position, attr) == getattr(node, attr) for attr in match_positions))))",The function `find_node` aims to locate a specific node within an EnhancedAST object based on the provided index and matching positions. It searches for a node that matches the specified criteria such as node type and certain position attributes. This function is crucial for retrieving and analyzing nodes within the EnhancedAST object for further processing or manipulation.,2,"def find_node(self, index, match_positions, typ):
    for node in self.nodes:
        if node.index == index and node.positions == match_positions and node.type == typ:
            return node
    return None","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
executing,find_node,"def find_node(self, index: int, match_positions: Sequence[str]=('lineno', 'end_lineno', 'col_offset', 'end_col_offset'), typ: tuple[Type, ...]=(ast.expr, ast.stmt, ast.excepthandler, ast.pattern, *extra_node_types)) -> EnhancedAST:
    instruction = self.instruction(index)
    assert instruction is not None
    position = instruction.positions
    assert position is not None and position.lineno is not None
    return only((cast(EnhancedAST, node) for node in self.source._nodes_by_line[position.lineno] if isinstance(node, typ) if not isinstance(node, ast.Expr) if not isinstance(node, ast.MatchValue) if all((getattr(position, attr) == getattr(node, attr) for attr in match_positions))))",The function `find_node` aims to locate a specific node within an EnhancedAST object based on the provided index and matching positions. It searches for a node that matches the specified criteria such as node type and certain position attributes. This function is crucial for retrieving and analyzing nodes within the EnhancedAST object for further processing or manipulation.,3,"def find_node(self, index, match_positions, typ):
    for node in self.nodes:
        if node.index == index and node.position in match_positions and node.type == typ:
            return node
    return None","['./repos/executing\\tests', './repos/executing\\tests\\generate_small_sample.py::test_file', './repos/executing\\tests\\test_ipython.py::test_one_lookup', './repos/executing\\tests\\test_ipython.py::test_two_statement_lookups', './repos/executing\\tests\\test_main.py::test_small_samples', './repos/executing\\tests\\test_main.py::test_global_tester_calls', './repos/executing\\tests\\test_pytest.py::test_pytest', './repos/executing\\tests\\test_pytest.py::test_ipython_cell_code', './repos/executing\\tests\\test_pytest.py::test_attr_names_match', './repos/executing\\tests\\test_pytest.py::test_source_file_text_change', './repos/executing\\tests\\test_pytest.py::test_manual_linecache', './repos/executing\\tests\\test_pytest.py::test_exception_catching', './repos/executing\\tests\\test_pytest.py::test_bad_linecache', './repos/executing\\tests\\test_pytest.py::test_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite', './repos/executing\\tests\\test_pytest.py::test_no_pytest_rewrite_with_consts', './repos/executing\\tests\\test_pytest.py::test_asttext', './repos/executing\\tests\\small_samples\\3a50eb1aed494e7b3b7e6fc814943b6b24acafdbc5b40644b79ec50bdb29b023.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\c069969a742f2faa3f432cb50c36f58a8158cdae7c19ce0536464b3f3e4b1dd9.py::test_alias_value_01', './repos/executing\\tests\\small_samples\\d88dbf79f1c03ac9d231408b03584e8396ab41a959edecfde86b82df8ee7c918.py::test_getsource_on_class_without_firstlineno']","192 Passed, 0 Failed",192,0,[],[]
