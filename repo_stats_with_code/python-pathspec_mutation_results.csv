Repo Name,Function Name,original_code,Description,Mutant Index,Mutant Code,Test Case,Test Result,Passed Count,Failed Count,Failed Tests,Failure Reasons
python-pathspec,generate_readme_dist,"def generate_readme_dist() -> None:
    """"""
	Generate the ""README-dist.rst"" file from ""README.rst"" and
	""CHANGES.rst"".
	""""""
    print('Read: README.rst')
    with open('README.rst', 'r', encoding='utf8') as fh:
        output = fh.read()
    print('Read: CHANGES.rst')
    with open('CHANGES.rst', 'r', encoding='utf8') as fh:
        output += '\n\n'
        output += fh.read()
    print('Write: README-dist.rst')
    with open('README-dist.rst', 'w', encoding='utf8') as fh:
        fh.write(output)","The function `generate_readme_dist` aims to combine the contents of ""README.rst"" and ""CHANGES.rst"" files and create a new file named ""README-dist.rst"". This new file serves as a consolidated version of the original files for distribution purposes.",1,"def generate_readme_dist():
    with open(""README.rst"", ""r"") as readme_file:
        readme_content = readme_file.read()
    
    with open(""CHANGES.rst"", ""r"") as changes_file:
        changes_content = changes_file.read()
    
    with open(""README-dist.rst"", ""w"") as dist_file:
        dist_file.write(readme_content + ""\n\n"" + changes_content)",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,generate_readme_dist,"def generate_readme_dist() -> None:
    """"""
	Generate the ""README-dist.rst"" file from ""README.rst"" and
	""CHANGES.rst"".
	""""""
    print('Read: README.rst')
    with open('README.rst', 'r', encoding='utf8') as fh:
        output = fh.read()
    print('Read: CHANGES.rst')
    with open('CHANGES.rst', 'r', encoding='utf8') as fh:
        output += '\n\n'
        output += fh.read()
    print('Write: README-dist.rst')
    with open('README-dist.rst', 'w', encoding='utf8') as fh:
        fh.write(output)","The function `generate_readme_dist` aims to combine the contents of ""README.rst"" and ""CHANGES.rst"" files and create a new file named ""README-dist.rst"". This new file serves as a consolidated version of the original files for distribution purposes.",2,"def generate_readme_dist():
    with open(""README.rst"", ""r"") as readme_file:
        readme_contents = readme_file.read()
    
    with open(""CHANGES.rst"", ""r"") as changes_file:
        changes_contents = changes_file.read()
    
    with open(""README-dist.rst"", ""w"") as readme_dist_file:
        readme_dist_file.write(readme_contents + ""\n\n"" + changes_contents)",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,generate_readme_dist,"def generate_readme_dist() -> None:
    """"""
	Generate the ""README-dist.rst"" file from ""README.rst"" and
	""CHANGES.rst"".
	""""""
    print('Read: README.rst')
    with open('README.rst', 'r', encoding='utf8') as fh:
        output = fh.read()
    print('Read: CHANGES.rst')
    with open('CHANGES.rst', 'r', encoding='utf8') as fh:
        output += '\n\n'
        output += fh.read()
    print('Write: README-dist.rst')
    with open('README-dist.rst', 'w', encoding='utf8') as fh:
        fh.write(output)","The function `generate_readme_dist` aims to combine the contents of ""README.rst"" and ""CHANGES.rst"" files and create a new file named ""README-dist.rst"". This new file serves as a consolidated version of the original files for distribution purposes.",3,"def generate_readme_dist():
    with open(""README.rst"", ""r"") as readme_file:
        readme_content = readme_file.read()

    with open(""CHANGES.rst"", ""r"") as changes_file:
        changes_content = changes_file.read()

    with open(""README-dist.rst"", ""w"") as readme_dist_file:
        readme_dist_file.write(readme_content + ""\n\n"" + changes_content)",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,generate_setup_cfg,"def generate_setup_cfg() -> None:
    """"""
	Generate the ""setup.cfg"" file from ""pyproject.toml"" in order to
	support legacy installation with ""setup.py"".
	""""""
    print('Read: pyproject.toml')
    with open('pyproject.toml', 'rb') as fh:
        config = tomli.load(fh)
    print('Write: setup.cfg')
    output = configparser.ConfigParser()
    output['metadata'] = {'author': config['project']['authors'][0]['name'], 'author_email': config['project']['authors'][0]['email'], 'classifiers': '\n' + '\n'.join(config['project']['classifiers']), 'description': config['project']['description'], 'license': config['project']['license']['text'], 'long_description': f'file: {config['project']['readme']}', 'long_description_content_type': 'text/x-rst', 'name': config['project']['name'], 'url': config['project']['urls']['Source Code'], 'version': 'attr: pathspec._meta.__version__'}
    output['options'] = {'packages': 'find:', 'python_requires': config['project']['requires-python'], 'setup_requires': 'setuptools>=40.8.0', 'test_suite': 'tests'}
    output['options.packages.find'] = {'include': 'pathspec, pathspec.*'}
    with open('setup.cfg', 'w', encoding='utf8') as fh:
        output.write(fh)","The goal of the `generate_setup_cfg` function is to read the information from a `pyproject.toml` file and use that information to generate a `setup.cfg` file. This is done in order to support legacy installation with `setup.py`. The function extracts metadata such as author, description, license, and version from the `pyproject.toml` file and writes it into the `setup.cfg` file in a specific format that is compatible with legacy installation methods.",1,"def generate_setup_cfg():
    # Read information from pyproject.toml file
    # Extract metadata such as author, description, license, and version
    # Generate setup.cfg file with the extracted metadata
    pass",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,generate_setup_cfg,"def generate_setup_cfg() -> None:
    """"""
	Generate the ""setup.cfg"" file from ""pyproject.toml"" in order to
	support legacy installation with ""setup.py"".
	""""""
    print('Read: pyproject.toml')
    with open('pyproject.toml', 'rb') as fh:
        config = tomli.load(fh)
    print('Write: setup.cfg')
    output = configparser.ConfigParser()
    output['metadata'] = {'author': config['project']['authors'][0]['name'], 'author_email': config['project']['authors'][0]['email'], 'classifiers': '\n' + '\n'.join(config['project']['classifiers']), 'description': config['project']['description'], 'license': config['project']['license']['text'], 'long_description': f'file: {config['project']['readme']}', 'long_description_content_type': 'text/x-rst', 'name': config['project']['name'], 'url': config['project']['urls']['Source Code'], 'version': 'attr: pathspec._meta.__version__'}
    output['options'] = {'packages': 'find:', 'python_requires': config['project']['requires-python'], 'setup_requires': 'setuptools>=40.8.0', 'test_suite': 'tests'}
    output['options.packages.find'] = {'include': 'pathspec, pathspec.*'}
    with open('setup.cfg', 'w', encoding='utf8') as fh:
        output.write(fh)","The goal of the `generate_setup_cfg` function is to read the information from a `pyproject.toml` file and use that information to generate a `setup.cfg` file. This is done in order to support legacy installation with `setup.py`. The function extracts metadata such as author, description, license, and version from the `pyproject.toml` file and writes it into the `setup.cfg` file in a specific format that is compatible with legacy installation methods.",2,"def generate_setup_cfg():
    # Read information from pyproject.toml file
    # Extract metadata such as author, description, license, and version
    # Write metadata into setup.cfg file in legacy installation compatible format
    pass",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,generate_setup_cfg,"def generate_setup_cfg() -> None:
    """"""
	Generate the ""setup.cfg"" file from ""pyproject.toml"" in order to
	support legacy installation with ""setup.py"".
	""""""
    print('Read: pyproject.toml')
    with open('pyproject.toml', 'rb') as fh:
        config = tomli.load(fh)
    print('Write: setup.cfg')
    output = configparser.ConfigParser()
    output['metadata'] = {'author': config['project']['authors'][0]['name'], 'author_email': config['project']['authors'][0]['email'], 'classifiers': '\n' + '\n'.join(config['project']['classifiers']), 'description': config['project']['description'], 'license': config['project']['license']['text'], 'long_description': f'file: {config['project']['readme']}', 'long_description_content_type': 'text/x-rst', 'name': config['project']['name'], 'url': config['project']['urls']['Source Code'], 'version': 'attr: pathspec._meta.__version__'}
    output['options'] = {'packages': 'find:', 'python_requires': config['project']['requires-python'], 'setup_requires': 'setuptools>=40.8.0', 'test_suite': 'tests'}
    output['options.packages.find'] = {'include': 'pathspec, pathspec.*'}
    with open('setup.cfg', 'w', encoding='utf8') as fh:
        output.write(fh)","The goal of the `generate_setup_cfg` function is to read the information from a `pyproject.toml` file and use that information to generate a `setup.cfg` file. This is done in order to support legacy installation with `setup.py`. The function extracts metadata such as author, description, license, and version from the `pyproject.toml` file and writes it into the `setup.cfg` file in a specific format that is compatible with legacy installation methods.",3,"def generate_setup_cfg():
    # Read information from pyproject.toml file
    # Extract metadata such as author, description, license, and version
    # Generate setup.cfg file with extracted metadata in specific format
    # Return the generated setup.cfg file contents
    pass",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,main,"def main() -> int:
    """"""
	Run the script.
	""""""
    parser = argparse.ArgumentParser(description=__doc__)
    parser.parse_args(sys.argv[1:])
    generate_readme_dist()
    generate_setup_cfg()
    return 0","The function `main` is responsible for parsing command line arguments, generating a README distribution file, setting up a configuration file, and then returning a success status code.",1,"def main():
    parse_command_line_arguments()
    generate_readme_file()
    setup_configuration_file()
    return 0",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,main,"def main() -> int:
    """"""
	Run the script.
	""""""
    parser = argparse.ArgumentParser(description=__doc__)
    parser.parse_args(sys.argv[1:])
    generate_readme_dist()
    generate_setup_cfg()
    return 0","The function `main` is responsible for parsing command line arguments, generating a README distribution file, setting up a configuration file, and then returning a success status code.",2,"def main():
    parse_command_line_arguments()
    generate_readme_distribution_file()
    setup_configuration_file()
    return 0",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,main,"def main() -> int:
    """"""
	Run the script.
	""""""
    parser = argparse.ArgumentParser(description=__doc__)
    parser.parse_args(sys.argv[1:])
    generate_readme_dist()
    generate_setup_cfg()
    return 0","The function `main` is responsible for parsing command line arguments, generating a README distribution file, setting up a configuration file, and then returning a success status code.",3,"def main():
    parse_command_line_arguments()
    generate_readme_distribution_file()
    setup_configuration_file()
    return 0",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,from_lines,"@classmethod
def from_lines(cls: Type[Self], lines: Iterable[AnyStr], pattern_factory: Union[str, Callable[[AnyStr], Pattern], None]=None) -> Self:
    """"""
		Compiles the pattern lines.

		*lines* (:class:`~collections.abc.Iterable`) yields each uncompiled
		pattern (:class:`str`). This simply has to yield each line so it can
		be a :class:`io.TextIOBase` (e.g., from :func:`open` or
		:class:`io.StringIO`) or the result from :meth:`str.splitlines`.

		*pattern_factory* can be :data:`None`, the name of a registered
		pattern factory (:class:`str`), or a :class:`~collections.abc.Callable`
		used to compile patterns. The callable must accept an uncompiled
		pattern (:class:`str`) and return the compiled pattern
		(:class:`pathspec.pattern.Pattern`).
		Default is :data:`None` for :class:`.GitWildMatchPattern`).

		Returns the :class:`GitIgnoreSpec` instance.
		""""""
    if pattern_factory is None:
        pattern_factory = GitWildMatchPattern
    elif (isinstance(lines, (str, bytes)) or callable(lines)) and _is_iterable(pattern_factory):
        pattern_factory, lines = (lines, pattern_factory)
    self = super().from_lines(pattern_factory, lines)
    return cast(Self, self)","This function is responsible for compiling pattern lines into a GitIgnoreSpec instance. It takes in uncompiled pattern lines, a pattern factory which can be a string, a callable function, or None, and returns the compiled GitIgnoreSpec instance. The function handles the compilation of patterns based on the specified pattern factory or a default factory if none is provided.",1,Invalid Syntax / No valid code,N/A,Failed,[],[],0,0
python-pathspec,from_lines,"@classmethod
def from_lines(cls: Type[Self], lines: Iterable[AnyStr], pattern_factory: Union[str, Callable[[AnyStr], Pattern], None]=None) -> Self:
    """"""
		Compiles the pattern lines.

		*lines* (:class:`~collections.abc.Iterable`) yields each uncompiled
		pattern (:class:`str`). This simply has to yield each line so it can
		be a :class:`io.TextIOBase` (e.g., from :func:`open` or
		:class:`io.StringIO`) or the result from :meth:`str.splitlines`.

		*pattern_factory* can be :data:`None`, the name of a registered
		pattern factory (:class:`str`), or a :class:`~collections.abc.Callable`
		used to compile patterns. The callable must accept an uncompiled
		pattern (:class:`str`) and return the compiled pattern
		(:class:`pathspec.pattern.Pattern`).
		Default is :data:`None` for :class:`.GitWildMatchPattern`).

		Returns the :class:`GitIgnoreSpec` instance.
		""""""
    if pattern_factory is None:
        pattern_factory = GitWildMatchPattern
    elif (isinstance(lines, (str, bytes)) or callable(lines)) and _is_iterable(pattern_factory):
        pattern_factory, lines = (lines, pattern_factory)
    self = super().from_lines(pattern_factory, lines)
    return cast(Self, self)","This function is responsible for compiling pattern lines into a GitIgnoreSpec instance. It takes in uncompiled pattern lines, a pattern factory which can be a string, a callable function, or None, and returns the compiled GitIgnoreSpec instance. The function handles the compilation of patterns based on the specified pattern factory or a default factory if none is provided.",2,Invalid Syntax / No valid code,N/A,Failed,[],[],0,0
python-pathspec,from_lines,"@classmethod
def from_lines(cls: Type[Self], lines: Iterable[AnyStr], pattern_factory: Union[str, Callable[[AnyStr], Pattern], None]=None) -> Self:
    """"""
		Compiles the pattern lines.

		*lines* (:class:`~collections.abc.Iterable`) yields each uncompiled
		pattern (:class:`str`). This simply has to yield each line so it can
		be a :class:`io.TextIOBase` (e.g., from :func:`open` or
		:class:`io.StringIO`) or the result from :meth:`str.splitlines`.

		*pattern_factory* can be :data:`None`, the name of a registered
		pattern factory (:class:`str`), or a :class:`~collections.abc.Callable`
		used to compile patterns. The callable must accept an uncompiled
		pattern (:class:`str`) and return the compiled pattern
		(:class:`pathspec.pattern.Pattern`).
		Default is :data:`None` for :class:`.GitWildMatchPattern`).

		Returns the :class:`GitIgnoreSpec` instance.
		""""""
    if pattern_factory is None:
        pattern_factory = GitWildMatchPattern
    elif (isinstance(lines, (str, bytes)) or callable(lines)) and _is_iterable(pattern_factory):
        pattern_factory, lines = (lines, pattern_factory)
    self = super().from_lines(pattern_factory, lines)
    return cast(Self, self)","This function is responsible for compiling pattern lines into a GitIgnoreSpec instance. It takes in uncompiled pattern lines, a pattern factory which can be a string, a callable function, or None, and returns the compiled GitIgnoreSpec instance. The function handles the compilation of patterns based on the specified pattern factory or a default factory if none is provided.",3,Invalid Syntax / No valid code,N/A,Failed,[],[],0,0
python-pathspec,check_file,"def check_file(self, file: TStrPath, separators: Optional[Collection[str]]=None) -> CheckResult[TStrPath]:
    """"""
		Check the files against this path-spec.

		*file* (:class:`str` or :class:`os.PathLike`) is the file path to be
		matched against :attr:`self.patterns <PathSpec.patterns>`.

		*separators* (:class:`~collections.abc.Collection` of :class:`str`; or
		:data:`None`) optionally contains the path separators to normalize. See
		:func:`~pathspec.util.normalize_file` for more information.

		Returns the file check result (:class:`~pathspec.util.CheckResult`).
		""""""
    norm_file = normalize_file(file, separators)
    include, index = self._match_file(enumerate(self.patterns), norm_file)
    return CheckResult(file, include, index)",The goal of the `check_file` function is to check a given file path against a set of patterns specified in a path-spec object. It normalizes the file path using optional separators and then matches it against the patterns. The function returns a CheckResult object indicating whether the file is included based on the patterns and the index of the matching pattern. This function is typically used within the context of a PathSpec class to validate file paths against a set of specified patterns.,1,"def check_file(self, file, separators=None):
    normalized_file = file.replace('/', os.sep).replace('\\', os.sep) if separators else file
    for index, pattern in enumerate(self.patterns):
        if fnmatch.fnmatch(normalized_file, pattern):
            return CheckResult(included=True, index=index)
    return CheckResult(included=False, index=None)",['./repos/python-pathspec\\tests'],"108 Passed, 4 Failed",108,4,"['tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_1_include', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_2_exclude', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_3_unmatch', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_4_many']","['self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_1_include>\n\n    def test_01_check_file_1_include(self):\n    \t""""""\n    \tTest checking a single file that is included.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""include.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:122: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x000001B2CB9742D0>\nfile = \'include.txt\', separators = None\n\n    def check_file(self, file, separators=None):\n        normalized_file = file.replace(\'/\', os.sep).replace(\'\\\\\', os.sep) if separators else file\n        for index, pattern in enumerate(self.patterns):\n>           if fnmatch.fnmatch(normalized_file, pattern):\nE           NameError: name \'fnmatch\' is not defined. Did you forget to import \'fnmatch\'?\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:73: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_2_exclude>\n\n    def test_01_check_file_2_exclude(self):\n    \t""""""\n    \tTest checking a single file that is excluded.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""test/exclude.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:135: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x000001B2CB7F3BB0>\nfile = \'test/exclude.txt\', separators = None\n\n    def check_file(self, file, separators=None):\n        normalized_file = file.replace(\'/\', os.sep).replace(\'\\\\\', os.sep) if separators else file\n        for index, pattern in enumerate(self.patterns):\n>           if fnmatch.fnmatch(normalized_file, pattern):\nE           NameError: name \'fnmatch\' is not defined. Did you forget to import \'fnmatch\'?\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:73: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_3_unmatch>\n\n    def test_01_check_file_3_unmatch(self):\n    \t""""""\n    \tTest checking a single file that is unmatched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""unmatch.bin"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x000001B2CB7F3CE0>\nfile = \'unmatch.bin\', separators = None\n\n    def check_file(self, file, separators=None):\n        normalized_file = file.replace(\'/\', os.sep).replace(\'\\\\\', os.sep) if separators else file\n        for index, pattern in enumerate(self.patterns):\n>           if fnmatch.fnmatch(normalized_file, pattern):\nE           NameError: name \'fnmatch\' is not defined. Did you forget to import \'fnmatch\'?\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:73: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_4_many>\n\n    def test_01_check_file_4_many(self):\n    \t""""""\n    \tTest that checking files one at a time yields the same results as checking\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tsingle_results = set(map(spec.check_file, files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:170: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x000001B2CB94F1D0>\nfile = \'test2/c/c.txt\', separators = None\n\n    def check_file(self, file, separators=None):\n        normalized_file = file.replace(\'/\', os.sep).replace(\'\\\\\', os.sep) if separators else file\n        for index, pattern in enumerate(self.patterns):\n>           if fnmatch.fnmatch(normalized_file, pattern):\nE           NameError: name \'fnmatch\' is not defined. Did you forget to import \'fnmatch\'?\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:73: NameError']"
python-pathspec,check_file,"def check_file(self, file: TStrPath, separators: Optional[Collection[str]]=None) -> CheckResult[TStrPath]:
    """"""
		Check the files against this path-spec.

		*file* (:class:`str` or :class:`os.PathLike`) is the file path to be
		matched against :attr:`self.patterns <PathSpec.patterns>`.

		*separators* (:class:`~collections.abc.Collection` of :class:`str`; or
		:data:`None`) optionally contains the path separators to normalize. See
		:func:`~pathspec.util.normalize_file` for more information.

		Returns the file check result (:class:`~pathspec.util.CheckResult`).
		""""""
    norm_file = normalize_file(file, separators)
    include, index = self._match_file(enumerate(self.patterns), norm_file)
    return CheckResult(file, include, index)",The goal of the `check_file` function is to check a given file path against a set of patterns specified in a path-spec object. It normalizes the file path using optional separators and then matches it against the patterns. The function returns a CheckResult object indicating whether the file is included based on the patterns and the index of the matching pattern. This function is typically used within the context of a PathSpec class to validate file paths against a set of specified patterns.,2,"def check_file(self, file_path, separators=None):
    normalized_file_path = file_path.replace('/', '\\') if separators else file_path
    for i, pattern in enumerate(self.patterns):
        if fnmatch.fnmatch(normalized_file_path, pattern):
            return CheckResult(True, i)
    return CheckResult(False, -1)",['./repos/python-pathspec\\tests'],"108 Passed, 4 Failed",108,4,"['tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_1_include', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_2_exclude', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_3_unmatch', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_4_many']","['self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_1_include>\n\n    def test_01_check_file_1_include(self):\n    \t""""""\n    \tTest checking a single file that is included.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""include.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:122: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x0000021845AF42D0>\nfile_path = \'include.txt\', separators = None\n\n    def check_file(self, file_path, separators=None):\n        normalized_file_path = file_path.replace(\'/\', \'\\\\\') if separators else file_path\n        for i, pattern in enumerate(self.patterns):\n>           if fnmatch.fnmatch(normalized_file_path, pattern):\nE           NameError: name \'fnmatch\' is not defined. Did you forget to import \'fnmatch\'?\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:73: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_2_exclude>\n\n    def test_01_check_file_2_exclude(self):\n    \t""""""\n    \tTest checking a single file that is excluded.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""test/exclude.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:135: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x0000021845973BB0>\nfile_path = \'test/exclude.txt\', separators = None\n\n    def check_file(self, file_path, separators=None):\n        normalized_file_path = file_path.replace(\'/\', \'\\\\\') if separators else file_path\n        for i, pattern in enumerate(self.patterns):\n>           if fnmatch.fnmatch(normalized_file_path, pattern):\nE           NameError: name \'fnmatch\' is not defined. Did you forget to import \'fnmatch\'?\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:73: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_3_unmatch>\n\n    def test_01_check_file_3_unmatch(self):\n    \t""""""\n    \tTest checking a single file that is unmatched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""unmatch.bin"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x0000021845973CE0>\nfile_path = \'unmatch.bin\', separators = None\n\n    def check_file(self, file_path, separators=None):\n        normalized_file_path = file_path.replace(\'/\', \'\\\\\') if separators else file_path\n        for i, pattern in enumerate(self.patterns):\n>           if fnmatch.fnmatch(normalized_file_path, pattern):\nE           NameError: name \'fnmatch\' is not defined. Did you forget to import \'fnmatch\'?\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:73: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_4_many>\n\n    def test_01_check_file_4_many(self):\n    \t""""""\n    \tTest that checking files one at a time yields the same results as checking\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tsingle_results = set(map(spec.check_file, files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:170: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x0000021845ACF1D0>\nfile_path = \'test1/c/c.txt\', separators = None\n\n    def check_file(self, file_path, separators=None):\n        normalized_file_path = file_path.replace(\'/\', \'\\\\\') if separators else file_path\n        for i, pattern in enumerate(self.patterns):\n>           if fnmatch.fnmatch(normalized_file_path, pattern):\nE           NameError: name \'fnmatch\' is not defined. Did you forget to import \'fnmatch\'?\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:73: NameError']"
python-pathspec,check_file,"def check_file(self, file: TStrPath, separators: Optional[Collection[str]]=None) -> CheckResult[TStrPath]:
    """"""
		Check the files against this path-spec.

		*file* (:class:`str` or :class:`os.PathLike`) is the file path to be
		matched against :attr:`self.patterns <PathSpec.patterns>`.

		*separators* (:class:`~collections.abc.Collection` of :class:`str`; or
		:data:`None`) optionally contains the path separators to normalize. See
		:func:`~pathspec.util.normalize_file` for more information.

		Returns the file check result (:class:`~pathspec.util.CheckResult`).
		""""""
    norm_file = normalize_file(file, separators)
    include, index = self._match_file(enumerate(self.patterns), norm_file)
    return CheckResult(file, include, index)",The goal of the `check_file` function is to check a given file path against a set of patterns specified in a path-spec object. It normalizes the file path using optional separators and then matches it against the patterns. The function returns a CheckResult object indicating whether the file is included based on the patterns and the index of the matching pattern. This function is typically used within the context of a PathSpec class to validate file paths against a set of specified patterns.,3,"def check_file(self, file_path, separators=None):
    normalized_file_path = file_path.replace('/', os.path.sep) if separators is not None else file_path
    for i, pattern in enumerate(self.patterns):
        if fnmatch(normalized_file_path, pattern):
            return CheckResult(True, i)
    return CheckResult(False, -1)",['./repos/python-pathspec\\tests'],"108 Passed, 4 Failed",108,4,"['tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_1_include', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_2_exclude', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_3_unmatch', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_4_many']","['self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_1_include>\n\n    def test_01_check_file_1_include(self):\n    \t""""""\n    \tTest checking a single file that is included.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""include.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:122: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x0000016BF38242D0>\nfile_path = \'include.txt\', separators = None\n\n    def check_file(self, file_path, separators=None):\n        normalized_file_path = file_path.replace(\'/\', os.path.sep) if separators is not None else file_path\n        for i, pattern in enumerate(self.patterns):\n>           if fnmatch(normalized_file_path, pattern):\nE           NameError: name \'fnmatch\' is not defined. Did you forget to import \'fnmatch\'?\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:73: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_2_exclude>\n\n    def test_01_check_file_2_exclude(self):\n    \t""""""\n    \tTest checking a single file that is excluded.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""test/exclude.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:135: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x0000016BF36A3BB0>\nfile_path = \'test/exclude.txt\', separators = None\n\n    def check_file(self, file_path, separators=None):\n        normalized_file_path = file_path.replace(\'/\', os.path.sep) if separators is not None else file_path\n        for i, pattern in enumerate(self.patterns):\n>           if fnmatch(normalized_file_path, pattern):\nE           NameError: name \'fnmatch\' is not defined. Did you forget to import \'fnmatch\'?\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:73: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_3_unmatch>\n\n    def test_01_check_file_3_unmatch(self):\n    \t""""""\n    \tTest checking a single file that is unmatched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""unmatch.bin"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x0000016BF36A3CE0>\nfile_path = \'unmatch.bin\', separators = None\n\n    def check_file(self, file_path, separators=None):\n        normalized_file_path = file_path.replace(\'/\', os.path.sep) if separators is not None else file_path\n        for i, pattern in enumerate(self.patterns):\n>           if fnmatch(normalized_file_path, pattern):\nE           NameError: name \'fnmatch\' is not defined. Did you forget to import \'fnmatch\'?\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:73: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_4_many>\n\n    def test_01_check_file_4_many(self):\n    \t""""""\n    \tTest that checking files one at a time yields the same results as checking\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tsingle_results = set(map(spec.check_file, files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:170: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x0000016BF37FF2F0>\nfile_path = \'test2/b.txt\', separators = None\n\n    def check_file(self, file_path, separators=None):\n        normalized_file_path = file_path.replace(\'/\', os.path.sep) if separators is not None else file_path\n        for i, pattern in enumerate(self.patterns):\n>           if fnmatch(normalized_file_path, pattern):\nE           NameError: name \'fnmatch\' is not defined. Did you forget to import \'fnmatch\'?\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:73: NameError']"
python-pathspec,check_files,"def check_files(self, files: Iterable[TStrPath], separators: Optional[Collection[str]]=None) -> Iterator[CheckResult[TStrPath]]:
    """"""
		Check the files against this path-spec.

		*files* (:class:`~collections.abc.Iterable` of :class:`str` or
		:class:`os.PathLike`) contains the file paths to be checked against
		:attr:`self.patterns <PathSpec.patterns>`.

		*separators* (:class:`~collections.abc.Collection` of :class:`str`; or
		:data:`None`) optionally contains the path separators to normalize. See
		:func:`~pathspec.util.normalize_file` for more information.

		Returns an :class:`~collections.abc.Iterator` yielding each file check
		result (:class:`~pathspec.util.CheckResult`).
		""""""
    if not _is_iterable(files):
        raise TypeError(f'files:{files!r} is not an iterable.')
    use_patterns = _filter_check_patterns(self.patterns)
    for orig_file in files:
        norm_file = normalize_file(orig_file, separators)
        include, index = self._match_file(use_patterns, norm_file)
        yield CheckResult(orig_file, include, index)","The goal of the function is to check a list of files against a given path-spec. 
It iterates through the list of files, normalizes the file paths using optional separators, 
matches the files against the patterns in the path-spec, and yields a CheckResult for each file, 
indicating whether it should be included based on the path-spec and the index of the matching pattern.",1,"def check_files(self, files, separators):
    for file in files:
        normalized_file = file.replace(separators, '/')
        for index, pattern in enumerate(self.path_spec):
            if fnmatch.fnmatch(normalized_file, pattern):
                yield CheckResult(file, True, index)
                break
        else:
            yield CheckResult(file, False, -1)",['./repos/python-pathspec\\tests'],"80 Passed, 32 Failed",80,32,"['tests/test_03_pathspec.py::PathSpecTest::test_01_absolute_dir_paths_1', 'tests/test_03_pathspec.py::PathSpecTest::test_01_absolute_dir_paths_2', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_4_many', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_01_current_dir_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_01_empty_path_1', 'tests/test_03_pathspec.py::PathSpecTest::test_01_windows_current_dir_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_01_windows_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_03_add', 'tests/test_03_pathspec.py::PathSpecTest::test_03_iadd', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_a', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_b', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_c', 'tests/test_03_pathspec.py::PathSpecTest::test_07_issue_62', 'tests/test_03_pathspec.py::PathSpecTest::test_08_issue_39', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_01_reversed_args', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_dir_exclusions', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_file_exclusions', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_issue_41_a', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_issue_41_b', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_issue_41_c', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_issue_19_a', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_issue_19_b', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_issue_19_c', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_subdir', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_04_issue_62', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_05_issue_39', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_06_issue_64', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_07_issue_74', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_08_issue_81_a', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_08_issue_81_b', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_08_issue_81_c']","['self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_absolute_dir_paths_1>\n\n    def test_01_absolute_dir_paths_1(self):\n    \t""""""\n    \tTests that absolute paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'foo\',\n    \t])\n    \tfiles = {\n    \t\t\'/a.py\',\n    \t\t\'/foo/a.py\',\n    \t\t\'/x/a.py\',\n    \t\t\'/x/foo/a.py\',\n    \t\t\'a.py\',\n    \t\t\'foo/a.py\',\n    \t\t\'x/a.py\',\n    \t\t\'x/foo/a.py\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:75: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_absolute_dir_paths_2>\n\n    def test_01_absolute_dir_paths_2(self):\n    \t""""""\n    \tTests that absolute paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'/foo\',\n    \t])\n    \tfiles = {\n    \t\t\'/a.py\',\n    \t\t\'/foo/a.py\',\n    \t\t\'/x/a.py\',\n    \t\t\'/x/foo/a.py\',\n    \t\t\'a.py\',\n    \t\t\'foo/a.py\',\n    \t\t\'x/a.py\',\n    \t\t\'x/foo/a.py\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:104: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_4_many>\n\n    def test_01_check_file_4_many(self):\n    \t""""""\n    \tTest that checking files one at a time yields the same results as checking\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n    \tsingle_results = set(map(spec.check_file, files))\n>   \tmulti_results = set(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:171: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_match_files>\n\n    def test_01_check_match_files(self):\n    \t""""""\n    \tTest that checking files and matching files yield the same results.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/**\',\n    \t])\n    \tfiles = {\n    \t\t\'src/test1/a.txt\',\n    \t\t\'src/test1/b.txt\',\n    \t\t\'src/test1/c/c.txt\',\n    \t\t\'src/test2/a.txt\',\n    \t\t\'src/test2/b.txt\',\n    \t\t\'src/test2/c/c.txt\',\n    \t}\n    \n>   \tcheck_results = set(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:192: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_current_dir_paths>\n\n    def test_01_current_dir_paths(self):\n    \t""""""\n    \tTests that paths referencing the current directory will be properly\n    \tnormalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'./src/test1/a.txt\',\n    \t\t\'./src/test1/b.txt\',\n    \t\t\'./src/test1/c/c.txt\',\n    \t\t\'./src/test2/a.txt\',\n    \t\t\'./src/test2/b.txt\',\n    \t\t\'./src/test2/c/c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:216: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_empty_path_1>\n\n    def test_01_empty_path_1(self):\n    \t""""""\n    \tTests that patterns that end with an escaped space will be treated properly.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'\\\\ \',\n    \t\t\'abc\\\\ \'\n    \t])\n    \tfiles = {\n    \t\t\' \',\n    \t\t\'  \',\n    \t\t\'abc \',\n    \t\t\'somefile\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:241: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_windows_current_dir_paths>\n\n    def test_01_windows_current_dir_paths(self):\n    \t""""""\n    \tTests that paths referencing the current directory will be properly\n    \tnormalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'.\\\\test1\\\\a.txt\',\n    \t\t\'.\\\\test1\\\\b.txt\',\n    \t\t\'.\\\\test1\\\\c\\\\c.txt\',\n    \t\t\'.\\\\test2\\\\a.txt\',\n    \t\t\'.\\\\test2\\\\b.txt\',\n    \t\t\'.\\\\test2\\\\c\\\\c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files, separators=[\'\\\\\']))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:341: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x0000022E17EEFD90>\nfiles = {\'.\\\\test1\\\\a.txt\', \'.\\\\test1\\\\b.txt\', \'.\\\\test1\\\\c\\\\c.txt\', \'.\\\\test2\\\\a.txt\', \'.\\\\test2\\\\b.txt\', \'.\\\\test2\\\\c\\\\c.txt\'}\nseparators = [\'\\\\\']\n\n    def check_files(self, files, separators):\n        for file in files:\n>           normalized_file = file.replace(separators, \'/\')\nE           TypeError: replace() argument 1 must be str, not list\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:89: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_windows_paths>\n\n    def test_01_windows_paths(self):\n    \t""""""\n    \tTests that Windows paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1\\\\a.txt\',\n    \t\t\'test1\\\\b.txt\',\n    \t\t\'test1\\\\c\\\\c.txt\',\n    \t\t\'test2\\\\a.txt\',\n    \t\t\'test2\\\\b.txt\',\n    \t\t\'test2\\\\c\\\\c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files, separators=[\'\\\\\']))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x0000022E180AEDD0>\nfiles = {\'test1\\\\a.txt\', \'test1\\\\b.txt\', \'test1\\\\c\\\\c.txt\', \'test2\\\\a.txt\', \'test2\\\\b.txt\', \'test2\\\\c\\\\c.txt\'}\nseparators = [\'\\\\\']\n\n    def check_files(self, files, separators):\n        for file in files:\n>           normalized_file = file.replace(separators, \'/\')\nE           TypeError: replace() argument 1 must be str, not list\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:89: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_03_add>\n\n    def test_03_add(self):\n    \t""""""\n    \tTest spec addition using :data:`+` operator.\n    \t""""""\n    \tfirst_spec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t])\n    \tsecond_spec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t])\n    \tcombined_spec = first_spec + second_spec\n    \tfiles = {\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t}\n    \n>   \tresults = list(combined_spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:424: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_03_iadd>\n\n    def test_03_iadd(self):\n    \t""""""\n    \tTest spec addition using :data:`+=` operator.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t])\n    \tspec += PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t])\n    \tfiles = {\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:454: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_a>\n\n    def test_06_issue_41_a(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario A.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.yaml\',\n    \t\t\'!*.yaml/\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:647: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_b>\n\n    def test_06_issue_41_b(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name\n    \tpattern, scenario B.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'!*.yaml/\',\n    \t\t\'*.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:683: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_c>\n\n    def test_06_issue_41_c(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name\n    \tpattern, scenario C.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.yaml\',\n    \t\t\'!dir.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:718: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_07_issue_62>\n\n    def test_07_issue_62(self):\n    \t""""""\n    \tTest including all files and excluding a directory.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*\',\n    \t\t\'!product_dir/\',\n    \t])\n    \tfiles = {\n    \t\t\'anydir/file.txt\',\n    \t\t\'product_dir/file.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:748: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_08_issue_39>\n\n    def test_08_issue_39(self):\n    \t""""""\n    \tTest excluding files in a directory.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.log\',\n    \t\t\'!important/*.log\',\n    \t\t\'trace.*\',\n    \t])\n    \tfiles = {\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'important/d.log\',\n    \t\t\'important/e.txt\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:773: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_01_reversed_args>\n\n    def test_01_reversed_args(self):\n    \t""""""\n    \tTest reversed args for `.from_lines()`.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines(\'gitwildmatch\', [\'*.txt\'])\n    \tfiles = {\n    \t\t\'a.txt\',\n    \t\t\'b.bin\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:30: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_dir_exclusions>\n\n    def test_02_dir_exclusions(self):\n    \t""""""\n    \tTest directory exclusions.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.bin\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.bin\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:55: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_file_exclusions>\n\n    def test_02_file_exclusions(self):\n    \t""""""\n    \tTest file exclusions.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:87: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_issue_41_a>\n\n    def test_02_issue_41_a(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario A.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.yaml\',\n    \t\t\'!*.yaml/\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',   # -\n    \t\t\'dir.yaml/file.yaml\',  # 1:*.yaml\n    \t\t\'dir.yaml/index.txt\',  # -\n    \t\t\'dir/file.sql\',        # -\n    \t\t\'dir/file.yaml\',       # 1:*.yaml\n    \t\t\'dir/index.txt\',       # -\n    \t\t\'file.yaml\',           # 1:*.yaml\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:122: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_issue_41_b>\n\n    def test_02_issue_41_b(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario B.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'!*.yaml/\',\n    \t\t\'*.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',   # 2:*.yaml\n    \t\t\'dir.yaml/file.yaml\',  # 2:*.yaml\n    \t\t\'dir.yaml/index.txt\',  # 2:*.yaml\n    \t\t\'dir/file.sql\',        # -\n    \t\t\'dir/file.yaml\',       # 2:*.yaml\n    \t\t\'dir/index.txt\',       # -\n    \t\t\'file.yaml\',           # 2:*.yaml\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:158: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_issue_41_c>\n\n    def test_02_issue_41_c(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario C.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.yaml\',\n    \t\t\'!dir.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',   # -\n    \t\t\'dir.yaml/file.yaml\',  # 1:*.yaml\n    \t\t\'dir.yaml/index.txt\',  # -\n    \t\t\'dir/file.sql\',        # -\n    \t\t\'dir/file.yaml\',       # 1:*.yaml\n    \t\t\'dir/index.txt\',       # -\n    \t\t\'file.yaml\',           # 1:*.yaml\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:194: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_issue_19_a>\n\n    def test_03_issue_19_a(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory, scenario A.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/"",\n    \t])\n    \tfiles = {\n    \t\t\'fileA\',\n    \t\t\'fileB\',\n    \t\t\'dirD/fileE\',\n    \t\t\'dirD/fileF\',\n    \t\t\'dirG/dirH/fileI\',\n    \t\t\'dirG/dirH/fileJ\',\n    \t\t\'dirG/fileO\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:260: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_issue_19_b>\n\n    def test_03_issue_19_b(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory, scenario B.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/*"",\n    \t])\n    \tfiles = {\n    \t\t\'fileA\',\n    \t\t\'fileB\',\n    \t\t\'dirD/fileE\',\n    \t\t\'dirD/fileF\',\n    \t\t\'dirG/dirH/fileI\',\n    \t\t\'dirG/dirH/fileJ\',\n    \t\t\'dirG/fileO\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:293: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_issue_19_c>\n\n    def test_03_issue_19_c(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory, scenario C.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/**"",\n    \t])\n    \tfiles = {\n    \t\t\'fileA\',\n    \t\t\'fileB\',\n    \t\t\'dirD/fileE\',\n    \t\t\'dirD/fileF\',\n    \t\t\'dirG/dirH/fileI\',\n    \t\t\'dirG/dirH/fileJ\',\n    \t\t\'dirG/fileO\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:326: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_subdir>\n\n    def test_03_subdir(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/"",\n    \t])\n    \tfiles = {\n    \t\t\'fileA\',\n    \t\t\'fileB\',\n    \t\t\'dirD/fileE\',\n    \t\t\'dirD/fileF\',\n    \t\t\'dirG/dirH/fileI\',\n    \t\t\'dirG/dirH/fileJ\',\n    \t\t\'dirG/fileO\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:227: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_04_issue_62>\n\n    def test_04_issue_62(self):\n    \t""""""\n    \tTest including all files and excluding a directory.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*\',\n    \t\t\'!product_dir/\',\n    \t])\n    \tfiles = {\n    \t\t\'anydir/file.txt\',\n    \t\t\'product_dir/file.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:355: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_05_issue_39>\n\n    def test_05_issue_39(self):\n    \t""""""\n    \tTest excluding files in a directory.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.log\',\n    \t\t\'!important/*.log\',\n    \t\t\'trace.*\',\n    \t])\n    \tfiles = {\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'important/d.log\',\n    \t\t\'important/e.txt\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:381: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_06_issue_64>\n\n    def test_06_issue_64(self):\n    \t""""""\n    \tTest using a double asterisk pattern.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""**"",\n    \t])\n    \tfiles = {\n    \t\t\'x\',\n    \t\t\'y.py\',\n    \t\t\'A/x\',\n    \t\t\'A/y.py\',\n    \t\t\'A/B/x\',\n    \t\t\'A/B/y.py\',\n    \t\t\'A/B/C/x\',\n    \t\t\'A/B/C/y.py\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:413: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_07_issue_74>\n\n    def test_07_issue_74(self):\n    \t""""""\n    \tTest include directory should override exclude file.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*\',  # Ignore all files by default\n    \t\t\'!*/\',  # but scan all directories\n    \t\t\'!*.txt\',  # Text files\n    \t\t\'/test1/**\',  # ignore all in the directory\n    \t])\n    \tfiles = {\n    \t\t\'test1/b.bin\',\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.bin\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:438: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_08_issue_81_a>\n\n    def test_08_issue_81_a(self):\n    \t""""""\n    \tTest issue 81 whitelist, scenario A.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""*"",\n    \t\t""!libfoo"",\n    \t\t""!libfoo/**"",\n    \t])\n    \tfiles = {\n    \t\t""ignore.txt"",          # 1:*\n    \t\t""libfoo/__init__.py"",  # 3:!libfoo/**\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:468: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_08_issue_81_b>\n\n    def test_08_issue_81_b(self):\n    \t""""""\n    \tTest issue 81 whitelist, scenario B.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""*"",\n    \t\t""!libfoo"",\n    \t\t""!libfoo/*"",\n    \t])\n    \tfiles = {\n    \t\t""ignore.txt"",          # 1:*\n    \t\t""libfoo/__init__.py"",  # 3:!libfoo/*\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:494: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_08_issue_81_c>\n\n    def test_08_issue_81_c(self):\n    \t""""""\n    \tTest issue 81 whitelist, scenario C.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""*"",\n    \t\t""!libfoo"",\n    \t\t""!libfoo/"",\n    \t])\n    \tfiles = {\n    \t\t""ignore.txt"",          # 1:*\n    \t\t""libfoo/__init__.py"",  # 1:*\n    \t}\n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:519: TypeError']"
python-pathspec,check_files,"def check_files(self, files: Iterable[TStrPath], separators: Optional[Collection[str]]=None) -> Iterator[CheckResult[TStrPath]]:
    """"""
		Check the files against this path-spec.

		*files* (:class:`~collections.abc.Iterable` of :class:`str` or
		:class:`os.PathLike`) contains the file paths to be checked against
		:attr:`self.patterns <PathSpec.patterns>`.

		*separators* (:class:`~collections.abc.Collection` of :class:`str`; or
		:data:`None`) optionally contains the path separators to normalize. See
		:func:`~pathspec.util.normalize_file` for more information.

		Returns an :class:`~collections.abc.Iterator` yielding each file check
		result (:class:`~pathspec.util.CheckResult`).
		""""""
    if not _is_iterable(files):
        raise TypeError(f'files:{files!r} is not an iterable.')
    use_patterns = _filter_check_patterns(self.patterns)
    for orig_file in files:
        norm_file = normalize_file(orig_file, separators)
        include, index = self._match_file(use_patterns, norm_file)
        yield CheckResult(orig_file, include, index)","The goal of the function is to check a list of files against a given path-spec. 
It iterates through the list of files, normalizes the file paths using optional separators, 
matches the files against the patterns in the path-spec, and yields a CheckResult for each file, 
indicating whether it should be included based on the path-spec and the index of the matching pattern.",2,"def check_files(self, files, separators):
    for file in files:
        normalized_file = file
        for sep in separators:
            normalized_file = normalized_file.replace(sep, '/')
        
        for index, pattern in enumerate(self.path_spec):
            if fnmatch.fnmatch(normalized_file, pattern):
                yield CheckResult(file, True, index)
                break
        else:
            yield CheckResult(file, False, -1)",['./repos/python-pathspec\\tests'],"80 Passed, 32 Failed",80,32,"['tests/test_03_pathspec.py::PathSpecTest::test_01_absolute_dir_paths_1', 'tests/test_03_pathspec.py::PathSpecTest::test_01_absolute_dir_paths_2', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_4_many', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_01_current_dir_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_01_empty_path_1', 'tests/test_03_pathspec.py::PathSpecTest::test_01_windows_current_dir_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_01_windows_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_03_add', 'tests/test_03_pathspec.py::PathSpecTest::test_03_iadd', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_a', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_b', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_c', 'tests/test_03_pathspec.py::PathSpecTest::test_07_issue_62', 'tests/test_03_pathspec.py::PathSpecTest::test_08_issue_39', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_01_reversed_args', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_dir_exclusions', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_file_exclusions', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_issue_41_a', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_issue_41_b', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_issue_41_c', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_issue_19_a', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_issue_19_b', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_issue_19_c', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_subdir', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_04_issue_62', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_05_issue_39', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_06_issue_64', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_07_issue_74', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_08_issue_81_a', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_08_issue_81_b', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_08_issue_81_c']","['self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_absolute_dir_paths_1>\n\n    def test_01_absolute_dir_paths_1(self):\n    \t""""""\n    \tTests that absolute paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'foo\',\n    \t])\n    \tfiles = {\n    \t\t\'/a.py\',\n    \t\t\'/foo/a.py\',\n    \t\t\'/x/a.py\',\n    \t\t\'/x/foo/a.py\',\n    \t\t\'a.py\',\n    \t\t\'foo/a.py\',\n    \t\t\'x/a.py\',\n    \t\t\'x/foo/a.py\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:75: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_absolute_dir_paths_2>\n\n    def test_01_absolute_dir_paths_2(self):\n    \t""""""\n    \tTests that absolute paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'/foo\',\n    \t])\n    \tfiles = {\n    \t\t\'/a.py\',\n    \t\t\'/foo/a.py\',\n    \t\t\'/x/a.py\',\n    \t\t\'/x/foo/a.py\',\n    \t\t\'a.py\',\n    \t\t\'foo/a.py\',\n    \t\t\'x/a.py\',\n    \t\t\'x/foo/a.py\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:104: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_4_many>\n\n    def test_01_check_file_4_many(self):\n    \t""""""\n    \tTest that checking files one at a time yields the same results as checking\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n    \tsingle_results = set(map(spec.check_file, files))\n>   \tmulti_results = set(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:171: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_match_files>\n\n    def test_01_check_match_files(self):\n    \t""""""\n    \tTest that checking files and matching files yield the same results.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/**\',\n    \t])\n    \tfiles = {\n    \t\t\'src/test1/a.txt\',\n    \t\t\'src/test1/b.txt\',\n    \t\t\'src/test1/c/c.txt\',\n    \t\t\'src/test2/a.txt\',\n    \t\t\'src/test2/b.txt\',\n    \t\t\'src/test2/c/c.txt\',\n    \t}\n    \n>   \tcheck_results = set(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:192: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_current_dir_paths>\n\n    def test_01_current_dir_paths(self):\n    \t""""""\n    \tTests that paths referencing the current directory will be properly\n    \tnormalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'./src/test1/a.txt\',\n    \t\t\'./src/test1/b.txt\',\n    \t\t\'./src/test1/c/c.txt\',\n    \t\t\'./src/test2/a.txt\',\n    \t\t\'./src/test2/b.txt\',\n    \t\t\'./src/test2/c/c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:216: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_empty_path_1>\n\n    def test_01_empty_path_1(self):\n    \t""""""\n    \tTests that patterns that end with an escaped space will be treated properly.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'\\\\ \',\n    \t\t\'abc\\\\ \'\n    \t])\n    \tfiles = {\n    \t\t\' \',\n    \t\t\'  \',\n    \t\t\'abc \',\n    \t\t\'somefile\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:241: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_windows_current_dir_paths>\n\n    def test_01_windows_current_dir_paths(self):\n    \t""""""\n    \tTests that paths referencing the current directory will be properly\n    \tnormalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'.\\\\test1\\\\a.txt\',\n    \t\t\'.\\\\test1\\\\b.txt\',\n    \t\t\'.\\\\test1\\\\c\\\\c.txt\',\n    \t\t\'.\\\\test2\\\\a.txt\',\n    \t\t\'.\\\\test2\\\\b.txt\',\n    \t\t\'.\\\\test2\\\\c\\\\c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files, separators=[\'\\\\\']))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:341: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x0000021B33B6FD90>\nfiles = {\'.\\\\test1\\\\a.txt\', \'.\\\\test1\\\\b.txt\', \'.\\\\test1\\\\c\\\\c.txt\', \'.\\\\test2\\\\a.txt\', \'.\\\\test2\\\\b.txt\', \'.\\\\test2\\\\c\\\\c.txt\'}\nseparators = [\'\\\\\']\n\n    def check_files(self, files, separators):\n        for file in files:\n            normalized_file = file\n            for sep in separators:\n                normalized_file = normalized_file.replace(sep, \'/\')\n>           for index, pattern in enumerate(self.path_spec):\nE           AttributeError: \'PathSpec\' object has no attribute \'path_spec\'\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:92: AttributeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_windows_paths>\n\n    def test_01_windows_paths(self):\n    \t""""""\n    \tTests that Windows paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1\\\\a.txt\',\n    \t\t\'test1\\\\b.txt\',\n    \t\t\'test1\\\\c\\\\c.txt\',\n    \t\t\'test2\\\\a.txt\',\n    \t\t\'test2\\\\b.txt\',\n    \t\t\'test2\\\\c\\\\c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files, separators=[\'\\\\\']))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x0000021B33D3ADD0>\nfiles = {\'test1\\\\a.txt\', \'test1\\\\b.txt\', \'test1\\\\c\\\\c.txt\', \'test2\\\\a.txt\', \'test2\\\\b.txt\', \'test2\\\\c\\\\c.txt\'}\nseparators = [\'\\\\\']\n\n    def check_files(self, files, separators):\n        for file in files:\n            normalized_file = file\n            for sep in separators:\n                normalized_file = normalized_file.replace(sep, \'/\')\n>           for index, pattern in enumerate(self.path_spec):\nE           AttributeError: \'PathSpec\' object has no attribute \'path_spec\'\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:92: AttributeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_03_add>\n\n    def test_03_add(self):\n    \t""""""\n    \tTest spec addition using :data:`+` operator.\n    \t""""""\n    \tfirst_spec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t])\n    \tsecond_spec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t])\n    \tcombined_spec = first_spec + second_spec\n    \tfiles = {\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t}\n    \n>   \tresults = list(combined_spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:424: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_03_iadd>\n\n    def test_03_iadd(self):\n    \t""""""\n    \tTest spec addition using :data:`+=` operator.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t])\n    \tspec += PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t])\n    \tfiles = {\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:454: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_a>\n\n    def test_06_issue_41_a(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario A.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.yaml\',\n    \t\t\'!*.yaml/\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:647: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_b>\n\n    def test_06_issue_41_b(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name\n    \tpattern, scenario B.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'!*.yaml/\',\n    \t\t\'*.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:683: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_c>\n\n    def test_06_issue_41_c(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name\n    \tpattern, scenario C.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.yaml\',\n    \t\t\'!dir.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:718: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_07_issue_62>\n\n    def test_07_issue_62(self):\n    \t""""""\n    \tTest including all files and excluding a directory.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*\',\n    \t\t\'!product_dir/\',\n    \t])\n    \tfiles = {\n    \t\t\'anydir/file.txt\',\n    \t\t\'product_dir/file.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:748: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_08_issue_39>\n\n    def test_08_issue_39(self):\n    \t""""""\n    \tTest excluding files in a directory.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.log\',\n    \t\t\'!important/*.log\',\n    \t\t\'trace.*\',\n    \t])\n    \tfiles = {\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'important/d.log\',\n    \t\t\'important/e.txt\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:773: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_01_reversed_args>\n\n    def test_01_reversed_args(self):\n    \t""""""\n    \tTest reversed args for `.from_lines()`.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines(\'gitwildmatch\', [\'*.txt\'])\n    \tfiles = {\n    \t\t\'a.txt\',\n    \t\t\'b.bin\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:30: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_dir_exclusions>\n\n    def test_02_dir_exclusions(self):\n    \t""""""\n    \tTest directory exclusions.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.bin\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.bin\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:55: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_file_exclusions>\n\n    def test_02_file_exclusions(self):\n    \t""""""\n    \tTest file exclusions.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:87: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_issue_41_a>\n\n    def test_02_issue_41_a(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario A.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.yaml\',\n    \t\t\'!*.yaml/\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',   # -\n    \t\t\'dir.yaml/file.yaml\',  # 1:*.yaml\n    \t\t\'dir.yaml/index.txt\',  # -\n    \t\t\'dir/file.sql\',        # -\n    \t\t\'dir/file.yaml\',       # 1:*.yaml\n    \t\t\'dir/index.txt\',       # -\n    \t\t\'file.yaml\',           # 1:*.yaml\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:122: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_issue_41_b>\n\n    def test_02_issue_41_b(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario B.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'!*.yaml/\',\n    \t\t\'*.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',   # 2:*.yaml\n    \t\t\'dir.yaml/file.yaml\',  # 2:*.yaml\n    \t\t\'dir.yaml/index.txt\',  # 2:*.yaml\n    \t\t\'dir/file.sql\',        # -\n    \t\t\'dir/file.yaml\',       # 2:*.yaml\n    \t\t\'dir/index.txt\',       # -\n    \t\t\'file.yaml\',           # 2:*.yaml\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:158: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_issue_41_c>\n\n    def test_02_issue_41_c(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario C.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.yaml\',\n    \t\t\'!dir.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',   # -\n    \t\t\'dir.yaml/file.yaml\',  # 1:*.yaml\n    \t\t\'dir.yaml/index.txt\',  # -\n    \t\t\'dir/file.sql\',        # -\n    \t\t\'dir/file.yaml\',       # 1:*.yaml\n    \t\t\'dir/index.txt\',       # -\n    \t\t\'file.yaml\',           # 1:*.yaml\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:194: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_issue_19_a>\n\n    def test_03_issue_19_a(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory, scenario A.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/"",\n    \t])\n    \tfiles = {\n    \t\t\'fileA\',\n    \t\t\'fileB\',\n    \t\t\'dirD/fileE\',\n    \t\t\'dirD/fileF\',\n    \t\t\'dirG/dirH/fileI\',\n    \t\t\'dirG/dirH/fileJ\',\n    \t\t\'dirG/fileO\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:260: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_issue_19_b>\n\n    def test_03_issue_19_b(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory, scenario B.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/*"",\n    \t])\n    \tfiles = {\n    \t\t\'fileA\',\n    \t\t\'fileB\',\n    \t\t\'dirD/fileE\',\n    \t\t\'dirD/fileF\',\n    \t\t\'dirG/dirH/fileI\',\n    \t\t\'dirG/dirH/fileJ\',\n    \t\t\'dirG/fileO\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:293: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_issue_19_c>\n\n    def test_03_issue_19_c(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory, scenario C.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/**"",\n    \t])\n    \tfiles = {\n    \t\t\'fileA\',\n    \t\t\'fileB\',\n    \t\t\'dirD/fileE\',\n    \t\t\'dirD/fileF\',\n    \t\t\'dirG/dirH/fileI\',\n    \t\t\'dirG/dirH/fileJ\',\n    \t\t\'dirG/fileO\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:326: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_subdir>\n\n    def test_03_subdir(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/"",\n    \t])\n    \tfiles = {\n    \t\t\'fileA\',\n    \t\t\'fileB\',\n    \t\t\'dirD/fileE\',\n    \t\t\'dirD/fileF\',\n    \t\t\'dirG/dirH/fileI\',\n    \t\t\'dirG/dirH/fileJ\',\n    \t\t\'dirG/fileO\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:227: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_04_issue_62>\n\n    def test_04_issue_62(self):\n    \t""""""\n    \tTest including all files and excluding a directory.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*\',\n    \t\t\'!product_dir/\',\n    \t])\n    \tfiles = {\n    \t\t\'anydir/file.txt\',\n    \t\t\'product_dir/file.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:355: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_05_issue_39>\n\n    def test_05_issue_39(self):\n    \t""""""\n    \tTest excluding files in a directory.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.log\',\n    \t\t\'!important/*.log\',\n    \t\t\'trace.*\',\n    \t])\n    \tfiles = {\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'important/d.log\',\n    \t\t\'important/e.txt\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:381: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_06_issue_64>\n\n    def test_06_issue_64(self):\n    \t""""""\n    \tTest using a double asterisk pattern.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""**"",\n    \t])\n    \tfiles = {\n    \t\t\'x\',\n    \t\t\'y.py\',\n    \t\t\'A/x\',\n    \t\t\'A/y.py\',\n    \t\t\'A/B/x\',\n    \t\t\'A/B/y.py\',\n    \t\t\'A/B/C/x\',\n    \t\t\'A/B/C/y.py\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:413: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_07_issue_74>\n\n    def test_07_issue_74(self):\n    \t""""""\n    \tTest include directory should override exclude file.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*\',  # Ignore all files by default\n    \t\t\'!*/\',  # but scan all directories\n    \t\t\'!*.txt\',  # Text files\n    \t\t\'/test1/**\',  # ignore all in the directory\n    \t])\n    \tfiles = {\n    \t\t\'test1/b.bin\',\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.bin\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:438: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_08_issue_81_a>\n\n    def test_08_issue_81_a(self):\n    \t""""""\n    \tTest issue 81 whitelist, scenario A.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""*"",\n    \t\t""!libfoo"",\n    \t\t""!libfoo/**"",\n    \t])\n    \tfiles = {\n    \t\t""ignore.txt"",          # 1:*\n    \t\t""libfoo/__init__.py"",  # 3:!libfoo/**\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:468: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_08_issue_81_b>\n\n    def test_08_issue_81_b(self):\n    \t""""""\n    \tTest issue 81 whitelist, scenario B.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""*"",\n    \t\t""!libfoo"",\n    \t\t""!libfoo/*"",\n    \t])\n    \tfiles = {\n    \t\t""ignore.txt"",          # 1:*\n    \t\t""libfoo/__init__.py"",  # 3:!libfoo/*\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:494: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_08_issue_81_c>\n\n    def test_08_issue_81_c(self):\n    \t""""""\n    \tTest issue 81 whitelist, scenario C.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""*"",\n    \t\t""!libfoo"",\n    \t\t""!libfoo/"",\n    \t])\n    \tfiles = {\n    \t\t""ignore.txt"",          # 1:*\n    \t\t""libfoo/__init__.py"",  # 1:*\n    \t}\n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:519: TypeError']"
python-pathspec,check_files,"def check_files(self, files: Iterable[TStrPath], separators: Optional[Collection[str]]=None) -> Iterator[CheckResult[TStrPath]]:
    """"""
		Check the files against this path-spec.

		*files* (:class:`~collections.abc.Iterable` of :class:`str` or
		:class:`os.PathLike`) contains the file paths to be checked against
		:attr:`self.patterns <PathSpec.patterns>`.

		*separators* (:class:`~collections.abc.Collection` of :class:`str`; or
		:data:`None`) optionally contains the path separators to normalize. See
		:func:`~pathspec.util.normalize_file` for more information.

		Returns an :class:`~collections.abc.Iterator` yielding each file check
		result (:class:`~pathspec.util.CheckResult`).
		""""""
    if not _is_iterable(files):
        raise TypeError(f'files:{files!r} is not an iterable.')
    use_patterns = _filter_check_patterns(self.patterns)
    for orig_file in files:
        norm_file = normalize_file(orig_file, separators)
        include, index = self._match_file(use_patterns, norm_file)
        yield CheckResult(orig_file, include, index)","The goal of the function is to check a list of files against a given path-spec. 
It iterates through the list of files, normalizes the file paths using optional separators, 
matches the files against the patterns in the path-spec, and yields a CheckResult for each file, 
indicating whether it should be included based on the path-spec and the index of the matching pattern.",3,"def check_files(self, files, separators):
    for file in files:
        normalized_file = file
        for separator in separators:
            normalized_file = normalized_file.replace(separator, '/')
        
        for index, pattern in enumerate(self.path_spec):
            if fnmatch.fnmatch(normalized_file, pattern):
                yield CheckResult(file, True, index)
                break
        else:
            yield CheckResult(file, False, None)",['./repos/python-pathspec\\tests'],"80 Passed, 32 Failed",80,32,"['tests/test_03_pathspec.py::PathSpecTest::test_01_absolute_dir_paths_1', 'tests/test_03_pathspec.py::PathSpecTest::test_01_absolute_dir_paths_2', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_4_many', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_01_current_dir_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_01_empty_path_1', 'tests/test_03_pathspec.py::PathSpecTest::test_01_windows_current_dir_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_01_windows_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_03_add', 'tests/test_03_pathspec.py::PathSpecTest::test_03_iadd', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_a', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_b', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_c', 'tests/test_03_pathspec.py::PathSpecTest::test_07_issue_62', 'tests/test_03_pathspec.py::PathSpecTest::test_08_issue_39', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_01_reversed_args', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_dir_exclusions', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_file_exclusions', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_issue_41_a', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_issue_41_b', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_issue_41_c', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_issue_19_a', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_issue_19_b', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_issue_19_c', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_subdir', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_04_issue_62', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_05_issue_39', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_06_issue_64', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_07_issue_74', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_08_issue_81_a', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_08_issue_81_b', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_08_issue_81_c']","['self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_absolute_dir_paths_1>\n\n    def test_01_absolute_dir_paths_1(self):\n    \t""""""\n    \tTests that absolute paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'foo\',\n    \t])\n    \tfiles = {\n    \t\t\'/a.py\',\n    \t\t\'/foo/a.py\',\n    \t\t\'/x/a.py\',\n    \t\t\'/x/foo/a.py\',\n    \t\t\'a.py\',\n    \t\t\'foo/a.py\',\n    \t\t\'x/a.py\',\n    \t\t\'x/foo/a.py\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:75: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_absolute_dir_paths_2>\n\n    def test_01_absolute_dir_paths_2(self):\n    \t""""""\n    \tTests that absolute paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'/foo\',\n    \t])\n    \tfiles = {\n    \t\t\'/a.py\',\n    \t\t\'/foo/a.py\',\n    \t\t\'/x/a.py\',\n    \t\t\'/x/foo/a.py\',\n    \t\t\'a.py\',\n    \t\t\'foo/a.py\',\n    \t\t\'x/a.py\',\n    \t\t\'x/foo/a.py\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:104: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_4_many>\n\n    def test_01_check_file_4_many(self):\n    \t""""""\n    \tTest that checking files one at a time yields the same results as checking\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n    \tsingle_results = set(map(spec.check_file, files))\n>   \tmulti_results = set(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:171: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_match_files>\n\n    def test_01_check_match_files(self):\n    \t""""""\n    \tTest that checking files and matching files yield the same results.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/**\',\n    \t])\n    \tfiles = {\n    \t\t\'src/test1/a.txt\',\n    \t\t\'src/test1/b.txt\',\n    \t\t\'src/test1/c/c.txt\',\n    \t\t\'src/test2/a.txt\',\n    \t\t\'src/test2/b.txt\',\n    \t\t\'src/test2/c/c.txt\',\n    \t}\n    \n>   \tcheck_results = set(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:192: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_current_dir_paths>\n\n    def test_01_current_dir_paths(self):\n    \t""""""\n    \tTests that paths referencing the current directory will be properly\n    \tnormalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'./src/test1/a.txt\',\n    \t\t\'./src/test1/b.txt\',\n    \t\t\'./src/test1/c/c.txt\',\n    \t\t\'./src/test2/a.txt\',\n    \t\t\'./src/test2/b.txt\',\n    \t\t\'./src/test2/c/c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:216: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_empty_path_1>\n\n    def test_01_empty_path_1(self):\n    \t""""""\n    \tTests that patterns that end with an escaped space will be treated properly.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'\\\\ \',\n    \t\t\'abc\\\\ \'\n    \t])\n    \tfiles = {\n    \t\t\' \',\n    \t\t\'  \',\n    \t\t\'abc \',\n    \t\t\'somefile\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:241: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_windows_current_dir_paths>\n\n    def test_01_windows_current_dir_paths(self):\n    \t""""""\n    \tTests that paths referencing the current directory will be properly\n    \tnormalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'.\\\\test1\\\\a.txt\',\n    \t\t\'.\\\\test1\\\\b.txt\',\n    \t\t\'.\\\\test1\\\\c\\\\c.txt\',\n    \t\t\'.\\\\test2\\\\a.txt\',\n    \t\t\'.\\\\test2\\\\b.txt\',\n    \t\t\'.\\\\test2\\\\c\\\\c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files, separators=[\'\\\\\']))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:341: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x000002D72F3DFD90>\nfiles = {\'.\\\\test1\\\\a.txt\', \'.\\\\test1\\\\b.txt\', \'.\\\\test1\\\\c\\\\c.txt\', \'.\\\\test2\\\\a.txt\', \'.\\\\test2\\\\b.txt\', \'.\\\\test2\\\\c\\\\c.txt\'}\nseparators = [\'\\\\\']\n\n    def check_files(self, files, separators):\n        for file in files:\n            normalized_file = file\n            for separator in separators:\n                normalized_file = normalized_file.replace(separator, \'/\')\n>           for index, pattern in enumerate(self.path_spec):\nE           AttributeError: \'PathSpec\' object has no attribute \'path_spec\'\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:92: AttributeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_windows_paths>\n\n    def test_01_windows_paths(self):\n    \t""""""\n    \tTests that Windows paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1\\\\a.txt\',\n    \t\t\'test1\\\\b.txt\',\n    \t\t\'test1\\\\c\\\\c.txt\',\n    \t\t\'test2\\\\a.txt\',\n    \t\t\'test2\\\\b.txt\',\n    \t\t\'test2\\\\c\\\\c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files, separators=[\'\\\\\']))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x000002D72F5AADD0>\nfiles = {\'test1\\\\a.txt\', \'test1\\\\b.txt\', \'test1\\\\c\\\\c.txt\', \'test2\\\\a.txt\', \'test2\\\\b.txt\', \'test2\\\\c\\\\c.txt\'}\nseparators = [\'\\\\\']\n\n    def check_files(self, files, separators):\n        for file in files:\n            normalized_file = file\n            for separator in separators:\n                normalized_file = normalized_file.replace(separator, \'/\')\n>           for index, pattern in enumerate(self.path_spec):\nE           AttributeError: \'PathSpec\' object has no attribute \'path_spec\'\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:92: AttributeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_03_add>\n\n    def test_03_add(self):\n    \t""""""\n    \tTest spec addition using :data:`+` operator.\n    \t""""""\n    \tfirst_spec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t])\n    \tsecond_spec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t])\n    \tcombined_spec = first_spec + second_spec\n    \tfiles = {\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t}\n    \n>   \tresults = list(combined_spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:424: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_03_iadd>\n\n    def test_03_iadd(self):\n    \t""""""\n    \tTest spec addition using :data:`+=` operator.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t])\n    \tspec += PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t])\n    \tfiles = {\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:454: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_a>\n\n    def test_06_issue_41_a(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario A.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.yaml\',\n    \t\t\'!*.yaml/\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:647: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_b>\n\n    def test_06_issue_41_b(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name\n    \tpattern, scenario B.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'!*.yaml/\',\n    \t\t\'*.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:683: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_c>\n\n    def test_06_issue_41_c(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name\n    \tpattern, scenario C.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.yaml\',\n    \t\t\'!dir.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:718: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_07_issue_62>\n\n    def test_07_issue_62(self):\n    \t""""""\n    \tTest including all files and excluding a directory.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*\',\n    \t\t\'!product_dir/\',\n    \t])\n    \tfiles = {\n    \t\t\'anydir/file.txt\',\n    \t\t\'product_dir/file.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:748: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_08_issue_39>\n\n    def test_08_issue_39(self):\n    \t""""""\n    \tTest excluding files in a directory.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.log\',\n    \t\t\'!important/*.log\',\n    \t\t\'trace.*\',\n    \t])\n    \tfiles = {\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'important/d.log\',\n    \t\t\'important/e.txt\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:773: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_01_reversed_args>\n\n    def test_01_reversed_args(self):\n    \t""""""\n    \tTest reversed args for `.from_lines()`.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines(\'gitwildmatch\', [\'*.txt\'])\n    \tfiles = {\n    \t\t\'a.txt\',\n    \t\t\'b.bin\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:30: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_dir_exclusions>\n\n    def test_02_dir_exclusions(self):\n    \t""""""\n    \tTest directory exclusions.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.bin\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.bin\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:55: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_file_exclusions>\n\n    def test_02_file_exclusions(self):\n    \t""""""\n    \tTest file exclusions.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:87: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_issue_41_a>\n\n    def test_02_issue_41_a(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario A.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.yaml\',\n    \t\t\'!*.yaml/\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',   # -\n    \t\t\'dir.yaml/file.yaml\',  # 1:*.yaml\n    \t\t\'dir.yaml/index.txt\',  # -\n    \t\t\'dir/file.sql\',        # -\n    \t\t\'dir/file.yaml\',       # 1:*.yaml\n    \t\t\'dir/index.txt\',       # -\n    \t\t\'file.yaml\',           # 1:*.yaml\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:122: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_issue_41_b>\n\n    def test_02_issue_41_b(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario B.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'!*.yaml/\',\n    \t\t\'*.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',   # 2:*.yaml\n    \t\t\'dir.yaml/file.yaml\',  # 2:*.yaml\n    \t\t\'dir.yaml/index.txt\',  # 2:*.yaml\n    \t\t\'dir/file.sql\',        # -\n    \t\t\'dir/file.yaml\',       # 2:*.yaml\n    \t\t\'dir/index.txt\',       # -\n    \t\t\'file.yaml\',           # 2:*.yaml\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:158: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_issue_41_c>\n\n    def test_02_issue_41_c(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario C.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.yaml\',\n    \t\t\'!dir.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',   # -\n    \t\t\'dir.yaml/file.yaml\',  # 1:*.yaml\n    \t\t\'dir.yaml/index.txt\',  # -\n    \t\t\'dir/file.sql\',        # -\n    \t\t\'dir/file.yaml\',       # 1:*.yaml\n    \t\t\'dir/index.txt\',       # -\n    \t\t\'file.yaml\',           # 1:*.yaml\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:194: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_issue_19_a>\n\n    def test_03_issue_19_a(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory, scenario A.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/"",\n    \t])\n    \tfiles = {\n    \t\t\'fileA\',\n    \t\t\'fileB\',\n    \t\t\'dirD/fileE\',\n    \t\t\'dirD/fileF\',\n    \t\t\'dirG/dirH/fileI\',\n    \t\t\'dirG/dirH/fileJ\',\n    \t\t\'dirG/fileO\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:260: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_issue_19_b>\n\n    def test_03_issue_19_b(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory, scenario B.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/*"",\n    \t])\n    \tfiles = {\n    \t\t\'fileA\',\n    \t\t\'fileB\',\n    \t\t\'dirD/fileE\',\n    \t\t\'dirD/fileF\',\n    \t\t\'dirG/dirH/fileI\',\n    \t\t\'dirG/dirH/fileJ\',\n    \t\t\'dirG/fileO\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:293: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_issue_19_c>\n\n    def test_03_issue_19_c(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory, scenario C.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/**"",\n    \t])\n    \tfiles = {\n    \t\t\'fileA\',\n    \t\t\'fileB\',\n    \t\t\'dirD/fileE\',\n    \t\t\'dirD/fileF\',\n    \t\t\'dirG/dirH/fileI\',\n    \t\t\'dirG/dirH/fileJ\',\n    \t\t\'dirG/fileO\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:326: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_subdir>\n\n    def test_03_subdir(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/"",\n    \t])\n    \tfiles = {\n    \t\t\'fileA\',\n    \t\t\'fileB\',\n    \t\t\'dirD/fileE\',\n    \t\t\'dirD/fileF\',\n    \t\t\'dirG/dirH/fileI\',\n    \t\t\'dirG/dirH/fileJ\',\n    \t\t\'dirG/fileO\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:227: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_04_issue_62>\n\n    def test_04_issue_62(self):\n    \t""""""\n    \tTest including all files and excluding a directory.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*\',\n    \t\t\'!product_dir/\',\n    \t])\n    \tfiles = {\n    \t\t\'anydir/file.txt\',\n    \t\t\'product_dir/file.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:355: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_05_issue_39>\n\n    def test_05_issue_39(self):\n    \t""""""\n    \tTest excluding files in a directory.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.log\',\n    \t\t\'!important/*.log\',\n    \t\t\'trace.*\',\n    \t])\n    \tfiles = {\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'important/d.log\',\n    \t\t\'important/e.txt\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:381: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_06_issue_64>\n\n    def test_06_issue_64(self):\n    \t""""""\n    \tTest using a double asterisk pattern.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""**"",\n    \t])\n    \tfiles = {\n    \t\t\'x\',\n    \t\t\'y.py\',\n    \t\t\'A/x\',\n    \t\t\'A/y.py\',\n    \t\t\'A/B/x\',\n    \t\t\'A/B/y.py\',\n    \t\t\'A/B/C/x\',\n    \t\t\'A/B/C/y.py\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:413: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_07_issue_74>\n\n    def test_07_issue_74(self):\n    \t""""""\n    \tTest include directory should override exclude file.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*\',  # Ignore all files by default\n    \t\t\'!*/\',  # but scan all directories\n    \t\t\'!*.txt\',  # Text files\n    \t\t\'/test1/**\',  # ignore all in the directory\n    \t])\n    \tfiles = {\n    \t\t\'test1/b.bin\',\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.bin\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:438: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_08_issue_81_a>\n\n    def test_08_issue_81_a(self):\n    \t""""""\n    \tTest issue 81 whitelist, scenario A.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""*"",\n    \t\t""!libfoo"",\n    \t\t""!libfoo/**"",\n    \t])\n    \tfiles = {\n    \t\t""ignore.txt"",          # 1:*\n    \t\t""libfoo/__init__.py"",  # 3:!libfoo/**\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:468: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_08_issue_81_b>\n\n    def test_08_issue_81_b(self):\n    \t""""""\n    \tTest issue 81 whitelist, scenario B.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""*"",\n    \t\t""!libfoo"",\n    \t\t""!libfoo/*"",\n    \t])\n    \tfiles = {\n    \t\t""ignore.txt"",          # 1:*\n    \t\t""libfoo/__init__.py"",  # 3:!libfoo/*\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:494: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_08_issue_81_c>\n\n    def test_08_issue_81_c(self):\n    \t""""""\n    \tTest issue 81 whitelist, scenario C.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""*"",\n    \t\t""!libfoo"",\n    \t\t""!libfoo/"",\n    \t])\n    \tfiles = {\n    \t\t""ignore.txt"",          # 1:*\n    \t\t""libfoo/__init__.py"",  # 1:*\n    \t}\n>   \tresults = list(spec.check_files(files))\nE    TypeError: PathSpec.check_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:519: TypeError']"
python-pathspec,from_lines,"@classmethod
def from_lines(cls: Type[Self], pattern_factory: Union[str, Callable[[AnyStr], Pattern]], lines: Iterable[AnyStr]) -> Self:
    """"""
		Compiles the pattern lines.

		*pattern_factory* can be either the name of a registered pattern factory
		(:class:`str`), or a :class:`~collections.abc.Callable` used to compile
		patterns. It must accept an uncompiled pattern (:class:`str`) and return the
		compiled pattern (:class:`.Pattern`).

		*lines* (:class:`~collections.abc.Iterable`) yields each uncompiled pattern
		(:class:`str`). This simply has to yield each line so that it can be a
		:class:`io.TextIOBase` (e.g., from :func:`open` or :class:`io.StringIO`) or
		the result from :meth:`str.splitlines`.

		Returns the :class:`PathSpec` instance.
		""""""
    if isinstance(pattern_factory, str):
        pattern_factory = util.lookup_pattern(pattern_factory)
    if not callable(pattern_factory):
        raise TypeError(f'pattern_factory:{pattern_factory!r} is not callable.')
    if not _is_iterable(lines):
        raise TypeError(f'lines:{lines!r} is not an iterable.')
    patterns = [pattern_factory(line) for line in lines if line]
    return cls(patterns)","This function/class method is designed to compile a list of patterns from uncompiled pattern lines. The function takes a pattern factory, which can be a string representing a registered pattern factory or a callable function that compiles patterns, and a list of uncompiled pattern lines. It then compiles each line using the pattern factory and returns an instance of PathSpec class with the compiled patterns. If the pattern factory is a string, it is looked up using a utility function, and if it is not callable, a TypeError is raised. The function ensures that the input lines are iterable before processing them.",1,Invalid Syntax / No valid code,N/A,Failed,[],[],0,0
python-pathspec,from_lines,"@classmethod
def from_lines(cls: Type[Self], pattern_factory: Union[str, Callable[[AnyStr], Pattern]], lines: Iterable[AnyStr]) -> Self:
    """"""
		Compiles the pattern lines.

		*pattern_factory* can be either the name of a registered pattern factory
		(:class:`str`), or a :class:`~collections.abc.Callable` used to compile
		patterns. It must accept an uncompiled pattern (:class:`str`) and return the
		compiled pattern (:class:`.Pattern`).

		*lines* (:class:`~collections.abc.Iterable`) yields each uncompiled pattern
		(:class:`str`). This simply has to yield each line so that it can be a
		:class:`io.TextIOBase` (e.g., from :func:`open` or :class:`io.StringIO`) or
		the result from :meth:`str.splitlines`.

		Returns the :class:`PathSpec` instance.
		""""""
    if isinstance(pattern_factory, str):
        pattern_factory = util.lookup_pattern(pattern_factory)
    if not callable(pattern_factory):
        raise TypeError(f'pattern_factory:{pattern_factory!r} is not callable.')
    if not _is_iterable(lines):
        raise TypeError(f'lines:{lines!r} is not an iterable.')
    patterns = [pattern_factory(line) for line in lines if line]
    return cls(patterns)","This function/class method is designed to compile a list of patterns from uncompiled pattern lines. The function takes a pattern factory, which can be a string representing a registered pattern factory or a callable function that compiles patterns, and a list of uncompiled pattern lines. It then compiles each line using the pattern factory and returns an instance of PathSpec class with the compiled patterns. If the pattern factory is a string, it is looked up using a utility function, and if it is not callable, a TypeError is raised. The function ensures that the input lines are iterable before processing them.",2,Invalid Syntax / No valid code,N/A,Failed,[],[],0,0
python-pathspec,from_lines,"@classmethod
def from_lines(cls: Type[Self], pattern_factory: Union[str, Callable[[AnyStr], Pattern]], lines: Iterable[AnyStr]) -> Self:
    """"""
		Compiles the pattern lines.

		*pattern_factory* can be either the name of a registered pattern factory
		(:class:`str`), or a :class:`~collections.abc.Callable` used to compile
		patterns. It must accept an uncompiled pattern (:class:`str`) and return the
		compiled pattern (:class:`.Pattern`).

		*lines* (:class:`~collections.abc.Iterable`) yields each uncompiled pattern
		(:class:`str`). This simply has to yield each line so that it can be a
		:class:`io.TextIOBase` (e.g., from :func:`open` or :class:`io.StringIO`) or
		the result from :meth:`str.splitlines`.

		Returns the :class:`PathSpec` instance.
		""""""
    if isinstance(pattern_factory, str):
        pattern_factory = util.lookup_pattern(pattern_factory)
    if not callable(pattern_factory):
        raise TypeError(f'pattern_factory:{pattern_factory!r} is not callable.')
    if not _is_iterable(lines):
        raise TypeError(f'lines:{lines!r} is not an iterable.')
    patterns = [pattern_factory(line) for line in lines if line]
    return cls(patterns)","This function/class method is designed to compile a list of patterns from uncompiled pattern lines. The function takes a pattern factory, which can be a string representing a registered pattern factory or a callable function that compiles patterns, and a list of uncompiled pattern lines. It then compiles each line using the pattern factory and returns an instance of PathSpec class with the compiled patterns. If the pattern factory is a string, it is looked up using a utility function, and if it is not callable, a TypeError is raised. The function ensures that the input lines are iterable before processing them.",3,Invalid Syntax / No valid code,N/A,Failed,[],[],0,0
python-pathspec,match_entries,"def match_entries(self, entries: Iterable[TreeEntry], separators: Optional[Collection[str]]=None, *, negate: Optional[bool]=None) -> Iterator[TreeEntry]:
    """"""
		Matches the entries to this path-spec.

		*entries* (:class:`~collections.abc.Iterable` of :class:`~pathspec.util.TreeEntry`)
		contains the entries to be matched against :attr:`self.patterns <PathSpec.patterns>`.

		*separators* (:class:`~collections.abc.Collection` of :class:`str`; or
		:data:`None`) optionally contains the path separators to normalize. See
		:func:`~pathspec.util.normalize_file` for more information.

		*negate* (:class:`bool` or :data:`None`) is whether to negate the match
		results of the patterns. If :data:`True`, a pattern matching a file will
		exclude the file rather than include it. Default is :data:`None` for
		:data:`False`.

		Returns the matched entries (:class:`~collections.abc.Iterator` of
		:class:`~pathspec.util.TreeEntry`).
		""""""
    if not _is_iterable(entries):
        raise TypeError(f'entries:{entries!r} is not an iterable.')
    use_patterns = _filter_check_patterns(self.patterns)
    for entry in entries:
        norm_file = normalize_file(entry.path, separators)
        include, _index = self._match_file(use_patterns, norm_file)
        if negate:
            include = not include
        if include:
            yield entry","This function `match_entries` takes a collection of tree entries and matches them against a set of patterns specified in a PathSpec object. It allows for optional normalization of path separators and negation of match results. The function iterates over the entries, normalizes the file paths, checks for matches against the patterns, applies negation if specified, and yields the matched entries. The goal is to filter and return the entries that match the patterns defined in the PathSpec object.",1,"def match_entries(self, entries, separators, normalize=False, negate=False):
    for entry in entries:
        path = entry.get_path()
        if normalize:
            path = path.replace('/', '\\') if separators == '\\' else path.replace('\\', '/')
        matched = self.path_spec.match(path)
        if (matched and not negate) or (not matched and negate):
            yield entry",['./repos/python-pathspec\\tests'],"110 Passed, 2 Failed",110,2,"['tests/test_03_pathspec.py::PathSpecTest::test_05_match_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_entries']","['self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_entries>\n\n    def test_05_match_entries(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tentries = iter_tree_entries(self.temp_dir)\n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_entries(entries)\n    \t}\nE    TypeError: PathSpec.match_entries() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:500: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_entries>\n\n    def test_05_match_tree_entries(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_tree_entries(self.temp_dir)\n    \t}\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:586: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x000001D57E9BE670>\nroot = WindowsPath(\'C:/Users/SERINE~1.SEF/AppData/Local/Temp/tmpa1vu81wv\')\non_error = None, follow_links = None\n\n        def match_tree_entries(self, root: StrPath, on_error: Optional[Callable[[OSError], None]]=None, follow_links: Optional[bool]=None, *, negate: Optional[bool]=None) -> Iterator[TreeEntry]:\n            """"""\n    \t\tWalks the specified root path for all files and matches them to this\n    \t\tpath-spec.\n    \n    \t\t*root* (:class:`str` or :class:`os.PathLike`) is the root directory to\n    \t\tsearch.\n    \n    \t\t*on_error* (:class:`~collections.abc.Callable` or :data:`None`) optionally\n    \t\tis the error handler for file-system exceptions. It will be called with the\n    \t\texception (:exc:`OSError`). Reraise the exception to abort the walk. Default\n    \t\tis :data:`None` to ignore file-system exceptions.\n    \n    \t\t*follow_links* (:class:`bool` or :data:`None`) optionally is whether to walk\n    \t\tsymbolic links that resolve to directories. Default is :data:`None` for\n    \t\t:data:`True`.\n    \n    \t\t*negate* (:class:`bool` or :data:`None`) is whether to negate the match\n    \t\tresults of the patterns. If :data:`True`, a pattern matching a file will\n    \t\texclude the file rather than include it. Default is :data:`None` for\n    \t\t:data:`False`.\n    \n    \t\tReturns the matched files (:class:`~collections.abc.Iterator` of\n    \t\t:class:`.TreeEntry`).\n    \t\t""""""\n            entries = util.iter_tree_entries(root, on_error=on_error, follow_links=follow_links)\n>           yield from self.match_entries(entries, negate=negate)\nE           TypeError: PathSpec.match_entries() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:249: TypeError']"
python-pathspec,match_entries,"def match_entries(self, entries: Iterable[TreeEntry], separators: Optional[Collection[str]]=None, *, negate: Optional[bool]=None) -> Iterator[TreeEntry]:
    """"""
		Matches the entries to this path-spec.

		*entries* (:class:`~collections.abc.Iterable` of :class:`~pathspec.util.TreeEntry`)
		contains the entries to be matched against :attr:`self.patterns <PathSpec.patterns>`.

		*separators* (:class:`~collections.abc.Collection` of :class:`str`; or
		:data:`None`) optionally contains the path separators to normalize. See
		:func:`~pathspec.util.normalize_file` for more information.

		*negate* (:class:`bool` or :data:`None`) is whether to negate the match
		results of the patterns. If :data:`True`, a pattern matching a file will
		exclude the file rather than include it. Default is :data:`None` for
		:data:`False`.

		Returns the matched entries (:class:`~collections.abc.Iterator` of
		:class:`~pathspec.util.TreeEntry`).
		""""""
    if not _is_iterable(entries):
        raise TypeError(f'entries:{entries!r} is not an iterable.')
    use_patterns = _filter_check_patterns(self.patterns)
    for entry in entries:
        norm_file = normalize_file(entry.path, separators)
        include, _index = self._match_file(use_patterns, norm_file)
        if negate:
            include = not include
        if include:
            yield entry","This function `match_entries` takes a collection of tree entries and matches them against a set of patterns specified in a PathSpec object. It allows for optional normalization of path separators and negation of match results. The function iterates over the entries, normalizes the file paths, checks for matches against the patterns, applies negation if specified, and yields the matched entries. The goal is to filter and return the entries that match the patterns defined in the PathSpec object.",2,"def match_entries(self, entries, separators):
    for entry in entries:
        normalized_path = entry.replace(separators, '/')
        match = self.path_spec.match(normalized_path)
        
        if match:
            if not self.negate_match:
                yield entry
        else:
            if self.negate_match:
                yield entry",['./repos/python-pathspec\\tests'],"110 Passed, 2 Failed",110,2,"['tests/test_03_pathspec.py::PathSpecTest::test_05_match_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_entries']","['self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_entries>\n\n    def test_05_match_entries(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tentries = iter_tree_entries(self.temp_dir)\n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_entries(entries)\n    \t}\nE    TypeError: PathSpec.match_entries() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:500: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_entries>\n\n    def test_05_match_tree_entries(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_tree_entries(self.temp_dir)\n    \t}\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:586: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x0000017CC6736670>\nroot = WindowsPath(\'C:/Users/SERINE~1.SEF/AppData/Local/Temp/tmpq_mp4go8\')\non_error = None, follow_links = None\n\n        def match_tree_entries(self, root: StrPath, on_error: Optional[Callable[[OSError], None]]=None, follow_links: Optional[bool]=None, *, negate: Optional[bool]=None) -> Iterator[TreeEntry]:\n            """"""\n    \t\tWalks the specified root path for all files and matches them to this\n    \t\tpath-spec.\n    \n    \t\t*root* (:class:`str` or :class:`os.PathLike`) is the root directory to\n    \t\tsearch.\n    \n    \t\t*on_error* (:class:`~collections.abc.Callable` or :data:`None`) optionally\n    \t\tis the error handler for file-system exceptions. It will be called with the\n    \t\texception (:exc:`OSError`). Reraise the exception to abort the walk. Default\n    \t\tis :data:`None` to ignore file-system exceptions.\n    \n    \t\t*follow_links* (:class:`bool` or :data:`None`) optionally is whether to walk\n    \t\tsymbolic links that resolve to directories. Default is :data:`None` for\n    \t\t:data:`True`.\n    \n    \t\t*negate* (:class:`bool` or :data:`None`) is whether to negate the match\n    \t\tresults of the patterns. If :data:`True`, a pattern matching a file will\n    \t\texclude the file rather than include it. Default is :data:`None` for\n    \t\t:data:`False`.\n    \n    \t\tReturns the matched files (:class:`~collections.abc.Iterator` of\n    \t\t:class:`.TreeEntry`).\n    \t\t""""""\n            entries = util.iter_tree_entries(root, on_error=on_error, follow_links=follow_links)\n>           yield from self.match_entries(entries, negate=negate)\nE           TypeError: PathSpec.match_entries() got an unexpected keyword argument \'negate\'\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:250: TypeError']"
python-pathspec,match_entries,"def match_entries(self, entries: Iterable[TreeEntry], separators: Optional[Collection[str]]=None, *, negate: Optional[bool]=None) -> Iterator[TreeEntry]:
    """"""
		Matches the entries to this path-spec.

		*entries* (:class:`~collections.abc.Iterable` of :class:`~pathspec.util.TreeEntry`)
		contains the entries to be matched against :attr:`self.patterns <PathSpec.patterns>`.

		*separators* (:class:`~collections.abc.Collection` of :class:`str`; or
		:data:`None`) optionally contains the path separators to normalize. See
		:func:`~pathspec.util.normalize_file` for more information.

		*negate* (:class:`bool` or :data:`None`) is whether to negate the match
		results of the patterns. If :data:`True`, a pattern matching a file will
		exclude the file rather than include it. Default is :data:`None` for
		:data:`False`.

		Returns the matched entries (:class:`~collections.abc.Iterator` of
		:class:`~pathspec.util.TreeEntry`).
		""""""
    if not _is_iterable(entries):
        raise TypeError(f'entries:{entries!r} is not an iterable.')
    use_patterns = _filter_check_patterns(self.patterns)
    for entry in entries:
        norm_file = normalize_file(entry.path, separators)
        include, _index = self._match_file(use_patterns, norm_file)
        if negate:
            include = not include
        if include:
            yield entry","This function `match_entries` takes a collection of tree entries and matches them against a set of patterns specified in a PathSpec object. It allows for optional normalization of path separators and negation of match results. The function iterates over the entries, normalizes the file paths, checks for matches against the patterns, applies negation if specified, and yields the matched entries. The goal is to filter and return the entries that match the patterns defined in the PathSpec object.",3,"def match_entries(self, entries, separators):
    for entry in entries:
        normalized_path = entry.replace('\\', '/') if separators else entry
        matched = any(pattern.match(normalized_path) for pattern in self.path_spec.patterns)
        if self.path_spec.negate_match:
            matched = not matched
        if matched:
            yield entry",['./repos/python-pathspec\\tests'],"110 Passed, 2 Failed",110,2,"['tests/test_03_pathspec.py::PathSpecTest::test_05_match_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_entries']","['self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_entries>\n\n    def test_05_match_entries(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tentries = iter_tree_entries(self.temp_dir)\n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_entries(entries)\n    \t}\nE    TypeError: PathSpec.match_entries() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:500: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_entries>\n\n    def test_05_match_tree_entries(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_tree_entries(self.temp_dir)\n    \t}\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:586: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x00000290AFAF6760>\nroot = WindowsPath(\'C:/Users/SERINE~1.SEF/AppData/Local/Temp/tmplupltnmg\')\non_error = None, follow_links = None\n\n        def match_tree_entries(self, root: StrPath, on_error: Optional[Callable[[OSError], None]]=None, follow_links: Optional[bool]=None, *, negate: Optional[bool]=None) -> Iterator[TreeEntry]:\n            """"""\n    \t\tWalks the specified root path for all files and matches them to this\n    \t\tpath-spec.\n    \n    \t\t*root* (:class:`str` or :class:`os.PathLike`) is the root directory to\n    \t\tsearch.\n    \n    \t\t*on_error* (:class:`~collections.abc.Callable` or :data:`None`) optionally\n    \t\tis the error handler for file-system exceptions. It will be called with the\n    \t\texception (:exc:`OSError`). Reraise the exception to abort the walk. Default\n    \t\tis :data:`None` to ignore file-system exceptions.\n    \n    \t\t*follow_links* (:class:`bool` or :data:`None`) optionally is whether to walk\n    \t\tsymbolic links that resolve to directories. Default is :data:`None` for\n    \t\t:data:`True`.\n    \n    \t\t*negate* (:class:`bool` or :data:`None`) is whether to negate the match\n    \t\tresults of the patterns. If :data:`True`, a pattern matching a file will\n    \t\texclude the file rather than include it. Default is :data:`None` for\n    \t\t:data:`False`.\n    \n    \t\tReturns the matched files (:class:`~collections.abc.Iterator` of\n    \t\t:class:`.TreeEntry`).\n    \t\t""""""\n            entries = util.iter_tree_entries(root, on_error=on_error, follow_links=follow_links)\n>           yield from self.match_entries(entries, negate=negate)\nE           TypeError: PathSpec.match_entries() got an unexpected keyword argument \'negate\'\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:249: TypeError']"
python-pathspec,match_file,"def match_file(self, file: StrPath, separators: Optional[Collection[str]]=None) -> bool:
    """"""
		Matches the file to this path-spec.

		*file* (:class:`str` or :class:`os.PathLike`) is the file path to be
		matched against :attr:`self.patterns <PathSpec.patterns>`.

		*separators* (:class:`~collections.abc.Collection` of :class:`str`)
		optionally contains the path separators to normalize. See
		:func:`~pathspec.util.normalize_file` for more information.

		Returns :data:`True` if *file* matched; otherwise, :data:`False`.
		""""""
    norm_file = normalize_file(file, separators)
    include, _index = self._match_file(enumerate(self.patterns), norm_file)
    return bool(include)","The goal of the `match_file` function is to take a file path as input and check if it matches the patterns specified in the path-spec object. It normalizes the file path, then iterates through the patterns to see if the file matches any of them. If a match is found, the function returns True, otherwise it returns False. This function is used to determine if a given file path matches the criteria set in the path-spec object.",1,"def match_file(self, file, separators):
    normalized_file = os.path.normpath(file)
    for pattern in separators:
        if fnmatch.fnmatch(normalized_file, pattern):
            return True
    return False",['./repos/python-pathspec\\tests'],"107 Passed, 5 Failed",107,5,"['tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_1_include', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_2_exclude', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_3_unmatch', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_file']","['self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_1_include>\n\n    def test_01_match_file_1_include(self):\n    \t""""""\n    \tTest matching a single file that is included.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""include.txt"")\nE    TypeError: PathSpec.match_file() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:270: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_2_exclude>\n\n    def test_01_match_file_2_exclude(self):\n    \t""""""\n    \tTest matching a single file that is excluded.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""test/exclude.txt"")\nE    TypeError: PathSpec.match_file() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:283: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_3_unmatch>\n\n    def test_01_match_file_3_unmatch(self):\n    \t""""""\n    \tTest match a single file that is unmatched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""unmatch.bin"")\nE    TypeError: PathSpec.match_file() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:296: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_files>\n\n    def test_01_match_files(self):\n    \t""""""\n    \tTest that matching files one at a time yields the same results as matching\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tsingle_files = set(filter(spec.match_file, files))\nE    TypeError: PathSpec.match_file() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:318: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_file>\n\n    def test_05_match_file(self):\n    \t""""""\n    \tTest matching files individually.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tincludes = set(filter(spec.match_file, files))\nE    TypeError: PathSpec.match_file() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:527: TypeError']"
python-pathspec,match_file,"def match_file(self, file: StrPath, separators: Optional[Collection[str]]=None) -> bool:
    """"""
		Matches the file to this path-spec.

		*file* (:class:`str` or :class:`os.PathLike`) is the file path to be
		matched against :attr:`self.patterns <PathSpec.patterns>`.

		*separators* (:class:`~collections.abc.Collection` of :class:`str`)
		optionally contains the path separators to normalize. See
		:func:`~pathspec.util.normalize_file` for more information.

		Returns :data:`True` if *file* matched; otherwise, :data:`False`.
		""""""
    norm_file = normalize_file(file, separators)
    include, _index = self._match_file(enumerate(self.patterns), norm_file)
    return bool(include)","The goal of the `match_file` function is to take a file path as input and check if it matches the patterns specified in the path-spec object. It normalizes the file path, then iterates through the patterns to see if the file matches any of them. If a match is found, the function returns True, otherwise it returns False. This function is used to determine if a given file path matches the criteria set in the path-spec object.",2,"def match_file(self, file, separators):
    normalized_file = os.path.normpath(file)
    
    for pattern in self.path_spec:
        pattern = pattern.replace('/', os.sep)
        pattern = pattern.replace('.', '\.')
        pattern = pattern.replace('*', '.*')
        pattern = pattern.replace('?', '.')
        pattern = '^' + pattern + '$'
        
        if re.match(pattern, normalized_file):
            return True

    return False",['./repos/python-pathspec\\tests'],"107 Passed, 5 Failed",107,5,"['tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_1_include', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_2_exclude', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_3_unmatch', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_file']","['self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_1_include>\n\n    def test_01_match_file_1_include(self):\n    \t""""""\n    \tTest matching a single file that is included.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""include.txt"")\nE    TypeError: PathSpec.match_file() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:270: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_2_exclude>\n\n    def test_01_match_file_2_exclude(self):\n    \t""""""\n    \tTest matching a single file that is excluded.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""test/exclude.txt"")\nE    TypeError: PathSpec.match_file() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:283: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_3_unmatch>\n\n    def test_01_match_file_3_unmatch(self):\n    \t""""""\n    \tTest match a single file that is unmatched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""unmatch.bin"")\nE    TypeError: PathSpec.match_file() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:296: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_files>\n\n    def test_01_match_files(self):\n    \t""""""\n    \tTest that matching files one at a time yields the same results as matching\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tsingle_files = set(filter(spec.match_file, files))\nE    TypeError: PathSpec.match_file() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:318: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_file>\n\n    def test_05_match_file(self):\n    \t""""""\n    \tTest matching files individually.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tincludes = set(filter(spec.match_file, files))\nE    TypeError: PathSpec.match_file() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:527: TypeError']"
python-pathspec,match_file,"def match_file(self, file: StrPath, separators: Optional[Collection[str]]=None) -> bool:
    """"""
		Matches the file to this path-spec.

		*file* (:class:`str` or :class:`os.PathLike`) is the file path to be
		matched against :attr:`self.patterns <PathSpec.patterns>`.

		*separators* (:class:`~collections.abc.Collection` of :class:`str`)
		optionally contains the path separators to normalize. See
		:func:`~pathspec.util.normalize_file` for more information.

		Returns :data:`True` if *file* matched; otherwise, :data:`False`.
		""""""
    norm_file = normalize_file(file, separators)
    include, _index = self._match_file(enumerate(self.patterns), norm_file)
    return bool(include)","The goal of the `match_file` function is to take a file path as input and check if it matches the patterns specified in the path-spec object. It normalizes the file path, then iterates through the patterns to see if the file matches any of them. If a match is found, the function returns True, otherwise it returns False. This function is used to determine if a given file path matches the criteria set in the path-spec object.",3,"def match_file(self, file, separators):
    normalized_file = os.path.normpath(file)
    
    for pattern in self.path_spec:
        if fnmatch.fnmatch(normalized_file, pattern):
            return True
    
    return False",['./repos/python-pathspec\\tests'],"107 Passed, 5 Failed",107,5,"['tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_1_include', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_2_exclude', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_3_unmatch', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_file']","['self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_1_include>\n\n    def test_01_match_file_1_include(self):\n    \t""""""\n    \tTest matching a single file that is included.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""include.txt"")\nE    TypeError: PathSpec.match_file() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:270: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_2_exclude>\n\n    def test_01_match_file_2_exclude(self):\n    \t""""""\n    \tTest matching a single file that is excluded.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""test/exclude.txt"")\nE    TypeError: PathSpec.match_file() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:283: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_3_unmatch>\n\n    def test_01_match_file_3_unmatch(self):\n    \t""""""\n    \tTest match a single file that is unmatched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""unmatch.bin"")\nE    TypeError: PathSpec.match_file() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:296: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_files>\n\n    def test_01_match_files(self):\n    \t""""""\n    \tTest that matching files one at a time yields the same results as matching\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tsingle_files = set(filter(spec.match_file, files))\nE    TypeError: PathSpec.match_file() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:318: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_file>\n\n    def test_05_match_file(self):\n    \t""""""\n    \tTest matching files individually.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tincludes = set(filter(spec.match_file, files))\nE    TypeError: PathSpec.match_file() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:527: TypeError']"
python-pathspec,match_files,"def match_files(self, files: Iterable[StrPath], separators: Optional[Collection[str]]=None, *, negate: Optional[bool]=None) -> Iterator[StrPath]:
    """"""
		Matches the files to this path-spec.

		*files* (:class:`~collections.abc.Iterable` of :class:`str` or
		:class:`os.PathLike`) contains the file paths to be matched against
		:attr:`self.patterns <PathSpec.patterns>`.

		*separators* (:class:`~collections.abc.Collection` of :class:`str`; or
		:data:`None`) optionally contains the path separators to normalize. See
		:func:`~pathspec.util.normalize_file` for more information.

		*negate* (:class:`bool` or :data:`None`) is whether to negate the match
		results of the patterns. If :data:`True`, a pattern matching a file will
		exclude the file rather than include it. Default is :data:`None` for
		:data:`False`.

		Returns the matched files (:class:`~collections.abc.Iterator` of
		:class:`str` or :class:`os.PathLike`).
		""""""
    if not _is_iterable(files):
        raise TypeError(f'files:{files!r} is not an iterable.')
    use_patterns = _filter_check_patterns(self.patterns)
    for orig_file in files:
        norm_file = normalize_file(orig_file, separators)
        include, _index = self._match_file(use_patterns, norm_file)
        if negate:
            include = not include
        if include:
            yield orig_file",The function `match_files` takes a list of file paths and matches them against a set of patterns. It allows for normalization of file paths using specified separators and provides an option to negate the match results of the patterns. The function returns an iterator containing the files that match the patterns after applying the normalization and negation rules. This function is a part of a class context and interacts with the class's patterns attribute to determine the matching files.,1,"def match_files(self, files, separators, negate=False):
    normalized_files = [file.replace(separators[0], separators[1]) for file in files]
    matched_files = filter(lambda x: any(pattern in x for pattern in self.patterns), normalized_files)
    
    if negate:
        matched_files = filter(lambda x: x not in matched_files, normalized_files)
    
    return iter(matched_files)",['./repos/python-pathspec\\tests'],"106 Passed, 6 Failed",106,6,"['tests/test_03_pathspec.py::PathSpecTest::test_01_check_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_files', 'tests/test_03_pathspec.py::PathSpecTest::test_09_issue_80_a', 'tests/test_03_pathspec.py::PathSpecTest::test_09_issue_80_b']","['self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_match_files>\n\n    def test_01_check_match_files(self):\n    \t""""""\n    \tTest that checking files and matching files yield the same results.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/**\',\n    \t])\n    \tfiles = {\n    \t\t\'src/test1/a.txt\',\n    \t\t\'src/test1/b.txt\',\n    \t\t\'src/test1/c/c.txt\',\n    \t\t\'src/test2/a.txt\',\n    \t\t\'src/test2/b.txt\',\n    \t\t\'src/test2/c/c.txt\',\n    \t}\n    \n    \tcheck_results = set(spec.check_files(files))\n    \tcheck_includes = get_includes(check_results)\n>   \tmatch_files = set(spec.match_files(files))\nE    TypeError: PathSpec.match_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:194: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_files>\n\n    def test_01_match_files(self):\n    \t""""""\n    \tTest that matching files one at a time yields the same results as matching\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n    \tsingle_files = set(filter(spec.match_file, files))\n>   \tmulti_files = set(spec.match_files(files))\nE    TypeError: PathSpec.match_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:319: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_files>\n\n    def test_05_match_files(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tincludes = set(spec.match_files(files))\nE    TypeError: PathSpec.match_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:553: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_files>\n\n    def test_05_match_tree_files(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n>   \tincludes = set(spec.match_tree_files(self.temp_dir))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:619: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x00000252BA716A80>\nroot = WindowsPath(\'C:/Users/SERINE~1.SEF/AppData/Local/Temp/tmpxkjsp1dz\')\non_error = None, follow_links = None\n\n        def match_tree_files(self, root: StrPath, on_error: Optional[Callable[[OSError], None]]=None, follow_links: Optional[bool]=None, *, negate: Optional[bool]=None) -> Iterator[str]:\n            """"""\n    \t\tWalks the specified root path for all files and matches them to this\n    \t\tpath-spec.\n    \n    \t\t*root* (:class:`str` or :class:`os.PathLike`) is the root directory to\n    \t\tsearch for files.\n    \n    \t\t*on_error* (:class:`~collections.abc.Callable` or :data:`None`) optionally\n    \t\tis the error handler for file-system exceptions. It will be called with the\n    \t\texception (:exc:`OSError`). Reraise the exception to abort the walk. Default\n    \t\tis :data:`None` to ignore file-system exceptions.\n    \n    \t\t*follow_links* (:class:`bool` or :data:`None`) optionally is whether to walk\n    \t\tsymbolic links that resolve to directories. Default is :data:`None` for\n    \t\t:data:`True`.\n    \n    \t\t*negate* (:class:`bool` or :data:`None`) is whether to negate the match\n    \t\tresults of the patterns. If :data:`True`, a pattern matching a file will\n    \t\texclude the file rather than include it. Default is :data:`None` for\n    \t\t:data:`False`.\n    \n    \t\tReturns the matched files (:class:`~collections.abc.Iterable` of\n    \t\t:class:`str`).\n    \t\t""""""\n            files = util.iter_tree_files(root, on_error=on_error, follow_links=follow_links)\n>           yield from self.match_files(files, negate=negate)\nE           TypeError: PathSpec.match_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:274: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_09_issue_80_a>\n\n    def test_09_issue_80_a(self):\n    \t""""""\n    \tTest negating patterns.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'build\',\n    \t\t\'*.log\',\n    \t\t\'.*\',\n    \t\t\'!.gitignore\',\n    \t])\n    \tfiles = {\n    \t\t\'.c-tmp\',\n    \t\t\'.gitignore\',\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'build/d.log\',\n    \t\t\'build/trace.bin\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tkeeps = set(spec.match_files(files, negate=True))\nE    TypeError: PathSpec.match_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:807: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_09_issue_80_b>\n\n    def test_09_issue_80_b(self):\n    \t""""""\n    \tTest negating patterns.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'build\',\n    \t\t\'*.log\',\n    \t\t\'.*\',\n    \t\t\'!.gitignore\',\n    \t])\n    \tfiles = {\n    \t\t\'.c-tmp\',\n    \t\t\'.gitignore\',\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'build/d.log\',\n    \t\t\'build/trace.bin\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tkeeps = set(spec.match_files(files, negate=True))\nE    TypeError: PathSpec.match_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:835: TypeError']"
python-pathspec,match_files,"def match_files(self, files: Iterable[StrPath], separators: Optional[Collection[str]]=None, *, negate: Optional[bool]=None) -> Iterator[StrPath]:
    """"""
		Matches the files to this path-spec.

		*files* (:class:`~collections.abc.Iterable` of :class:`str` or
		:class:`os.PathLike`) contains the file paths to be matched against
		:attr:`self.patterns <PathSpec.patterns>`.

		*separators* (:class:`~collections.abc.Collection` of :class:`str`; or
		:data:`None`) optionally contains the path separators to normalize. See
		:func:`~pathspec.util.normalize_file` for more information.

		*negate* (:class:`bool` or :data:`None`) is whether to negate the match
		results of the patterns. If :data:`True`, a pattern matching a file will
		exclude the file rather than include it. Default is :data:`None` for
		:data:`False`.

		Returns the matched files (:class:`~collections.abc.Iterator` of
		:class:`str` or :class:`os.PathLike`).
		""""""
    if not _is_iterable(files):
        raise TypeError(f'files:{files!r} is not an iterable.')
    use_patterns = _filter_check_patterns(self.patterns)
    for orig_file in files:
        norm_file = normalize_file(orig_file, separators)
        include, _index = self._match_file(use_patterns, norm_file)
        if negate:
            include = not include
        if include:
            yield orig_file",The function `match_files` takes a list of file paths and matches them against a set of patterns. It allows for normalization of file paths using specified separators and provides an option to negate the match results of the patterns. The function returns an iterator containing the files that match the patterns after applying the normalization and negation rules. This function is a part of a class context and interacts with the class's patterns attribute to determine the matching files.,2,"def match_files(self, files, separators, negate=False):
    normalized_files = [file.replace('/', separators) for file in files]
    matched_files = []

    for file in normalized_files:
        match = any(pattern in file for pattern in self.patterns)
        if (match and not negate) or (not match and negate):
            matched_files.append(file)

    return iter(matched_files)",['./repos/python-pathspec\\tests'],"106 Passed, 6 Failed",106,6,"['tests/test_03_pathspec.py::PathSpecTest::test_01_check_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_files', 'tests/test_03_pathspec.py::PathSpecTest::test_09_issue_80_a', 'tests/test_03_pathspec.py::PathSpecTest::test_09_issue_80_b']","['self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_match_files>\n\n    def test_01_check_match_files(self):\n    \t""""""\n    \tTest that checking files and matching files yield the same results.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/**\',\n    \t])\n    \tfiles = {\n    \t\t\'src/test1/a.txt\',\n    \t\t\'src/test1/b.txt\',\n    \t\t\'src/test1/c/c.txt\',\n    \t\t\'src/test2/a.txt\',\n    \t\t\'src/test2/b.txt\',\n    \t\t\'src/test2/c/c.txt\',\n    \t}\n    \n    \tcheck_results = set(spec.check_files(files))\n    \tcheck_includes = get_includes(check_results)\n>   \tmatch_files = set(spec.match_files(files))\nE    TypeError: PathSpec.match_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:194: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_files>\n\n    def test_01_match_files(self):\n    \t""""""\n    \tTest that matching files one at a time yields the same results as matching\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n    \tsingle_files = set(filter(spec.match_file, files))\n>   \tmulti_files = set(spec.match_files(files))\nE    TypeError: PathSpec.match_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:319: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_files>\n\n    def test_05_match_files(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tincludes = set(spec.match_files(files))\nE    TypeError: PathSpec.match_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:553: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_files>\n\n    def test_05_match_tree_files(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n>   \tincludes = set(spec.match_tree_files(self.temp_dir))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:619: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x000001E1876B6B70>\nroot = WindowsPath(\'C:/Users/SERINE~1.SEF/AppData/Local/Temp/tmpxze5dac1\')\non_error = None, follow_links = None\n\n        def match_tree_files(self, root: StrPath, on_error: Optional[Callable[[OSError], None]]=None, follow_links: Optional[bool]=None, *, negate: Optional[bool]=None) -> Iterator[str]:\n            """"""\n    \t\tWalks the specified root path for all files and matches them to this\n    \t\tpath-spec.\n    \n    \t\t*root* (:class:`str` or :class:`os.PathLike`) is the root directory to\n    \t\tsearch for files.\n    \n    \t\t*on_error* (:class:`~collections.abc.Callable` or :data:`None`) optionally\n    \t\tis the error handler for file-system exceptions. It will be called with the\n    \t\texception (:exc:`OSError`). Reraise the exception to abort the walk. Default\n    \t\tis :data:`None` to ignore file-system exceptions.\n    \n    \t\t*follow_links* (:class:`bool` or :data:`None`) optionally is whether to walk\n    \t\tsymbolic links that resolve to directories. Default is :data:`None` for\n    \t\t:data:`True`.\n    \n    \t\t*negate* (:class:`bool` or :data:`None`) is whether to negate the match\n    \t\tresults of the patterns. If :data:`True`, a pattern matching a file will\n    \t\texclude the file rather than include it. Default is :data:`None` for\n    \t\t:data:`False`.\n    \n    \t\tReturns the matched files (:class:`~collections.abc.Iterable` of\n    \t\t:class:`str`).\n    \t\t""""""\n            files = util.iter_tree_files(root, on_error=on_error, follow_links=follow_links)\n>           yield from self.match_files(files, negate=negate)\nE           TypeError: PathSpec.match_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:276: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_09_issue_80_a>\n\n    def test_09_issue_80_a(self):\n    \t""""""\n    \tTest negating patterns.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'build\',\n    \t\t\'*.log\',\n    \t\t\'.*\',\n    \t\t\'!.gitignore\',\n    \t])\n    \tfiles = {\n    \t\t\'.c-tmp\',\n    \t\t\'.gitignore\',\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'build/d.log\',\n    \t\t\'build/trace.bin\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tkeeps = set(spec.match_files(files, negate=True))\nE    TypeError: PathSpec.match_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:807: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_09_issue_80_b>\n\n    def test_09_issue_80_b(self):\n    \t""""""\n    \tTest negating patterns.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'build\',\n    \t\t\'*.log\',\n    \t\t\'.*\',\n    \t\t\'!.gitignore\',\n    \t])\n    \tfiles = {\n    \t\t\'.c-tmp\',\n    \t\t\'.gitignore\',\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'build/d.log\',\n    \t\t\'build/trace.bin\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tkeeps = set(spec.match_files(files, negate=True))\nE    TypeError: PathSpec.match_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:835: TypeError']"
python-pathspec,match_files,"def match_files(self, files: Iterable[StrPath], separators: Optional[Collection[str]]=None, *, negate: Optional[bool]=None) -> Iterator[StrPath]:
    """"""
		Matches the files to this path-spec.

		*files* (:class:`~collections.abc.Iterable` of :class:`str` or
		:class:`os.PathLike`) contains the file paths to be matched against
		:attr:`self.patterns <PathSpec.patterns>`.

		*separators* (:class:`~collections.abc.Collection` of :class:`str`; or
		:data:`None`) optionally contains the path separators to normalize. See
		:func:`~pathspec.util.normalize_file` for more information.

		*negate* (:class:`bool` or :data:`None`) is whether to negate the match
		results of the patterns. If :data:`True`, a pattern matching a file will
		exclude the file rather than include it. Default is :data:`None` for
		:data:`False`.

		Returns the matched files (:class:`~collections.abc.Iterator` of
		:class:`str` or :class:`os.PathLike`).
		""""""
    if not _is_iterable(files):
        raise TypeError(f'files:{files!r} is not an iterable.')
    use_patterns = _filter_check_patterns(self.patterns)
    for orig_file in files:
        norm_file = normalize_file(orig_file, separators)
        include, _index = self._match_file(use_patterns, norm_file)
        if negate:
            include = not include
        if include:
            yield orig_file",The function `match_files` takes a list of file paths and matches them against a set of patterns. It allows for normalization of file paths using specified separators and provides an option to negate the match results of the patterns. The function returns an iterator containing the files that match the patterns after applying the normalization and negation rules. This function is a part of a class context and interacts with the class's patterns attribute to determine the matching files.,3,"def match_files(self, files, separators, negate=False):
    normalized_files = []
    for file in files:
        normalized_file = file.replace('/', separators).replace('\\', separators)
        normalized_files.append(normalized_file)
    
    matched_files = []
    for pattern in self.patterns:
        for file in normalized_files:
            if pattern in file:
                if not negate:
                    matched_files.append(file)
            else:
                if negate:
                    matched_files.append(file)
    
    return iter(matched_files)",['./repos/python-pathspec\\tests'],"106 Passed, 6 Failed",106,6,"['tests/test_03_pathspec.py::PathSpecTest::test_01_check_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_files', 'tests/test_03_pathspec.py::PathSpecTest::test_09_issue_80_a', 'tests/test_03_pathspec.py::PathSpecTest::test_09_issue_80_b']","['self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_match_files>\n\n    def test_01_check_match_files(self):\n    \t""""""\n    \tTest that checking files and matching files yield the same results.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/**\',\n    \t])\n    \tfiles = {\n    \t\t\'src/test1/a.txt\',\n    \t\t\'src/test1/b.txt\',\n    \t\t\'src/test1/c/c.txt\',\n    \t\t\'src/test2/a.txt\',\n    \t\t\'src/test2/b.txt\',\n    \t\t\'src/test2/c/c.txt\',\n    \t}\n    \n    \tcheck_results = set(spec.check_files(files))\n    \tcheck_includes = get_includes(check_results)\n>   \tmatch_files = set(spec.match_files(files))\nE    TypeError: PathSpec.match_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:194: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_files>\n\n    def test_01_match_files(self):\n    \t""""""\n    \tTest that matching files one at a time yields the same results as matching\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n    \tsingle_files = set(filter(spec.match_file, files))\n>   \tmulti_files = set(spec.match_files(files))\nE    TypeError: PathSpec.match_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:319: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_files>\n\n    def test_05_match_files(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tincludes = set(spec.match_files(files))\nE    TypeError: PathSpec.match_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:553: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_files>\n\n    def test_05_match_tree_files(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n>   \tincludes = set(spec.match_tree_files(self.temp_dir))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:619: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pathspec.pathspec.PathSpec object at 0x0000013CB35769E0>\nroot = WindowsPath(\'C:/Users/SERINE~1.SEF/AppData/Local/Temp/tmprdomw79s\')\non_error = None, follow_links = None\n\n        def match_tree_files(self, root: StrPath, on_error: Optional[Callable[[OSError], None]]=None, follow_links: Optional[bool]=None, *, negate: Optional[bool]=None) -> Iterator[str]:\n            """"""\n    \t\tWalks the specified root path for all files and matches them to this\n    \t\tpath-spec.\n    \n    \t\t*root* (:class:`str` or :class:`os.PathLike`) is the root directory to\n    \t\tsearch for files.\n    \n    \t\t*on_error* (:class:`~collections.abc.Callable` or :data:`None`) optionally\n    \t\tis the error handler for file-system exceptions. It will be called with the\n    \t\texception (:exc:`OSError`). Reraise the exception to abort the walk. Default\n    \t\tis :data:`None` to ignore file-system exceptions.\n    \n    \t\t*follow_links* (:class:`bool` or :data:`None`) optionally is whether to walk\n    \t\tsymbolic links that resolve to directories. Default is :data:`None` for\n    \t\t:data:`True`.\n    \n    \t\t*negate* (:class:`bool` or :data:`None`) is whether to negate the match\n    \t\tresults of the patterns. If :data:`True`, a pattern matching a file will\n    \t\texclude the file rather than include it. Default is :data:`None` for\n    \t\t:data:`False`.\n    \n    \t\tReturns the matched files (:class:`~collections.abc.Iterable` of\n    \t\t:class:`str`).\n    \t\t""""""\n            files = util.iter_tree_files(root, on_error=on_error, follow_links=follow_links)\n>           yield from self.match_files(files, negate=negate)\nE           TypeError: PathSpec.match_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\pathspec\\pathspec.py:282: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_09_issue_80_a>\n\n    def test_09_issue_80_a(self):\n    \t""""""\n    \tTest negating patterns.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'build\',\n    \t\t\'*.log\',\n    \t\t\'.*\',\n    \t\t\'!.gitignore\',\n    \t])\n    \tfiles = {\n    \t\t\'.c-tmp\',\n    \t\t\'.gitignore\',\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'build/d.log\',\n    \t\t\'build/trace.bin\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tkeeps = set(spec.match_files(files, negate=True))\nE    TypeError: PathSpec.match_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:807: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_09_issue_80_b>\n\n    def test_09_issue_80_b(self):\n    \t""""""\n    \tTest negating patterns.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'build\',\n    \t\t\'*.log\',\n    \t\t\'.*\',\n    \t\t\'!.gitignore\',\n    \t])\n    \tfiles = {\n    \t\t\'.c-tmp\',\n    \t\t\'.gitignore\',\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'build/d.log\',\n    \t\t\'build/trace.bin\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tkeeps = set(spec.match_files(files, negate=True))\nE    TypeError: PathSpec.match_files() missing 1 required positional argument: \'separators\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:835: TypeError']"
python-pathspec,append_dir_sep,"def append_dir_sep(path: pathlib.Path) -> str:
    """"""
	Appends the path separator to the path if the path is a directory.
	This can be used to aid in distinguishing between directories and
	files on the file-system by relying on the presence of a trailing path
	separator.

	*path* (:class:`pathlib.Path`) is the path to use.

	Returns the path (:class:`str`).
	""""""
    str_path = str(path)
    if path.is_dir():
        str_path += os.sep
    return str_path",The function `append_dir_sep` takes a pathlib Path object as input and appends a path separator to the path if the path represents a directory. This can help in easily distinguishing between directories and files in the file system by checking for the presence of a trailing path separator. The function then returns the updated path as a string.,1,"def append_dir_sep(path):
    if path.is_dir():
        return str(path) + ""/""
    return str(path)",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,append_dir_sep,"def append_dir_sep(path: pathlib.Path) -> str:
    """"""
	Appends the path separator to the path if the path is a directory.
	This can be used to aid in distinguishing between directories and
	files on the file-system by relying on the presence of a trailing path
	separator.

	*path* (:class:`pathlib.Path`) is the path to use.

	Returns the path (:class:`str`).
	""""""
    str_path = str(path)
    if path.is_dir():
        str_path += os.sep
    return str_path",The function `append_dir_sep` takes a pathlib Path object as input and appends a path separator to the path if the path represents a directory. This can help in easily distinguishing between directories and files in the file system by checking for the presence of a trailing path separator. The function then returns the updated path as a string.,2,"def append_dir_sep(path):
    if path.is_dir():
        return str(path) + ""/""
    else:
        return str(path)",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,append_dir_sep,"def append_dir_sep(path: pathlib.Path) -> str:
    """"""
	Appends the path separator to the path if the path is a directory.
	This can be used to aid in distinguishing between directories and
	files on the file-system by relying on the presence of a trailing path
	separator.

	*path* (:class:`pathlib.Path`) is the path to use.

	Returns the path (:class:`str`).
	""""""
    str_path = str(path)
    if path.is_dir():
        str_path += os.sep
    return str_path",The function `append_dir_sep` takes a pathlib Path object as input and appends a path separator to the path if the path represents a directory. This can help in easily distinguishing between directories and files in the file system by checking for the presence of a trailing path separator. The function then returns the updated path as a string.,3,"def append_dir_sep(path):
    if path.is_dir():
        return str(path) + ""/""
    return str(path)",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,check_match_file,"def check_match_file(patterns: Iterable[Tuple[int, Pattern]], file: str) -> Tuple[Optional[bool], Optional[int]]:
    """"""
	Check the file against the patterns.

	*patterns* (:class:`~collections.abc.Iterable`) yields each indexed pattern
	(:class:`tuple`) which contains the pattern index (:class:`int`) and actual
	pattern (:class:`~pathspec.pattern.Pattern`).

	*file* (:class:`str`) is the normalized file path to be matched
	against *patterns*.

	Returns a :class:`tuple` containing whether to include *file* (:class:`bool`
	or :data:`None`), and the index of the last matched pattern (:class:`int` or
	:data:`None`).
	""""""
    out_include: Optional[bool] = None
    out_index: Optional[int] = None
    for index, pattern in patterns:
        if pattern.include is not None and pattern.match_file(file) is not None:
            out_include = pattern.include
            out_index = index
    return (out_include, out_index)",This function checks a given file against a set of patterns and determines whether the file should be included based on the matching pattern. It returns a boolean value indicating whether to include the file and the index of the last matched pattern.,1,"def check_match_file(patterns, file):
    should_include = False
    last_matched_index = -1
    
    for index, pattern in enumerate(patterns):
        if pattern in file:
            should_include = True
            last_matched_index = index
    
    return should_include, last_matched_index",['./repos/python-pathspec\\tests'],"79 Passed, 33 Failed",79,33,"['tests/test_01_util.py::CheckMatchFileTest::test_01_single_1_include', 'tests/test_01_util.py::CheckMatchFileTest::test_01_single_2_exclude', 'tests/test_01_util.py::CheckMatchFileTest::test_01_single_3_unmatch', 'tests/test_01_util.py::CheckMatchFileTest::test_02_many', 'tests/test_03_pathspec.py::PathSpecTest::test_01_absolute_dir_paths_1', 'tests/test_03_pathspec.py::PathSpecTest::test_01_absolute_dir_paths_2', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_1_include', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_2_exclude', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_3_unmatch', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_4_many', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_01_current_dir_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_01_empty_path_1', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_1_include', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_2_exclude', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_3_unmatch', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_01_windows_current_dir_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_01_windows_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_03_add', 'tests/test_03_pathspec.py::PathSpecTest::test_03_iadd', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_file', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_files', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_a', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_b', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_c', 'tests/test_03_pathspec.py::PathSpecTest::test_07_issue_62', 'tests/test_03_pathspec.py::PathSpecTest::test_08_issue_39', 'tests/test_03_pathspec.py::PathSpecTest::test_09_issue_80_a', 'tests/test_03_pathspec.py::PathSpecTest::test_09_issue_80_b']","['self = <tests.test_01_util.CheckMatchFileTest testMethod=test_01_single_1_include>\n\n    def test_01_single_1_include(self):\n    \t""""""\n    \tTest checking a single file that is included.\n    \t""""""\n    \tpatterns = list(enumerate(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])))\n    \n>   \tinclude_index = check_match_file(patterns, ""include.txt"")\n\nrepos\\python-pathspec\\tests\\test_01_util.py:51: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3714FC40>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3714FC80>)]\nfile = \'include.txt\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_01_util.CheckMatchFileTest testMethod=test_01_single_2_exclude>\n\n    def test_01_single_2_exclude(self):\n    \t""""""\n    \tTest checking a single file that is excluded.\n    \t""""""\n    \tpatterns = list(enumerate(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])))\n    \n>   \tinclude_index = check_match_file(patterns, ""test/exclude.txt"")\n\nrepos\\python-pathspec\\tests\\test_01_util.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3727AD00>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3727AC80>)]\nfile = \'test/exclude.txt\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_01_util.CheckMatchFileTest testMethod=test_01_single_3_unmatch>\n\n    def test_01_single_3_unmatch(self):\n    \t""""""\n    \tTest checking a single file that is ignored.\n    \t""""""\n    \tpatterns = list(enumerate(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])))\n    \n>   \tinclude_index = check_match_file(patterns, ""unmatch.bin"")\n\nrepos\\python-pathspec\\tests\\test_01_util.py:77: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC37289000>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3728A480>)]\nfile = \'unmatch.bin\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_01_util.CheckMatchFileTest testMethod=test_02_many>\n\n    def test_02_many(self):\n    \t""""""\n    \tTest matching files individually.\n    \t""""""\n    \tpatterns = list(enumerate(map(GitWildMatchPattern, [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])))\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n    \tincludes = {\n    \t\t__file\n    \t\tfor __file in files\n>   \t\tif check_match_file(patterns, __file)[0]\n    \t}\n\nrepos\\python-pathspec\\tests\\test_01_util.py:101: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC372A3DC0>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC372A3F40>)]\nfile = \'X/b.txt\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_absolute_dir_paths_1>\n\n    def test_01_absolute_dir_paths_1(self):\n    \t""""""\n    \tTests that absolute paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'foo\',\n    \t])\n    \tfiles = {\n    \t\t\'/a.py\',\n    \t\t\'/foo/a.py\',\n    \t\t\'/x/a.py\',\n    \t\t\'/x/foo/a.py\',\n    \t\t\'a.py\',\n    \t\t\'foo/a.py\',\n    \t\t\'x/a.py\',\n    \t\t\'x/foo/a.py\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:75: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC372DCC40>)]\nfile = \'x/foo/a.py\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_absolute_dir_paths_2>\n\n    def test_01_absolute_dir_paths_2(self):\n    \t""""""\n    \tTests that absolute paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'/foo\',\n    \t])\n    \tfiles = {\n    \t\t\'/a.py\',\n    \t\t\'/foo/a.py\',\n    \t\t\'/x/a.py\',\n    \t\t\'/x/foo/a.py\',\n    \t\t\'a.py\',\n    \t\t\'foo/a.py\',\n    \t\t\'x/a.py\',\n    \t\t\'x/foo/a.py\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:104: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3722C4C0>)]\nfile = \'x/foo/a.py\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_1_include>\n\n    def test_01_check_file_1_include(self):\n    \t""""""\n    \tTest checking a single file that is included.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""include.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:122: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:118: in check_file\n    include, index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x000001FC37237CE0>, file = \'include.txt\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_2_exclude>\n\n    def test_01_check_file_2_exclude(self):\n    \t""""""\n    \tTest checking a single file that is excluded.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""test/exclude.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:135: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:118: in check_file\n    include, index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x000001FC372F1B20>, file = \'test/exclude.txt\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_3_unmatch>\n\n    def test_01_check_file_3_unmatch(self):\n    \t""""""\n    \tTest checking a single file that is unmatched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""unmatch.bin"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:118: in check_file\n    include, index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x000001FC372F1800>, file = \'unmatch.bin\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_4_many>\n\n    def test_01_check_file_4_many(self):\n    \t""""""\n    \tTest that checking files one at a time yields the same results as checking\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tsingle_results = set(map(spec.check_file, files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:170: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:118: in check_file\n    include, index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x000001FC36FEDCB0>, file = \'test1/a.txt\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_match_files>\n\n    def test_01_check_match_files(self):\n    \t""""""\n    \tTest that checking files and matching files yield the same results.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/**\',\n    \t])\n    \tfiles = {\n    \t\t\'src/test1/a.txt\',\n    \t\t\'src/test1/b.txt\',\n    \t\t\'src/test1/c/c.txt\',\n    \t\t\'src/test2/a.txt\',\n    \t\t\'src/test2/b.txt\',\n    \t\t\'src/test2/c/c.txt\',\n    \t}\n    \n>   \tcheck_results = set(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:192: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3728B200>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3728AC80>)]\nfile = \'src/test2/a.txt\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_current_dir_paths>\n\n    def test_01_current_dir_paths(self):\n    \t""""""\n    \tTests that paths referencing the current directory will be properly\n    \tnormalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'./src/test1/a.txt\',\n    \t\t\'./src/test1/b.txt\',\n    \t\t\'./src/test1/c/c.txt\',\n    \t\t\'./src/test2/a.txt\',\n    \t\t\'./src/test2/b.txt\',\n    \t\t\'./src/test2/c/c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:216: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC338D10C0>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC338D0E40>)]\nfile = \'src/test2/b.txt\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_empty_path_1>\n\n    def test_01_empty_path_1(self):\n    \t""""""\n    \tTests that patterns that end with an escaped space will be treated properly.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'\\\\ \',\n    \t\t\'abc\\\\ \'\n    \t])\n    \tfiles = {\n    \t\t\' \',\n    \t\t\'  \',\n    \t\t\'abc \',\n    \t\t\'somefile\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:241: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC373605C0>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC37363C40>)]\nfile = \'abc \'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_1_include>\n\n    def test_01_match_file_1_include(self):\n    \t""""""\n    \tTest matching a single file that is included.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""include.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:270: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:279: in match_file\n    include, _index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x000001FC372F2A70>, file = \'include.txt\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_2_exclude>\n\n    def test_01_match_file_2_exclude(self):\n    \t""""""\n    \tTest matching a single file that is excluded.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""test/exclude.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:283: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:279: in match_file\n    include, _index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x000001FC372F04A0>, file = \'test/exclude.txt\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_3_unmatch>\n\n    def test_01_match_file_3_unmatch(self):\n    \t""""""\n    \tTest match a single file that is unmatched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""unmatch.bin"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:296: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:279: in match_file\n    include, _index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x000001FC36FEE020>, file = \'unmatch.bin\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_files>\n\n    def test_01_match_files(self):\n    \t""""""\n    \tTest that matching files one at a time yields the same results as matching\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tsingle_files = set(filter(spec.match_file, files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:318: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:279: in match_file\n    include, _index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x000001FC372F2160>, file = \'test1/a.txt\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_windows_current_dir_paths>\n\n    def test_01_windows_current_dir_paths(self):\n    \t""""""\n    \tTests that paths referencing the current directory will be properly\n    \tnormalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'.\\\\test1\\\\a.txt\',\n    \t\t\'.\\\\test1\\\\b.txt\',\n    \t\t\'.\\\\test1\\\\c\\\\c.txt\',\n    \t\t\'.\\\\test2\\\\a.txt\',\n    \t\t\'.\\\\test2\\\\b.txt\',\n    \t\t\'.\\\\test2\\\\c\\\\c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files, separators=[\'\\\\\']))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:341: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3701A5C0>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC338D0EC0>)]\nfile = \'test2/b.txt\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_windows_paths>\n\n    def test_01_windows_paths(self):\n    \t""""""\n    \tTests that Windows paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1\\\\a.txt\',\n    \t\t\'test1\\\\b.txt\',\n    \t\t\'test1\\\\c\\\\c.txt\',\n    \t\t\'test2\\\\a.txt\',\n    \t\t\'test2\\\\b.txt\',\n    \t\t\'test2\\\\c\\\\c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files, separators=[\'\\\\\']))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC37127940>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC37126080>)]\nfile = \'test1/b.txt\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_03_add>\n\n    def test_03_add(self):\n    \t""""""\n    \tTest spec addition using :data:`+` operator.\n    \t""""""\n    \tfirst_spec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t])\n    \tsecond_spec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t])\n    \tcombined_spec = first_spec + second_spec\n    \tfiles = {\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t}\n    \n>   \tresults = list(combined_spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:424: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3714C980>), (1, <pathspec.patterns.gitwil...object at 0x000001FC3714C5C0>), (3, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3714D7C0>)]\nfile = \'test.txt\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_03_iadd>\n\n    def test_03_iadd(self):\n    \t""""""\n    \tTest spec addition using :data:`+=` operator.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t])\n    \tspec += PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t])\n    \tfiles = {\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:454: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC37344840>), (1, <pathspec.patterns.gitwil...object at 0x000001FC37347B40>), (3, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC373458C0>)]\nfile = \'test.txt\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_entries>\n\n    def test_05_match_entries(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tentries = iter_tree_entries(self.temp_dir)\n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_entries(entries)\n    \t}\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:500: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:246: in match_entries\n    include, _index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3741BD00>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC374197C0>)]\nfile = \'X\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_file>\n\n    def test_05_match_file(self):\n    \t""""""\n    \tTest matching files individually.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tincludes = set(filter(spec.match_file, files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:527: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:279: in match_file\n    include, _index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x000001FC372F0310>, file = \'X/b.txt\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_files>\n\n    def test_05_match_files(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tincludes = set(spec.match_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:553: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:314: in match_files\n    include, _index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC37345200>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC37346DC0>)]\nfile = \'X/b.txt\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_entries>\n\n    def test_05_match_tree_entries(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_tree_entries(self.temp_dir)\n    \t}\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:586: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:355: in match_tree_entries\n    yield from self.match_entries(entries, negate=negate)\nrepos\\python-pathspec\\pathspec\\pathspec.py:246: in match_entries\n    include, _index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3731EE00>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3731F0C0>)]\nfile = \'X\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_files>\n\n    def test_05_match_tree_files(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n>   \tincludes = set(spec.match_tree_files(self.temp_dir))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:619: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:390: in match_tree_files\n    yield from self.match_files(files, negate=negate)\nrepos\\python-pathspec\\pathspec\\pathspec.py:314: in match_files\n    include, _index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC373A3E40>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC373A25C0>)]\nfile = \'X/a.txt\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_a>\n\n    def test_06_issue_41_a(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario A.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.yaml\',\n    \t\t\'!*.yaml/\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:647: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3741A480>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3741BF80>)]\nfile = \'dir.yaml/file.yaml\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_b>\n\n    def test_06_issue_41_b(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name\n    \tpattern, scenario B.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'!*.yaml/\',\n    \t\t\'*.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:683: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3728B200>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3728AE40>)]\nfile = \'dir.yaml/file.yaml\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_c>\n\n    def test_06_issue_41_c(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name\n    \tpattern, scenario C.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.yaml\',\n    \t\t\'!dir.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:718: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3734A800>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3734AA40>)]\nfile = \'dir.yaml/file.yaml\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_07_issue_62>\n\n    def test_07_issue_62(self):\n    \t""""""\n    \tTest including all files and excluding a directory.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*\',\n    \t\t\'!product_dir/\',\n    \t])\n    \tfiles = {\n    \t\t\'anydir/file.txt\',\n    \t\t\'product_dir/file.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:748: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3732FF40>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC3732F000>)]\nfile = \'product_dir/file.txt\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_08_issue_39>\n\n    def test_08_issue_39(self):\n    \t""""""\n    \tTest excluding files in a directory.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.log\',\n    \t\t\'!important/*.log\',\n    \t\t\'trace.*\',\n    \t])\n    \tfiles = {\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'important/d.log\',\n    \t\t\'important/e.txt\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:773: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC373CD980>), (1, <pathspec.patterns.gitwil...object at 0x000001FC373CE1C0>), (2, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC373CF700>)]\nfile = \'important/d.log\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_09_issue_80_a>\n\n    def test_09_issue_80_a(self):\n    \t""""""\n    \tTest negating patterns.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'build\',\n    \t\t\'*.log\',\n    \t\t\'.*\',\n    \t\t\'!.gitignore\',\n    \t])\n    \tfiles = {\n    \t\t\'.c-tmp\',\n    \t\t\'.gitignore\',\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'build/d.log\',\n    \t\t\'build/trace.bin\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tkeeps = set(spec.match_files(files, negate=True))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:807: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:314: in match_files\n    include, _index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC373BBCC0>), (1, <pathspec.patterns.gitwil...object at 0x000001FC373BBC00>), (3, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC373BAAC0>)]\nfile = \'.gitignore\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_09_issue_80_b>\n\n    def test_09_issue_80_b(self):\n    \t""""""\n    \tTest negating patterns.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'build\',\n    \t\t\'*.log\',\n    \t\t\'.*\',\n    \t\t\'!.gitignore\',\n    \t])\n    \tfiles = {\n    \t\t\'.c-tmp\',\n    \t\t\'.gitignore\',\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'build/d.log\',\n    \t\t\'build/trace.bin\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tkeeps = set(spec.match_files(files, negate=True))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:835: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:314: in match_files\n    include, _index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC37144700>), (1, <pathspec.patterns.gitwil...object at 0x000001FC37145200>), (3, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001FC37145040>)]\nfile = \'.gitignore\'\n\n    def check_match_file(patterns, file):\n        should_include = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError']"
python-pathspec,check_match_file,"def check_match_file(patterns: Iterable[Tuple[int, Pattern]], file: str) -> Tuple[Optional[bool], Optional[int]]:
    """"""
	Check the file against the patterns.

	*patterns* (:class:`~collections.abc.Iterable`) yields each indexed pattern
	(:class:`tuple`) which contains the pattern index (:class:`int`) and actual
	pattern (:class:`~pathspec.pattern.Pattern`).

	*file* (:class:`str`) is the normalized file path to be matched
	against *patterns*.

	Returns a :class:`tuple` containing whether to include *file* (:class:`bool`
	or :data:`None`), and the index of the last matched pattern (:class:`int` or
	:data:`None`).
	""""""
    out_include: Optional[bool] = None
    out_index: Optional[int] = None
    for index, pattern in patterns:
        if pattern.include is not None and pattern.match_file(file) is not None:
            out_include = pattern.include
            out_index = index
    return (out_include, out_index)",This function checks a given file against a set of patterns and determines whether the file should be included based on the matching pattern. It returns a boolean value indicating whether to include the file and the index of the last matched pattern.,2,"def check_match_file(patterns, file):
    include_file = False
    last_matched_index = -1
    
    for index, pattern in enumerate(patterns):
        if pattern in file:
            include_file = True
            last_matched_index = index
    
    return include_file, last_matched_index",['./repos/python-pathspec\\tests'],"79 Passed, 33 Failed",79,33,"['tests/test_01_util.py::CheckMatchFileTest::test_01_single_1_include', 'tests/test_01_util.py::CheckMatchFileTest::test_01_single_2_exclude', 'tests/test_01_util.py::CheckMatchFileTest::test_01_single_3_unmatch', 'tests/test_01_util.py::CheckMatchFileTest::test_02_many', 'tests/test_03_pathspec.py::PathSpecTest::test_01_absolute_dir_paths_1', 'tests/test_03_pathspec.py::PathSpecTest::test_01_absolute_dir_paths_2', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_1_include', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_2_exclude', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_3_unmatch', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_4_many', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_01_current_dir_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_01_empty_path_1', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_1_include', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_2_exclude', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_3_unmatch', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_01_windows_current_dir_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_01_windows_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_03_add', 'tests/test_03_pathspec.py::PathSpecTest::test_03_iadd', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_file', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_files', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_a', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_b', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_c', 'tests/test_03_pathspec.py::PathSpecTest::test_07_issue_62', 'tests/test_03_pathspec.py::PathSpecTest::test_08_issue_39', 'tests/test_03_pathspec.py::PathSpecTest::test_09_issue_80_a', 'tests/test_03_pathspec.py::PathSpecTest::test_09_issue_80_b']","['self = <tests.test_01_util.CheckMatchFileTest testMethod=test_01_single_1_include>\n\n    def test_01_single_1_include(self):\n    \t""""""\n    \tTest checking a single file that is included.\n    \t""""""\n    \tpatterns = list(enumerate(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])))\n    \n>   \tinclude_index = check_match_file(patterns, ""include.txt"")\n\nrepos\\python-pathspec\\tests\\test_01_util.py:51: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D501FE80>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D501FF80>)]\nfile = \'include.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_01_util.CheckMatchFileTest testMethod=test_01_single_2_exclude>\n\n    def test_01_single_2_exclude(self):\n    \t""""""\n    \tTest checking a single file that is excluded.\n    \t""""""\n    \tpatterns = list(enumerate(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])))\n    \n>   \tinclude_index = check_match_file(patterns, ""test/exclude.txt"")\n\nrepos\\python-pathspec\\tests\\test_01_util.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D514AD40>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D514AD00>)]\nfile = \'test/exclude.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_01_util.CheckMatchFileTest testMethod=test_01_single_3_unmatch>\n\n    def test_01_single_3_unmatch(self):\n    \t""""""\n    \tTest checking a single file that is ignored.\n    \t""""""\n    \tpatterns = list(enumerate(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])))\n    \n>   \tinclude_index = check_match_file(patterns, ""unmatch.bin"")\n\nrepos\\python-pathspec\\tests\\test_01_util.py:77: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D516EDC0>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D516EB80>)]\nfile = \'unmatch.bin\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_01_util.CheckMatchFileTest testMethod=test_02_many>\n\n    def test_02_many(self):\n    \t""""""\n    \tTest matching files individually.\n    \t""""""\n    \tpatterns = list(enumerate(map(GitWildMatchPattern, [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])))\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n    \tincludes = {\n    \t\t__file\n    \t\tfor __file in files\n>   \t\tif check_match_file(patterns, __file)[0]\n    \t}\n\nrepos\\python-pathspec\\tests\\test_01_util.py:101: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D5177BC0>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D5177E40>)]\nfile = \'X/a.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_absolute_dir_paths_1>\n\n    def test_01_absolute_dir_paths_1(self):\n    \t""""""\n    \tTests that absolute paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'foo\',\n    \t])\n    \tfiles = {\n    \t\t\'/a.py\',\n    \t\t\'/foo/a.py\',\n    \t\t\'/x/a.py\',\n    \t\t\'/x/foo/a.py\',\n    \t\t\'a.py\',\n    \t\t\'foo/a.py\',\n    \t\t\'x/a.py\',\n    \t\t\'x/foo/a.py\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:75: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D5124F40>)]\nfile = \'a.py\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_absolute_dir_paths_2>\n\n    def test_01_absolute_dir_paths_2(self):\n    \t""""""\n    \tTests that absolute paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'/foo\',\n    \t])\n    \tfiles = {\n    \t\t\'/a.py\',\n    \t\t\'/foo/a.py\',\n    \t\t\'/x/a.py\',\n    \t\t\'/x/foo/a.py\',\n    \t\t\'a.py\',\n    \t\t\'foo/a.py\',\n    \t\t\'x/a.py\',\n    \t\t\'x/foo/a.py\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:104: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D516D700>)]\nfile = \'a.py\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_1_include>\n\n    def test_01_check_file_1_include(self):\n    \t""""""\n    \tTest checking a single file that is included.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""include.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:122: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:118: in check_file\n    include, index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x00000244D51CBBF0>, file = \'include.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_2_exclude>\n\n    def test_01_check_file_2_exclude(self):\n    \t""""""\n    \tTest checking a single file that is excluded.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""test/exclude.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:135: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:118: in check_file\n    include, index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x00000244D51CDA30>, file = \'test/exclude.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_3_unmatch>\n\n    def test_01_check_file_3_unmatch(self):\n    \t""""""\n    \tTest checking a single file that is unmatched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""unmatch.bin"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:118: in check_file\n    include, index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x00000244D51CD710>, file = \'unmatch.bin\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_4_many>\n\n    def test_01_check_file_4_many(self):\n    \t""""""\n    \tTest that checking files one at a time yields the same results as checking\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tsingle_results = set(map(spec.check_file, files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:170: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:118: in check_file\n    include, index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x00000244D51CBD30>, file = \'test1/a.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_match_files>\n\n    def test_01_check_match_files(self):\n    \t""""""\n    \tTest that checking files and matching files yield the same results.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/**\',\n    \t])\n    \tfiles = {\n    \t\t\'src/test1/a.txt\',\n    \t\t\'src/test1/b.txt\',\n    \t\t\'src/test1/c/c.txt\',\n    \t\t\'src/test2/a.txt\',\n    \t\t\'src/test2/b.txt\',\n    \t\t\'src/test2/c/c.txt\',\n    \t}\n    \n>   \tcheck_results = set(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:192: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D1739740>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D173AC40>)]\nfile = \'src/test1/a.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_current_dir_paths>\n\n    def test_01_current_dir_paths(self):\n    \t""""""\n    \tTests that paths referencing the current directory will be properly\n    \tnormalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'./src/test1/a.txt\',\n    \t\t\'./src/test1/b.txt\',\n    \t\t\'./src/test1/c/c.txt\',\n    \t\t\'./src/test2/a.txt\',\n    \t\t\'./src/test2/b.txt\',\n    \t\t\'./src/test2/c/c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:216: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D4EEEC40>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D4EED980>)]\nfile = \'src/test1/a.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_empty_path_1>\n\n    def test_01_empty_path_1(self):\n    \t""""""\n    \tTests that patterns that end with an escaped space will be treated properly.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'\\\\ \',\n    \t\t\'abc\\\\ \'\n    \t])\n    \tfiles = {\n    \t\t\' \',\n    \t\t\'  \',\n    \t\t\'abc \',\n    \t\t\'somefile\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:241: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D4FDAD40>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D4FDAD00>)]\nfile = \'  \'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_1_include>\n\n    def test_01_match_file_1_include(self):\n    \t""""""\n    \tTest matching a single file that is included.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""include.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:270: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:279: in match_file\n    include, _index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x00000244D51CD6C0>, file = \'include.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_2_exclude>\n\n    def test_01_match_file_2_exclude(self):\n    \t""""""\n    \tTest matching a single file that is excluded.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""test/exclude.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:283: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:279: in match_file\n    include, _index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x00000244D51CC310>, file = \'test/exclude.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_3_unmatch>\n\n    def test_01_match_file_3_unmatch(self):\n    \t""""""\n    \tTest match a single file that is unmatched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""unmatch.bin"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:296: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:279: in match_file\n    include, _index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x00000244D51CBEC0>, file = \'unmatch.bin\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_files>\n\n    def test_01_match_files(self):\n    \t""""""\n    \tTest that matching files one at a time yields the same results as matching\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tsingle_files = set(filter(spec.match_file, files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:318: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:279: in match_file\n    include, _index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x00000244D51CCB80>, file = \'test1/a.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_windows_current_dir_paths>\n\n    def test_01_windows_current_dir_paths(self):\n    \t""""""\n    \tTests that paths referencing the current directory will be properly\n    \tnormalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'.\\\\test1\\\\a.txt\',\n    \t\t\'.\\\\test1\\\\b.txt\',\n    \t\t\'.\\\\test1\\\\c\\\\c.txt\',\n    \t\t\'.\\\\test2\\\\a.txt\',\n    \t\t\'.\\\\test2\\\\b.txt\',\n    \t\t\'.\\\\test2\\\\c\\\\c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files, separators=[\'\\\\\']))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:341: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D5231040>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D5231800>)]\nfile = \'test1/a.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_windows_paths>\n\n    def test_01_windows_paths(self):\n    \t""""""\n    \tTests that Windows paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1\\\\a.txt\',\n    \t\t\'test1\\\\b.txt\',\n    \t\t\'test1\\\\c\\\\c.txt\',\n    \t\t\'test2\\\\a.txt\',\n    \t\t\'test2\\\\b.txt\',\n    \t\t\'test2\\\\c\\\\c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files, separators=[\'\\\\\']))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D5003000>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D5000A80>)]\nfile = \'test2/a.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_03_add>\n\n    def test_03_add(self):\n    \t""""""\n    \tTest spec addition using :data:`+` operator.\n    \t""""""\n    \tfirst_spec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t])\n    \tsecond_spec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t])\n    \tcombined_spec = first_spec + second_spec\n    \tfiles = {\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t}\n    \n>   \tresults = list(combined_spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:424: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D51A6FC0>), (1, <pathspec.patterns.gitwil...object at 0x00000244D51A5FC0>), (3, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D51A5E80>)]\nfile = \'test.jpg\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_03_iadd>\n\n    def test_03_iadd(self):\n    \t""""""\n    \tTest spec addition using :data:`+=` operator.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t])\n    \tspec += PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t])\n    \tfiles = {\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:454: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D5127D80>), (1, <pathspec.patterns.gitwil...object at 0x00000244D4FF41C0>), (3, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D4FF4C80>)]\nfile = \'test.jpg\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_entries>\n\n    def test_05_match_entries(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tentries = iter_tree_entries(self.temp_dir)\n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_entries(entries)\n    \t}\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:500: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:246: in match_entries\n    include, _index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D520F4C0>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D520CCC0>)]\nfile = \'X\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_file>\n\n    def test_05_match_file(self):\n    \t""""""\n    \tTest matching files individually.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tincludes = set(filter(spec.match_file, files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:527: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:279: in match_file\n    include, _index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x00000244D51CC130>, file = \'X/a.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_files>\n\n    def test_05_match_files(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tincludes = set(spec.match_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:553: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:314: in match_files\n    include, _index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D528D340>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D528CCC0>)]\nfile = \'X/a.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_entries>\n\n    def test_05_match_tree_entries(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_tree_entries(self.temp_dir)\n    \t}\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:586: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:355: in match_tree_entries\n    yield from self.match_entries(entries, negate=negate)\nrepos\\python-pathspec\\pathspec\\pathspec.py:246: in match_entries\n    include, _index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D4FDB680>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D5231500>)]\nfile = \'X\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_files>\n\n    def test_05_match_tree_files(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n>   \tincludes = set(spec.match_tree_files(self.temp_dir))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:619: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:390: in match_tree_files\n    yield from self.match_files(files, negate=negate)\nrepos\\python-pathspec\\pathspec\\pathspec.py:314: in match_files\n    include, _index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D5256740>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D52567C0>)]\nfile = \'X/a.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_a>\n\n    def test_06_issue_41_a(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario A.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.yaml\',\n    \t\t\'!*.yaml/\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:647: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D51E9280>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D51E8D40>)]\nfile = \'dir/index.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_b>\n\n    def test_06_issue_41_b(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name\n    \tpattern, scenario B.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'!*.yaml/\',\n    \t\t\'*.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:683: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D5269280>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D5268CC0>)]\nfile = \'dir/index.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_c>\n\n    def test_06_issue_41_c(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name\n    \tpattern, scenario C.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.yaml\',\n    \t\t\'!dir.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:718: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D51B3180>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D4D48E80>)]\nfile = \'dir/index.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_07_issue_62>\n\n    def test_07_issue_62(self):\n    \t""""""\n    \tTest including all files and excluding a directory.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*\',\n    \t\t\'!product_dir/\',\n    \t])\n    \tfiles = {\n    \t\t\'anydir/file.txt\',\n    \t\t\'product_dir/file.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:748: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D51FC400>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D51FC7C0>)]\nfile = \'anydir/file.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_08_issue_39>\n\n    def test_08_issue_39(self):\n    \t""""""\n    \tTest excluding files in a directory.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.log\',\n    \t\t\'!important/*.log\',\n    \t\t\'trace.*\',\n    \t])\n    \tfiles = {\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'important/d.log\',\n    \t\t\'important/e.txt\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:773: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D4EBE640>), (1, <pathspec.patterns.gitwil...object at 0x00000244D4EBC440>), (2, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D4EBE240>)]\nfile = \'a.log\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_09_issue_80_a>\n\n    def test_09_issue_80_a(self):\n    \t""""""\n    \tTest negating patterns.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'build\',\n    \t\t\'*.log\',\n    \t\t\'.*\',\n    \t\t\'!.gitignore\',\n    \t])\n    \tfiles = {\n    \t\t\'.c-tmp\',\n    \t\t\'.gitignore\',\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'build/d.log\',\n    \t\t\'build/trace.bin\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tkeeps = set(spec.match_files(files, negate=True))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:807: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:314: in match_files\n    include, _index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D524BC00>), (1, <pathspec.patterns.gitwil...object at 0x00000244D524AE80>), (3, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D524AB80>)]\nfile = \'a.log\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_09_issue_80_b>\n\n    def test_09_issue_80_b(self):\n    \t""""""\n    \tTest negating patterns.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'build\',\n    \t\t\'*.log\',\n    \t\t\'.*\',\n    \t\t\'!.gitignore\',\n    \t])\n    \tfiles = {\n    \t\t\'.c-tmp\',\n    \t\t\'.gitignore\',\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'build/d.log\',\n    \t\t\'build/trace.bin\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tkeeps = set(spec.match_files(files, negate=True))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:835: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:314: in match_files\n    include, _index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D4EEECC0>), (1, <pathspec.patterns.gitwil...object at 0x00000244D4EED980>), (3, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000244D4EEEA40>)]\nfile = \'a.log\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for index, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError']"
python-pathspec,check_match_file,"def check_match_file(patterns: Iterable[Tuple[int, Pattern]], file: str) -> Tuple[Optional[bool], Optional[int]]:
    """"""
	Check the file against the patterns.

	*patterns* (:class:`~collections.abc.Iterable`) yields each indexed pattern
	(:class:`tuple`) which contains the pattern index (:class:`int`) and actual
	pattern (:class:`~pathspec.pattern.Pattern`).

	*file* (:class:`str`) is the normalized file path to be matched
	against *patterns*.

	Returns a :class:`tuple` containing whether to include *file* (:class:`bool`
	or :data:`None`), and the index of the last matched pattern (:class:`int` or
	:data:`None`).
	""""""
    out_include: Optional[bool] = None
    out_index: Optional[int] = None
    for index, pattern in patterns:
        if pattern.include is not None and pattern.match_file(file) is not None:
            out_include = pattern.include
            out_index = index
    return (out_include, out_index)",This function checks a given file against a set of patterns and determines whether the file should be included based on the matching pattern. It returns a boolean value indicating whether to include the file and the index of the last matched pattern.,3,"def check_match_file(patterns, file):
    include_file = False
    last_matched_index = -1
    
    for i, pattern in enumerate(patterns):
        if pattern in file:
            include_file = True
            last_matched_index = i
    
    return include_file, last_matched_index",['./repos/python-pathspec\\tests'],"79 Passed, 33 Failed",79,33,"['tests/test_01_util.py::CheckMatchFileTest::test_01_single_1_include', 'tests/test_01_util.py::CheckMatchFileTest::test_01_single_2_exclude', 'tests/test_01_util.py::CheckMatchFileTest::test_01_single_3_unmatch', 'tests/test_01_util.py::CheckMatchFileTest::test_02_many', 'tests/test_03_pathspec.py::PathSpecTest::test_01_absolute_dir_paths_1', 'tests/test_03_pathspec.py::PathSpecTest::test_01_absolute_dir_paths_2', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_1_include', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_2_exclude', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_3_unmatch', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_4_many', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_01_current_dir_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_01_empty_path_1', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_1_include', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_2_exclude', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_3_unmatch', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_01_windows_current_dir_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_01_windows_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_03_add', 'tests/test_03_pathspec.py::PathSpecTest::test_03_iadd', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_file', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_files', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_a', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_b', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_c', 'tests/test_03_pathspec.py::PathSpecTest::test_07_issue_62', 'tests/test_03_pathspec.py::PathSpecTest::test_08_issue_39', 'tests/test_03_pathspec.py::PathSpecTest::test_09_issue_80_a', 'tests/test_03_pathspec.py::PathSpecTest::test_09_issue_80_b']","['self = <tests.test_01_util.CheckMatchFileTest testMethod=test_01_single_1_include>\n\n    def test_01_single_1_include(self):\n    \t""""""\n    \tTest checking a single file that is included.\n    \t""""""\n    \tpatterns = list(enumerate(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])))\n    \n>   \tinclude_index = check_match_file(patterns, ""include.txt"")\n\nrepos\\python-pathspec\\tests\\test_01_util.py:51: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFBDC400>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFBDC440>)]\nfile = \'include.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_01_util.CheckMatchFileTest testMethod=test_01_single_2_exclude>\n\n    def test_01_single_2_exclude(self):\n    \t""""""\n    \tTest checking a single file that is excluded.\n    \t""""""\n    \tpatterns = list(enumerate(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])))\n    \n>   \tinclude_index = check_match_file(patterns, ""test/exclude.txt"")\n\nrepos\\python-pathspec\\tests\\test_01_util.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFCDEDC0>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFCDED40>)]\nfile = \'test/exclude.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_01_util.CheckMatchFileTest testMethod=test_01_single_3_unmatch>\n\n    def test_01_single_3_unmatch(self):\n    \t""""""\n    \tTest checking a single file that is ignored.\n    \t""""""\n    \tpatterns = list(enumerate(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])))\n    \n>   \tinclude_index = check_match_file(patterns, ""unmatch.bin"")\n\nrepos\\python-pathspec\\tests\\test_01_util.py:77: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFBDFE80>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFBDFC80>)]\nfile = \'unmatch.bin\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_01_util.CheckMatchFileTest testMethod=test_02_many>\n\n    def test_02_many(self):\n    \t""""""\n    \tTest matching files individually.\n    \t""""""\n    \tpatterns = list(enumerate(map(GitWildMatchPattern, [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])))\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n    \tincludes = {\n    \t\t__file\n    \t\tfor __file in files\n>   \t\tif check_match_file(patterns, __file)[0]\n    \t}\n\nrepos\\python-pathspec\\tests\\test_01_util.py:101: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFD03880>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFD02180>)]\nfile = \'X/b.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_absolute_dir_paths_1>\n\n    def test_01_absolute_dir_paths_1(self):\n    \t""""""\n    \tTests that absolute paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'foo\',\n    \t])\n    \tfiles = {\n    \t\t\'/a.py\',\n    \t\t\'/foo/a.py\',\n    \t\t\'/x/a.py\',\n    \t\t\'/x/foo/a.py\',\n    \t\t\'a.py\',\n    \t\t\'foo/a.py\',\n    \t\t\'x/a.py\',\n    \t\t\'x/foo/a.py\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:75: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFCE9C40>)]\nfile = \'x/a.py\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_absolute_dir_paths_2>\n\n    def test_01_absolute_dir_paths_2(self):\n    \t""""""\n    \tTests that absolute paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'/foo\',\n    \t])\n    \tfiles = {\n    \t\t\'/a.py\',\n    \t\t\'/foo/a.py\',\n    \t\t\'/x/a.py\',\n    \t\t\'/x/foo/a.py\',\n    \t\t\'a.py\',\n    \t\t\'foo/a.py\',\n    \t\t\'x/a.py\',\n    \t\t\'x/foo/a.py\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:104: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFAF6900>)]\nfile = \'x/a.py\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_1_include>\n\n    def test_01_check_file_1_include(self):\n    \t""""""\n    \tTest checking a single file that is included.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""include.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:122: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:118: in check_file\n    include, index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x00000186BFCF7BF0>, file = \'include.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_2_exclude>\n\n    def test_01_check_file_2_exclude(self):\n    \t""""""\n    \tTest checking a single file that is excluded.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""test/exclude.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:135: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:118: in check_file\n    include, index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x00000186BFCE1A30>, file = \'test/exclude.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_3_unmatch>\n\n    def test_01_check_file_3_unmatch(self):\n    \t""""""\n    \tTest checking a single file that is unmatched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""unmatch.bin"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:118: in check_file\n    include, index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x00000186BFCE1710>, file = \'unmatch.bin\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_4_many>\n\n    def test_01_check_file_4_many(self):\n    \t""""""\n    \tTest that checking files one at a time yields the same results as checking\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tsingle_results = set(map(spec.check_file, files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:170: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:118: in check_file\n    include, index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x00000186BFCF7D30>, file = \'test2/a.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_match_files>\n\n    def test_01_check_match_files(self):\n    \t""""""\n    \tTest that checking files and matching files yield the same results.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/**\',\n    \t])\n    \tfiles = {\n    \t\t\'src/test1/a.txt\',\n    \t\t\'src/test1/b.txt\',\n    \t\t\'src/test1/c/c.txt\',\n    \t\t\'src/test2/a.txt\',\n    \t\t\'src/test2/b.txt\',\n    \t\t\'src/test2/c/c.txt\',\n    \t}\n    \n>   \tcheck_results = set(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:192: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFA7F280>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFA7EE80>)]\nfile = \'src/test1/c/c.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_current_dir_paths>\n\n    def test_01_current_dir_paths(self):\n    \t""""""\n    \tTests that paths referencing the current directory will be properly\n    \tnormalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'./src/test1/a.txt\',\n    \t\t\'./src/test1/b.txt\',\n    \t\t\'./src/test1/c/c.txt\',\n    \t\t\'./src/test2/a.txt\',\n    \t\t\'./src/test2/b.txt\',\n    \t\t\'./src/test2/c/c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:216: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BC338580>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BC338D40>)]\nfile = \'src/test2/a.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_empty_path_1>\n\n    def test_01_empty_path_1(self):\n    \t""""""\n    \tTests that patterns that end with an escaped space will be treated properly.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'\\\\ \',\n    \t\t\'abc\\\\ \'\n    \t])\n    \tfiles = {\n    \t\t\' \',\n    \t\t\'  \',\n    \t\t\'abc \',\n    \t\t\'somefile\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:241: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFDF5AC0>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFDF48C0>)]\nfile = \'abc \'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_1_include>\n\n    def test_01_match_file_1_include(self):\n    \t""""""\n    \tTest matching a single file that is included.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""include.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:270: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:279: in match_file\n    include, _index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x00000186BFCE2BB0>, file = \'include.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_2_exclude>\n\n    def test_01_match_file_2_exclude(self):\n    \t""""""\n    \tTest matching a single file that is excluded.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""test/exclude.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:283: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:279: in match_file\n    include, _index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x00000186BFCE0540>, file = \'test/exclude.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_3_unmatch>\n\n    def test_01_match_file_3_unmatch(self):\n    \t""""""\n    \tTest match a single file that is unmatched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""unmatch.bin"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:296: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:279: in match_file\n    include, _index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x00000186BFCF7C40>, file = \'unmatch.bin\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_files>\n\n    def test_01_match_files(self):\n    \t""""""\n    \tTest that matching files one at a time yields the same results as matching\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tsingle_files = set(filter(spec.match_file, files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:318: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:279: in match_file\n    include, _index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x00000186BFCE2070>, file = \'test2/a.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_windows_current_dir_paths>\n\n    def test_01_windows_current_dir_paths(self):\n    \t""""""\n    \tTests that paths referencing the current directory will be properly\n    \tnormalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'.\\\\test1\\\\a.txt\',\n    \t\t\'.\\\\test1\\\\b.txt\',\n    \t\t\'.\\\\test1\\\\c\\\\c.txt\',\n    \t\t\'.\\\\test2\\\\a.txt\',\n    \t\t\'.\\\\test2\\\\b.txt\',\n    \t\t\'.\\\\test2\\\\c\\\\c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files, separators=[\'\\\\\']))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:341: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFC64FC0>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFC64AC0>)]\nfile = \'test1/b.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_windows_paths>\n\n    def test_01_windows_paths(self):\n    \t""""""\n    \tTests that Windows paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1\\\\a.txt\',\n    \t\t\'test1\\\\b.txt\',\n    \t\t\'test1\\\\c\\\\c.txt\',\n    \t\t\'test2\\\\a.txt\',\n    \t\t\'test2\\\\b.txt\',\n    \t\t\'test2\\\\c\\\\c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files, separators=[\'\\\\\']))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFDA4380>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFDA47C0>)]\nfile = \'test1/b.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_03_add>\n\n    def test_03_add(self):\n    \t""""""\n    \tTest spec addition using :data:`+` operator.\n    \t""""""\n    \tfirst_spec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t])\n    \tsecond_spec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t])\n    \tcombined_spec = first_spec + second_spec\n    \tfiles = {\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t}\n    \n>   \tresults = list(combined_spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:424: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFD41E80>), (1, <pathspec.patterns.gitwil...object at 0x00000186BFD00B80>), (3, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFD03540>)]\nfile = \'test.png\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_03_iadd>\n\n    def test_03_iadd(self):\n    \t""""""\n    \tTest spec addition using :data:`+=` operator.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t])\n    \tspec += PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t])\n    \tfiles = {\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:454: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFE56780>), (1, <pathspec.patterns.gitwil...object at 0x00000186BFE55200>), (3, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFE572C0>)]\nfile = \'test.png\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_entries>\n\n    def test_05_match_entries(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tentries = iter_tree_entries(self.temp_dir)\n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_entries(entries)\n    \t}\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:500: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:246: in match_entries\n    include, _index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFE61B80>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFE60080>)]\nfile = \'X\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_file>\n\n    def test_05_match_file(self):\n    \t""""""\n    \tTest matching files individually.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tincludes = set(filter(spec.match_file, files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:527: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:279: in match_file\n    include, _index = self._match_file(enumerate(self.patterns), norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = <enumerate object at 0x00000186BFCE2750>, file = \'X/b.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_files>\n\n    def test_05_match_files(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tincludes = set(spec.match_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:553: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:314: in match_files\n    include, _index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFA4BA80>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFA49800>)]\nfile = \'X/b.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_entries>\n\n    def test_05_match_tree_entries(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_tree_entries(self.temp_dir)\n    \t}\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:586: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:355: in match_tree_entries\n    yield from self.match_entries(entries, negate=negate)\nrepos\\python-pathspec\\pathspec\\pathspec.py:246: in match_entries\n    include, _index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFE628C0>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFE63BC0>)]\nfile = \'X\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_files>\n\n    def test_05_match_tree_files(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n>   \tincludes = set(spec.match_tree_files(self.temp_dir))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:619: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:390: in match_tree_files\n    yield from self.match_files(files, negate=negate)\nrepos\\python-pathspec\\pathspec\\pathspec.py:314: in match_files\n    include, _index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFDE9080>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFDE8F40>)]\nfile = \'X/a.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_a>\n\n    def test_06_issue_41_a(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario A.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.yaml\',\n    \t\t\'!*.yaml/\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:647: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BC338AC0>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFE55A40>)]\nfile = \'dir.yaml/index.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_b>\n\n    def test_06_issue_41_b(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name\n    \tpattern, scenario B.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'!*.yaml/\',\n    \t\t\'*.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:683: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFA5ED00>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFA5E640>)]\nfile = \'dir.yaml/index.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_c>\n\n    def test_06_issue_41_c(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name\n    \tpattern, scenario C.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.yaml\',\n    \t\t\'!dir.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:718: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFA49F80>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFA48A00>)]\nfile = \'dir.yaml/index.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_07_issue_62>\n\n    def test_07_issue_62(self):\n    \t""""""\n    \tTest including all files and excluding a directory.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*\',\n    \t\t\'!product_dir/\',\n    \t])\n    \tfiles = {\n    \t\t\'anydir/file.txt\',\n    \t\t\'product_dir/file.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:748: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFD01140>), (1, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFD00140>)]\nfile = \'anydir/file.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_08_issue_39>\n\n    def test_08_issue_39(self):\n    \t""""""\n    \tTest excluding files in a directory.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.log\',\n    \t\t\'!important/*.log\',\n    \t\t\'trace.*\',\n    \t])\n    \tfiles = {\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'important/d.log\',\n    \t\t\'important/e.txt\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:773: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:146: in check_files\n    include, index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFD8CA40>), (1, <pathspec.patterns.gitwil...object at 0x00000186BFD8D040>), (2, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFD8CFC0>)]\nfile = \'important/e.txt\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_09_issue_80_a>\n\n    def test_09_issue_80_a(self):\n    \t""""""\n    \tTest negating patterns.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'build\',\n    \t\t\'*.log\',\n    \t\t\'.*\',\n    \t\t\'!.gitignore\',\n    \t])\n    \tfiles = {\n    \t\t\'.c-tmp\',\n    \t\t\'.gitignore\',\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'build/d.log\',\n    \t\t\'build/trace.bin\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tkeeps = set(spec.match_files(files, negate=True))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:807: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:314: in match_files\n    include, _index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFA5E280>), (1, <pathspec.patterns.gitwil...object at 0x00000186BFA5DF40>), (3, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFA5CE00>)]\nfile = \'.c-tmp\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_09_issue_80_b>\n\n    def test_09_issue_80_b(self):\n    \t""""""\n    \tTest negating patterns.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'build\',\n    \t\t\'*.log\',\n    \t\t\'.*\',\n    \t\t\'!.gitignore\',\n    \t])\n    \tfiles = {\n    \t\t\'.c-tmp\',\n    \t\t\'.gitignore\',\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'build/d.log\',\n    \t\t\'build/trace.bin\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tkeeps = set(spec.match_files(files, negate=True))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:835: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:314: in match_files\n    include, _index = self._match_file(use_patterns, norm_file)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [(0, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFC51AC0>), (1, <pathspec.patterns.gitwil...object at 0x00000186BFC51CC0>), (3, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000186BFC51A80>)]\nfile = \'.c-tmp\'\n\n    def check_match_file(patterns, file):\n        include_file = False\n        last_matched_index = -1\n        for i, pattern in enumerate(patterns):\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not tuple\n\nrepos\\python-pathspec\\pathspec\\util.py:47: TypeError']"
python-pathspec,detailed_match_files,"def detailed_match_files(patterns: Iterable[Pattern], files: Iterable[str], all_matches: Optional[bool]=None) -> Dict[str, 'MatchDetail']:
    """"""
	Matches the files to the patterns, and returns which patterns matched
	the files.

	*patterns* (:class:`~collections.abc.Iterable` of :class:`~pathspec.pattern.Pattern`)
	contains the patterns to use.

	*files* (:class:`~collections.abc.Iterable` of :class:`str`) contains
	the normalized file paths to be matched against *patterns*.

	*all_matches* (:class:`bool` or :data:`None`) is whether to return all
	matches patterns (:data:`True`), or only the last matched pattern
	(:data:`False`). Default is :data:`None` for :data:`False`.

	Returns the matched files (:class:`dict`) which maps each matched file
	(:class:`str`) to the patterns that matched in order (:class:`.MatchDetail`).
	""""""
    all_files = files if isinstance(files, CollectionType) else list(files)
    return_files = {}
    for pattern in patterns:
        if pattern.include is not None:
            result_files = pattern.match(all_files)
            if pattern.include:
                for result_file in result_files:
                    if result_file in return_files:
                        if all_matches:
                            return_files[result_file].patterns.append(pattern)
                        else:
                            return_files[result_file].patterns[0] = pattern
                    else:
                        return_files[result_file] = MatchDetail([pattern])
            else:
                for file in result_files:
                    del return_files[file]
    return return_files","This function takes a collection of patterns and a collection of files as input. It then matches each file against the patterns provided and returns a dictionary where each file is mapped to the patterns that matched it. The function allows for the option to return all matching patterns for each file or only the last matched pattern. If a file matches an include pattern, it is included in the result, while if it matches an exclude pattern, it is removed from the result.",1,"def detailed_match_files(patterns, files, all_matches=False):
    matched_files = {}

    for file in files:
        matched_patterns = []
        for pattern in patterns:
            if pattern.startswith('include') and pattern[7:] in file:
                matched_patterns.append(pattern)
            elif pattern.startswith('exclude') and pattern[7:] in file:
                matched_patterns = []
                break
        
        if matched_patterns:
            if all_matches:
                matched_files[file] = matched_patterns
            else:
                matched_files[file] = [matched_patterns[-1]]

    return matched_files",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,detailed_match_files,"def detailed_match_files(patterns: Iterable[Pattern], files: Iterable[str], all_matches: Optional[bool]=None) -> Dict[str, 'MatchDetail']:
    """"""
	Matches the files to the patterns, and returns which patterns matched
	the files.

	*patterns* (:class:`~collections.abc.Iterable` of :class:`~pathspec.pattern.Pattern`)
	contains the patterns to use.

	*files* (:class:`~collections.abc.Iterable` of :class:`str`) contains
	the normalized file paths to be matched against *patterns*.

	*all_matches* (:class:`bool` or :data:`None`) is whether to return all
	matches patterns (:data:`True`), or only the last matched pattern
	(:data:`False`). Default is :data:`None` for :data:`False`.

	Returns the matched files (:class:`dict`) which maps each matched file
	(:class:`str`) to the patterns that matched in order (:class:`.MatchDetail`).
	""""""
    all_files = files if isinstance(files, CollectionType) else list(files)
    return_files = {}
    for pattern in patterns:
        if pattern.include is not None:
            result_files = pattern.match(all_files)
            if pattern.include:
                for result_file in result_files:
                    if result_file in return_files:
                        if all_matches:
                            return_files[result_file].patterns.append(pattern)
                        else:
                            return_files[result_file].patterns[0] = pattern
                    else:
                        return_files[result_file] = MatchDetail([pattern])
            else:
                for file in result_files:
                    del return_files[file]
    return return_files","This function takes a collection of patterns and a collection of files as input. It then matches each file against the patterns provided and returns a dictionary where each file is mapped to the patterns that matched it. The function allows for the option to return all matching patterns for each file or only the last matched pattern. If a file matches an include pattern, it is included in the result, while if it matches an exclude pattern, it is removed from the result.",2,"def detailed_match_files(patterns, files, return_all_matches):
    matched_files = {}

    for file in files:
        matched_patterns = []
        for pattern in patterns:
            if pattern.startswith('include') and pattern[7:] in file:
                matched_patterns.append(pattern[7:])
            elif pattern.startswith('exclude') and pattern[7:] in file:
                matched_patterns = []
                break
        
        if return_all_matches:
            matched_files[file] = matched_patterns
        else:
            if matched_patterns:
                matched_files[file] = [matched_patterns[-1]]
    
    return matched_files",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,detailed_match_files,"def detailed_match_files(patterns: Iterable[Pattern], files: Iterable[str], all_matches: Optional[bool]=None) -> Dict[str, 'MatchDetail']:
    """"""
	Matches the files to the patterns, and returns which patterns matched
	the files.

	*patterns* (:class:`~collections.abc.Iterable` of :class:`~pathspec.pattern.Pattern`)
	contains the patterns to use.

	*files* (:class:`~collections.abc.Iterable` of :class:`str`) contains
	the normalized file paths to be matched against *patterns*.

	*all_matches* (:class:`bool` or :data:`None`) is whether to return all
	matches patterns (:data:`True`), or only the last matched pattern
	(:data:`False`). Default is :data:`None` for :data:`False`.

	Returns the matched files (:class:`dict`) which maps each matched file
	(:class:`str`) to the patterns that matched in order (:class:`.MatchDetail`).
	""""""
    all_files = files if isinstance(files, CollectionType) else list(files)
    return_files = {}
    for pattern in patterns:
        if pattern.include is not None:
            result_files = pattern.match(all_files)
            if pattern.include:
                for result_file in result_files:
                    if result_file in return_files:
                        if all_matches:
                            return_files[result_file].patterns.append(pattern)
                        else:
                            return_files[result_file].patterns[0] = pattern
                    else:
                        return_files[result_file] = MatchDetail([pattern])
            else:
                for file in result_files:
                    del return_files[file]
    return return_files","This function takes a collection of patterns and a collection of files as input. It then matches each file against the patterns provided and returns a dictionary where each file is mapped to the patterns that matched it. The function allows for the option to return all matching patterns for each file or only the last matched pattern. If a file matches an include pattern, it is included in the result, while if it matches an exclude pattern, it is removed from the result.",3,"def detailed_match_files(patterns, files, all_matches=False):
    result = {}
    
    for file in files:
        matched_patterns = []
        
        for pattern in patterns:
            if pattern.match(file):
                matched_patterns.append(pattern)
        
        if all_matches:
            result[file] = matched_patterns
        else:
            if matched_patterns:
                result[file] = [matched_patterns[-1]]
    
    return result",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,iter_tree_entries,"def iter_tree_entries(root: StrPath, on_error: Optional[Callable[[OSError], None]]=None, follow_links: Optional[bool]=None) -> Iterator['TreeEntry']:
    """"""
	Walks the specified directory for all files and directories.

	*root* (:class:`str` or :class:`os.PathLike`) is the root directory to
	search.

	*on_error* (:class:`~collections.abc.Callable` or :data:`None`)
	optionally is the error handler for file-system exceptions. It will be
	called with the exception (:exc:`OSError`). Reraise the exception to
	abort the walk. Default is :data:`None` to ignore file-system
	exceptions.

	*follow_links* (:class:`bool` or :data:`None`) optionally is whether
	to walk symbolic links that resolve to directories. Default is
	:data:`None` for :data:`True`.

	Raises :exc:`RecursionError` if recursion is detected.

	Returns an :class:`~collections.abc.Iterator` yielding each file or
	directory entry (:class:`.TreeEntry`) relative to *root*.
	""""""
    if on_error is not None and (not callable(on_error)):
        raise TypeError(f'on_error:{on_error!r} is not callable.')
    if follow_links is None:
        follow_links = True
    yield from _iter_tree_entries_next(os.path.abspath(root), '', {}, on_error, follow_links)",The function `iter_tree_entries` is designed to walk through a specified directory and its subdirectories to retrieve all files and directories. It allows for handling file-system exceptions and has an option to follow symbolic links that resolve to directories. The function returns an iterator yielding each file or directory entry relative to the specified root directory.,1,"def iter_tree_entries(root, on_error=None, follow_links=False):
    import os

    def walk(root):
        try:
            entries = os.scandir(root)
            for entry in entries:
                yield entry
                if entry.is_dir() and (follow_links or not entry.is_symlink()):
                    yield from walk(entry.path)
        except OSError as e:
            if on_error:
                on_error(e)

    return walk(root)",['./repos/python-pathspec\\tests'],"107 Passed, 5 Failed",107,5,"['tests/test_01_util.py::IterTreeTest::test_01_files', 'tests/test_01_util.py::IterTreeTest::test_03_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_files']","['self = <tests.test_01_util.IterTreeTest testMethod=test_01_files>\n\n    def test_01_files(self):\n    \t""""""\n    \tTests to make sure all files are found.\n    \t""""""\n    \tself.make_dirs([\n    \t\t\'Empty\',\n    \t\t\'Dir\',\n    \t\t\'Dir/Inner\',\n    \t])\n    \tself.make_files([\n    \t\t\'a\',\n    \t\t\'b\',\n    \t\t\'Dir/c\',\n    \t\t\'Dir/d\',\n    \t\t\'Dir/Inner/e\',\n    \t\t\'Dir/Inner/f\',\n    \t])\n>   \tresults = set(iter_tree_files(self.temp_dir))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:172: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot = WindowsPath(\'C:/Users/SERINE~1.SEF/AppData/Local/Temp/tmp1h8n7d7s\')\non_error = None, follow_links = None\n\n    def iter_tree_files(root: StrPath, on_error: Optional[Callable[[OSError], None]]=None, follow_links: Optional[bool]=None) -> Iterator[str]:\n        """"""\n    \tWalks the specified directory for all files.\n    \n    \t*root* (:class:`str` or :class:`os.PathLike`) is the root directory to\n    \tsearch for files.\n    \n    \t*on_error* (:class:`~collections.abc.Callable` or :data:`None`)\n    \toptionally is the error handler for file-system exceptions. It will be\n    \tcalled with the exception (:exc:`OSError`). Reraise the exception to\n    \tabort the walk. Default is :data:`None` to ignore file-system\n    \texceptions.\n    \n    \t*follow_links* (:class:`bool` or :data:`None`) optionally is whether\n    \tto walk symbolic links that resolve to directories. Default is\n    \t:data:`None` for :data:`True`.\n    \n    \tRaises :exc:`RecursionError` if recursion is detected.\n    \n    \tReturns an :class:`~collections.abc.Iterator` yielding the path to\n    \teach file (:class:`str`) relative to *root*.\n    \t""""""\n        for entry in iter_tree_entries(root, on_error=on_error, follow_links=follow_links):\n>           if not entry.is_dir(follow_links):\nE           TypeError: is_dir() takes no positional arguments\n\nrepos\\python-pathspec\\pathspec\\util.py:217: TypeError', 'self = <tests.test_01_util.IterTreeTest testMethod=test_03_entries>\n\n    def test_03_entries(self):\n    \t""""""\n    \tTests to make sure all files are found.\n    \t""""""\n    \tself.make_dirs([\n    \t\t\'Empty\',\n    \t\t\'Dir\',\n    \t\t\'Dir/Inner\',\n    \t])\n    \tself.make_files([\n    \t\t\'a\',\n    \t\t\'b\',\n    \t\t\'Dir/c\',\n    \t\t\'Dir/d\',\n    \t\t\'Dir/Inner/e\',\n    \t\t\'Dir/Inner/f\',\n    \t])\n    \tresults = {entry.path for entry in iter_tree_entries(self.temp_dir)}\n>   \tself.assertEqual(results, set(map(ospath, [\n    \t\t\'a\',\n    \t\t\'b\',\n    \t\t\'Dir\',\n    \t\t\'Dir/c\',\n    \t\t\'Dir/d\',\n    \t\t\'Dir/Inner\',\n    \t\t\'Dir/Inner/e\',\n    \t\t\'Dir/Inner/f\',\n    \t\t\'Empty\',\n    \t])))\nE    AssertionError: Items in the first set but not the second:\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp6ye7dhx6\\\\Dir\\\\Inner\\\\e\'\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp6ye7dhx6\\\\Dir\\\\c\'\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp6ye7dhx6\\\\Empty\'\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp6ye7dhx6\\\\Dir\\\\Inner\\\\f\'\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp6ye7dhx6\\\\Dir\\\\d\'\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp6ye7dhx6\\\\Dir\'\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp6ye7dhx6\\\\a\'\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp6ye7dhx6\\\\Dir\\\\Inner\'\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp6ye7dhx6\\\\b\'\nE    Items in the second set but not the first:\nE    \'Dir\\\\c\'\nE    \'Dir\\\\Inner\\\\f\'\nE    \'a\'\nE    \'b\'\nE    \'Dir\'\nE    \'Dir\\\\Inner\'\nE    \'Dir\\\\Inner\\\\e\'\nE    \'Dir\\\\d\'\nE    \'Empty\'\n\nrepos\\python-pathspec\\tests\\test_01_util.py:406: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_entries>\n\n    def test_05_match_entries(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tentries = iter_tree_entries(self.temp_dir)\n    \tincludes = {\n    \t\t__entry.path for __entry in spec.match_entries(entries)\n    \t}\n    \n>   \tself.assertEqual(includes, set(map(ospath, [\n    \t\t\'X/a.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])))\nE    AssertionError: Items in the first set but not the second:\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp74l0f5xa\\\\X\\\\Z\\\\c.txt\'\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp74l0f5xa\\\\X\\\\a.txt\'\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp74l0f5xa\\\\Y\\\\a.txt\'\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp74l0f5xa\\\\Y\\\\Z\\\\c.txt\'\nE    Items in the second set but not the first:\nE    \'X\\\\a.txt\'\nE    \'Y\\\\a.txt\'\nE    \'X\\\\Z\\\\c.txt\'\nE    \'Y\\\\Z\\\\c.txt\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:503: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_entries>\n\n    def test_05_match_tree_entries(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tincludes = {\n    \t\t__entry.path for __entry in spec.match_tree_entries(self.temp_dir)\n    \t}\n    \n>   \tself.assertEqual(includes, set(map(ospath, [\n    \t\t\'X/a.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])))\nE    AssertionError: Items in the first set but not the second:\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp6fvbug77\\\\Y\\\\a.txt\'\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp6fvbug77\\\\X\\\\a.txt\'\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp6fvbug77\\\\X\\\\Z\\\\c.txt\'\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp6fvbug77\\\\Y\\\\Z\\\\c.txt\'\nE    Items in the second set but not the first:\nE    \'X\\\\a.txt\'\nE    \'Y\\\\a.txt\'\nE    \'X\\\\Z\\\\c.txt\'\nE    \'Y\\\\Z\\\\c.txt\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:589: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_files>\n\n    def test_05_match_tree_files(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n>   \tincludes = set(spec.match_tree_files(self.temp_dir))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:619: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:390: in match_tree_files\n    yield from self.match_files(files, negate=negate)\nrepos\\python-pathspec\\pathspec\\pathspec.py:312: in match_files\n    for orig_file in files:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot = WindowsPath(\'C:/Users/SERINE~1.SEF/AppData/Local/Temp/tmpb5ottxh6\')\non_error = None, follow_links = None\n\n    def iter_tree_files(root: StrPath, on_error: Optional[Callable[[OSError], None]]=None, follow_links: Optional[bool]=None) -> Iterator[str]:\n        """"""\n    \tWalks the specified directory for all files.\n    \n    \t*root* (:class:`str` or :class:`os.PathLike`) is the root directory to\n    \tsearch for files.\n    \n    \t*on_error* (:class:`~collections.abc.Callable` or :data:`None`)\n    \toptionally is the error handler for file-system exceptions. It will be\n    \tcalled with the exception (:exc:`OSError`). Reraise the exception to\n    \tabort the walk. Default is :data:`None` to ignore file-system\n    \texceptions.\n    \n    \t*follow_links* (:class:`bool` or :data:`None`) optionally is whether\n    \tto walk symbolic links that resolve to directories. Default is\n    \t:data:`None` for :data:`True`.\n    \n    \tRaises :exc:`RecursionError` if recursion is detected.\n    \n    \tReturns an :class:`~collections.abc.Iterator` yielding the path to\n    \teach file (:class:`str`) relative to *root*.\n    \t""""""\n        for entry in iter_tree_entries(root, on_error=on_error, follow_links=follow_links):\n>           if not entry.is_dir(follow_links):\nE           TypeError: is_dir() takes no positional arguments\n\nrepos\\python-pathspec\\pathspec\\util.py:217: TypeError']"
python-pathspec,iter_tree_entries,"def iter_tree_entries(root: StrPath, on_error: Optional[Callable[[OSError], None]]=None, follow_links: Optional[bool]=None) -> Iterator['TreeEntry']:
    """"""
	Walks the specified directory for all files and directories.

	*root* (:class:`str` or :class:`os.PathLike`) is the root directory to
	search.

	*on_error* (:class:`~collections.abc.Callable` or :data:`None`)
	optionally is the error handler for file-system exceptions. It will be
	called with the exception (:exc:`OSError`). Reraise the exception to
	abort the walk. Default is :data:`None` to ignore file-system
	exceptions.

	*follow_links* (:class:`bool` or :data:`None`) optionally is whether
	to walk symbolic links that resolve to directories. Default is
	:data:`None` for :data:`True`.

	Raises :exc:`RecursionError` if recursion is detected.

	Returns an :class:`~collections.abc.Iterator` yielding each file or
	directory entry (:class:`.TreeEntry`) relative to *root*.
	""""""
    if on_error is not None and (not callable(on_error)):
        raise TypeError(f'on_error:{on_error!r} is not callable.')
    if follow_links is None:
        follow_links = True
    yield from _iter_tree_entries_next(os.path.abspath(root), '', {}, on_error, follow_links)",The function `iter_tree_entries` is designed to walk through a specified directory and its subdirectories to retrieve all files and directories. It allows for handling file-system exceptions and has an option to follow symbolic links that resolve to directories. The function returns an iterator yielding each file or directory entry relative to the specified root directory.,2,"def iter_tree_entries(root, on_error=None, follow_links=False):
    import os

    def get_entries(root):
        for entry in os.scandir(root):
            yield entry

            if entry.is_dir() and follow_links and entry.is_symlink():
                yield from get_entries(entry.path)

    try:
        yield from get_entries(root)
    except OSError as e:
        if on_error:
            on_error(e)
        else:
            raise e",['./repos/python-pathspec\\tests'],"107 Passed, 5 Failed",107,5,"['tests/test_01_util.py::IterTreeTest::test_01_files', 'tests/test_01_util.py::IterTreeTest::test_03_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_files']","['self = <tests.test_01_util.IterTreeTest testMethod=test_01_files>\n\n    def test_01_files(self):\n    \t""""""\n    \tTests to make sure all files are found.\n    \t""""""\n    \tself.make_dirs([\n    \t\t\'Empty\',\n    \t\t\'Dir\',\n    \t\t\'Dir/Inner\',\n    \t])\n    \tself.make_files([\n    \t\t\'a\',\n    \t\t\'b\',\n    \t\t\'Dir/c\',\n    \t\t\'Dir/d\',\n    \t\t\'Dir/Inner/e\',\n    \t\t\'Dir/Inner/f\',\n    \t])\n>   \tresults = set(iter_tree_files(self.temp_dir))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:172: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot = WindowsPath(\'C:/Users/SERINE~1.SEF/AppData/Local/Temp/tmp5hyse5hy\')\non_error = None, follow_links = None\n\n    def iter_tree_files(root: StrPath, on_error: Optional[Callable[[OSError], None]]=None, follow_links: Optional[bool]=None) -> Iterator[str]:\n        """"""\n    \tWalks the specified directory for all files.\n    \n    \t*root* (:class:`str` or :class:`os.PathLike`) is the root directory to\n    \tsearch for files.\n    \n    \t*on_error* (:class:`~collections.abc.Callable` or :data:`None`)\n    \toptionally is the error handler for file-system exceptions. It will be\n    \tcalled with the exception (:exc:`OSError`). Reraise the exception to\n    \tabort the walk. Default is :data:`None` to ignore file-system\n    \texceptions.\n    \n    \t*follow_links* (:class:`bool` or :data:`None`) optionally is whether\n    \tto walk symbolic links that resolve to directories. Default is\n    \t:data:`None` for :data:`True`.\n    \n    \tRaises :exc:`RecursionError` if recursion is detected.\n    \n    \tReturns an :class:`~collections.abc.Iterator` yielding the path to\n    \teach file (:class:`str`) relative to *root*.\n    \t""""""\n        for entry in iter_tree_entries(root, on_error=on_error, follow_links=follow_links):\n>           if not entry.is_dir(follow_links):\nE           TypeError: is_dir() takes no positional arguments\n\nrepos\\python-pathspec\\pathspec\\util.py:218: TypeError', 'self = <tests.test_01_util.IterTreeTest testMethod=test_03_entries>\n\n    def test_03_entries(self):\n    \t""""""\n    \tTests to make sure all files are found.\n    \t""""""\n    \tself.make_dirs([\n    \t\t\'Empty\',\n    \t\t\'Dir\',\n    \t\t\'Dir/Inner\',\n    \t])\n    \tself.make_files([\n    \t\t\'a\',\n    \t\t\'b\',\n    \t\t\'Dir/c\',\n    \t\t\'Dir/d\',\n    \t\t\'Dir/Inner/e\',\n    \t\t\'Dir/Inner/f\',\n    \t])\n    \tresults = {entry.path for entry in iter_tree_entries(self.temp_dir)}\n>   \tself.assertEqual(results, set(map(ospath, [\n    \t\t\'a\',\n    \t\t\'b\',\n    \t\t\'Dir\',\n    \t\t\'Dir/c\',\n    \t\t\'Dir/d\',\n    \t\t\'Dir/Inner\',\n    \t\t\'Dir/Inner/e\',\n    \t\t\'Dir/Inner/f\',\n    \t\t\'Empty\',\n    \t])))\nE    AssertionError: Items in the first set but not the second:\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmpf3ut52wd\\\\a\'\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmpf3ut52wd\\\\b\'\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmpf3ut52wd\\\\Dir\'\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmpf3ut52wd\\\\Empty\'\nE    Items in the second set but not the first:\nE    \'a\'\nE    \'Dir\\\\Inner\\\\f\'\nE    \'Dir\\\\Inner\\\\e\'\nE    \'Dir\\\\c\'\nE    \'Dir\'\nE    \'b\'\nE    \'Dir\\\\Inner\'\nE    \'Empty\'\nE    \'Dir\\\\d\'\n\nrepos\\python-pathspec\\tests\\test_01_util.py:406: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_entries>\n\n    def test_05_match_entries(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tentries = iter_tree_entries(self.temp_dir)\n    \tincludes = {\n    \t\t__entry.path for __entry in spec.match_entries(entries)\n    \t}\n    \n>   \tself.assertEqual(includes, set(map(ospath, [\n    \t\t\'X/a.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])))\nE    AssertionError: Items in the second set but not the first:\nE    \'Y\\\\a.txt\'\nE    \'X\\\\Z\\\\c.txt\'\nE    \'X\\\\a.txt\'\nE    \'Y\\\\Z\\\\c.txt\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:503: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_entries>\n\n    def test_05_match_tree_entries(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tincludes = {\n    \t\t__entry.path for __entry in spec.match_tree_entries(self.temp_dir)\n    \t}\n    \n>   \tself.assertEqual(includes, set(map(ospath, [\n    \t\t\'X/a.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])))\nE    AssertionError: Items in the second set but not the first:\nE    \'Y\\\\a.txt\'\nE    \'X\\\\Z\\\\c.txt\'\nE    \'X\\\\a.txt\'\nE    \'Y\\\\Z\\\\c.txt\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:589: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_files>\n\n    def test_05_match_tree_files(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n>   \tincludes = set(spec.match_tree_files(self.temp_dir))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:619: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:390: in match_tree_files\n    yield from self.match_files(files, negate=negate)\nrepos\\python-pathspec\\pathspec\\pathspec.py:312: in match_files\n    for orig_file in files:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot = WindowsPath(\'C:/Users/SERINE~1.SEF/AppData/Local/Temp/tmplwdb8vp1\')\non_error = None, follow_links = None\n\n    def iter_tree_files(root: StrPath, on_error: Optional[Callable[[OSError], None]]=None, follow_links: Optional[bool]=None) -> Iterator[str]:\n        """"""\n    \tWalks the specified directory for all files.\n    \n    \t*root* (:class:`str` or :class:`os.PathLike`) is the root directory to\n    \tsearch for files.\n    \n    \t*on_error* (:class:`~collections.abc.Callable` or :data:`None`)\n    \toptionally is the error handler for file-system exceptions. It will be\n    \tcalled with the exception (:exc:`OSError`). Reraise the exception to\n    \tabort the walk. Default is :data:`None` to ignore file-system\n    \texceptions.\n    \n    \t*follow_links* (:class:`bool` or :data:`None`) optionally is whether\n    \tto walk symbolic links that resolve to directories. Default is\n    \t:data:`None` for :data:`True`.\n    \n    \tRaises :exc:`RecursionError` if recursion is detected.\n    \n    \tReturns an :class:`~collections.abc.Iterator` yielding the path to\n    \teach file (:class:`str`) relative to *root*.\n    \t""""""\n        for entry in iter_tree_entries(root, on_error=on_error, follow_links=follow_links):\n>           if not entry.is_dir(follow_links):\nE           TypeError: is_dir() takes no positional arguments\n\nrepos\\python-pathspec\\pathspec\\util.py:218: TypeError']"
python-pathspec,iter_tree_entries,"def iter_tree_entries(root: StrPath, on_error: Optional[Callable[[OSError], None]]=None, follow_links: Optional[bool]=None) -> Iterator['TreeEntry']:
    """"""
	Walks the specified directory for all files and directories.

	*root* (:class:`str` or :class:`os.PathLike`) is the root directory to
	search.

	*on_error* (:class:`~collections.abc.Callable` or :data:`None`)
	optionally is the error handler for file-system exceptions. It will be
	called with the exception (:exc:`OSError`). Reraise the exception to
	abort the walk. Default is :data:`None` to ignore file-system
	exceptions.

	*follow_links* (:class:`bool` or :data:`None`) optionally is whether
	to walk symbolic links that resolve to directories. Default is
	:data:`None` for :data:`True`.

	Raises :exc:`RecursionError` if recursion is detected.

	Returns an :class:`~collections.abc.Iterator` yielding each file or
	directory entry (:class:`.TreeEntry`) relative to *root*.
	""""""
    if on_error is not None and (not callable(on_error)):
        raise TypeError(f'on_error:{on_error!r} is not callable.')
    if follow_links is None:
        follow_links = True
    yield from _iter_tree_entries_next(os.path.abspath(root), '', {}, on_error, follow_links)",The function `iter_tree_entries` is designed to walk through a specified directory and its subdirectories to retrieve all files and directories. It allows for handling file-system exceptions and has an option to follow symbolic links that resolve to directories. The function returns an iterator yielding each file or directory entry relative to the specified root directory.,3,"def iter_tree_entries(root, on_error=None, follow_links=False):
    import os

    def inner_iter_tree_entries(root):
        try:
            for entry in os.scandir(root):
                if entry.is_dir() and follow_links:
                    yield entry
                    yield from inner_iter_tree_entries(entry.path)
                elif entry.is_file() or (entry.is_symlink() and os.path.isdir(entry.path) and follow_links):
                    yield entry
        except Exception as e:
            if on_error:
                on_error(e)

    return inner_iter_tree_entries(root)",['./repos/python-pathspec\\tests'],"107 Passed, 5 Failed",107,5,"['tests/test_01_util.py::IterTreeTest::test_01_files', 'tests/test_01_util.py::IterTreeTest::test_03_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_files']","['self = <tests.test_01_util.IterTreeTest testMethod=test_01_files>\n\n    def test_01_files(self):\n    \t""""""\n    \tTests to make sure all files are found.\n    \t""""""\n    \tself.make_dirs([\n    \t\t\'Empty\',\n    \t\t\'Dir\',\n    \t\t\'Dir/Inner\',\n    \t])\n    \tself.make_files([\n    \t\t\'a\',\n    \t\t\'b\',\n    \t\t\'Dir/c\',\n    \t\t\'Dir/d\',\n    \t\t\'Dir/Inner/e\',\n    \t\t\'Dir/Inner/f\',\n    \t])\n>   \tresults = set(iter_tree_files(self.temp_dir))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:172: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot = WindowsPath(\'C:/Users/SERINE~1.SEF/AppData/Local/Temp/tmp9o_w3d4u\')\non_error = None, follow_links = None\n\n    def iter_tree_files(root: StrPath, on_error: Optional[Callable[[OSError], None]]=None, follow_links: Optional[bool]=None) -> Iterator[str]:\n        """"""\n    \tWalks the specified directory for all files.\n    \n    \t*root* (:class:`str` or :class:`os.PathLike`) is the root directory to\n    \tsearch for files.\n    \n    \t*on_error* (:class:`~collections.abc.Callable` or :data:`None`)\n    \toptionally is the error handler for file-system exceptions. It will be\n    \tcalled with the exception (:exc:`OSError`). Reraise the exception to\n    \tabort the walk. Default is :data:`None` to ignore file-system\n    \texceptions.\n    \n    \t*follow_links* (:class:`bool` or :data:`None`) optionally is whether\n    \tto walk symbolic links that resolve to directories. Default is\n    \t:data:`None` for :data:`True`.\n    \n    \tRaises :exc:`RecursionError` if recursion is detected.\n    \n    \tReturns an :class:`~collections.abc.Iterator` yielding the path to\n    \teach file (:class:`str`) relative to *root*.\n    \t""""""\n        for entry in iter_tree_entries(root, on_error=on_error, follow_links=follow_links):\n>           if not entry.is_dir(follow_links):\nE           TypeError: is_dir() takes no positional arguments\n\nrepos\\python-pathspec\\pathspec\\util.py:218: TypeError', 'self = <tests.test_01_util.IterTreeTest testMethod=test_03_entries>\n\n    def test_03_entries(self):\n    \t""""""\n    \tTests to make sure all files are found.\n    \t""""""\n    \tself.make_dirs([\n    \t\t\'Empty\',\n    \t\t\'Dir\',\n    \t\t\'Dir/Inner\',\n    \t])\n    \tself.make_files([\n    \t\t\'a\',\n    \t\t\'b\',\n    \t\t\'Dir/c\',\n    \t\t\'Dir/d\',\n    \t\t\'Dir/Inner/e\',\n    \t\t\'Dir/Inner/f\',\n    \t])\n    \tresults = {entry.path for entry in iter_tree_entries(self.temp_dir)}\n>   \tself.assertEqual(results, set(map(ospath, [\n    \t\t\'a\',\n    \t\t\'b\',\n    \t\t\'Dir\',\n    \t\t\'Dir/c\',\n    \t\t\'Dir/d\',\n    \t\t\'Dir/Inner\',\n    \t\t\'Dir/Inner/e\',\n    \t\t\'Dir/Inner/f\',\n    \t\t\'Empty\',\n    \t])))\nE    AssertionError: Items in the first set but not the second:\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmpyzruc43m\\\\b\'\nE    \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmpyzruc43m\\\\a\'\nE    Items in the second set but not the first:\nE    \'b\'\nE    \'Dir\\\\c\'\nE    \'Dir\\\\Inner\'\nE    \'Dir\\\\d\'\nE    \'a\'\nE    \'Empty\'\nE    \'Dir\\\\Inner\\\\f\'\nE    \'Dir\\\\Inner\\\\e\'\nE    \'Dir\'\n\nrepos\\python-pathspec\\tests\\test_01_util.py:406: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_entries>\n\n    def test_05_match_entries(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tentries = iter_tree_entries(self.temp_dir)\n    \tincludes = {\n    \t\t__entry.path for __entry in spec.match_entries(entries)\n    \t}\n    \n>   \tself.assertEqual(includes, set(map(ospath, [\n    \t\t\'X/a.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])))\nE    AssertionError: Items in the second set but not the first:\nE    \'X\\\\Z\\\\c.txt\'\nE    \'Y\\\\a.txt\'\nE    \'X\\\\a.txt\'\nE    \'Y\\\\Z\\\\c.txt\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:503: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_entries>\n\n    def test_05_match_tree_entries(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tincludes = {\n    \t\t__entry.path for __entry in spec.match_tree_entries(self.temp_dir)\n    \t}\n    \n>   \tself.assertEqual(includes, set(map(ospath, [\n    \t\t\'X/a.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])))\nE    AssertionError: Items in the second set but not the first:\nE    \'X\\\\Z\\\\c.txt\'\nE    \'Y\\\\a.txt\'\nE    \'X\\\\a.txt\'\nE    \'Y\\\\Z\\\\c.txt\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:589: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_files>\n\n    def test_05_match_tree_files(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tincludes = set(spec.match_tree_files(self.temp_dir))\n    \n>   \tself.assertEqual(includes, set(map(ospath, [\n    \t\t\'X/a.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])))\nE    AssertionError: Items in the second set but not the first:\nE    \'X\\\\Z\\\\c.txt\'\nE    \'Y\\\\a.txt\'\nE    \'X\\\\a.txt\'\nE    \'Y\\\\Z\\\\c.txt\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:621: AssertionError']"
python-pathspec,_iter_tree_entries_next,"def _iter_tree_entries_next(root_full: str, dir_rel: str, memo: Dict[str, str], on_error: Callable[[OSError], None], follow_links: bool) -> Iterator['TreeEntry']:
    """"""
	Scan the directory for all descendant files.

	*root_full* (:class:`str`) the absolute path to the root directory.

	*dir_rel* (:class:`str`) the path to the directory to scan relative to
	*root_full*.

	*memo* (:class:`dict`) keeps track of ancestor directories
	encountered. Maps each ancestor real path (:class:`str`) to relative
	path (:class:`str`).

	*on_error* (:class:`~collections.abc.Callable` or :data:`None`)
	optionally is the error handler for file-system exceptions.

	*follow_links* (:class:`bool`) is whether to walk symbolic links that
	resolve to directories.

	Yields each entry (:class:`.TreeEntry`).
	""""""
    dir_full = os.path.join(root_full, dir_rel)
    dir_real = os.path.realpath(dir_full)
    if dir_real not in memo:
        memo[dir_real] = dir_rel
    else:
        raise RecursionError(real_path=dir_real, first_path=memo[dir_real], second_path=dir_rel)
    with os.scandir(dir_full) as scan_iter:
        node_ent: os.DirEntry
        for node_ent in scan_iter:
            node_rel = os.path.join(dir_rel, node_ent.name)
            try:
                node_lstat = node_ent.stat(follow_symlinks=False)
            except OSError as e:
                if on_error is not None:
                    on_error(e)
                continue
            if node_ent.is_symlink():
                try:
                    node_stat = node_ent.stat()
                except OSError as e:
                    if on_error is not None:
                        on_error(e)
                    continue
            else:
                node_stat = node_lstat
            if node_ent.is_dir(follow_symlinks=follow_links):
                yield TreeEntry(node_ent.name, node_rel, node_lstat, node_stat)
                yield from _iter_tree_entries_next(root_full, node_rel, memo, on_error, follow_links)
            elif node_ent.is_file() or node_ent.is_symlink():
                yield TreeEntry(node_ent.name, node_rel, node_lstat, node_stat)
    del memo[dir_real]","The goal of the function is to recursively scan a directory and its descendant files, yielding each entry as a TreeEntry object. It keeps track of encountered ancestor directories to prevent infinite recursion and handles errors using an optional error handler. The function also supports following symbolic links that resolve to directories. It iterates through the directory entries, checking for directories, files, and symbolic links, and yields the corresponding TreeEntry objects for each entry found.",1,"def _iter_tree_entries_next(root_full, dir_rel, memo=None, on_error=None, follow_links=False):
    if memo is None:
        memo = set()

    try:
        full_path = os.path.join(root_full, dir_rel)
        if os.path.islink(full_path) and follow_links:
            real_path = os.path.realpath(full_path)
            if os.path.isdir(real_path):
                dir_rel = os.path.relpath(real_path, root_full)

        if dir_rel not in memo:
            memo.add(dir_rel)
            yield TreeEntry(full_path)

            if os.path.isdir(full_path):
                for entry in os.listdir(full_path):
                    yield from _iter_tree_entries_next(root_full, os.path.join(dir_rel, entry), memo, on_error, follow_links)
    except Exception as e:
        if on_error:
            on_error(e)
        else:
            raise e",['./repos/python-pathspec\\tests'],"107 Passed, 5 Failed",107,5,"['tests/test_01_util.py::IterTreeTest::test_01_files', 'tests/test_01_util.py::IterTreeTest::test_03_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_files']","['self = <tests.test_01_util.IterTreeTest testMethod=test_01_files>\n\n    def test_01_files(self):\n    \t""""""\n    \tTests to make sure all files are found.\n    \t""""""\n    \tself.make_dirs([\n    \t\t\'Empty\',\n    \t\t\'Dir\',\n    \t\t\'Dir/Inner\',\n    \t])\n    \tself.make_files([\n    \t\t\'a\',\n    \t\t\'b\',\n    \t\t\'Dir/c\',\n    \t\t\'Dir/d\',\n    \t\t\'Dir/Inner/e\',\n    \t\t\'Dir/Inner/f\',\n    \t])\n>   \tresults = set(iter_tree_files(self.temp_dir))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:172: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\util.py:197: in iter_tree_files\n    for entry in iter_tree_entries(root, on_error=on_error, follow_links=follow_links):\nrepos\\python-pathspec\\pathspec\\util.py:152: in iter_tree_entries\n    yield from _iter_tree_entries_next(os.path.abspath(root), \'\', {}, on_error, follow_links)\nrepos\\python-pathspec\\pathspec\\util.py:173: in _iter_tree_entries_next\n    raise e\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot_full = \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp1z949a65\'\ndir_rel = \'\', memo = {}, on_error = None, follow_links = True\n\n    def _iter_tree_entries_next(root_full, dir_rel, memo=None, on_error=None, follow_links=False):\n        if memo is None:\n            memo = set()\n        try:\n            full_path = os.path.join(root_full, dir_rel)\n            if os.path.islink(full_path) and follow_links:\n                real_path = os.path.realpath(full_path)\n                if os.path.isdir(real_path):\n                    dir_rel = os.path.relpath(real_path, root_full)\n            if dir_rel not in memo:\n>               memo.add(dir_rel)\nE               AttributeError: \'dict\' object has no attribute \'add\'\n\nrepos\\python-pathspec\\pathspec\\util.py:164: AttributeError', 'self = <tests.test_01_util.IterTreeTest testMethod=test_03_entries>\n\n    def test_03_entries(self):\n    \t""""""\n    \tTests to make sure all files are found.\n    \t""""""\n    \tself.make_dirs([\n    \t\t\'Empty\',\n    \t\t\'Dir\',\n    \t\t\'Dir/Inner\',\n    \t])\n    \tself.make_files([\n    \t\t\'a\',\n    \t\t\'b\',\n    \t\t\'Dir/c\',\n    \t\t\'Dir/d\',\n    \t\t\'Dir/Inner/e\',\n    \t\t\'Dir/Inner/f\',\n    \t])\n>   \tresults = {entry.path for entry in iter_tree_entries(self.temp_dir)}\n\nrepos\\python-pathspec\\tests\\test_01_util.py:405: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\util.py:152: in iter_tree_entries\n    yield from _iter_tree_entries_next(os.path.abspath(root), \'\', {}, on_error, follow_links)\nrepos\\python-pathspec\\pathspec\\util.py:173: in _iter_tree_entries_next\n    raise e\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot_full = \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmpufjq5e8x\'\ndir_rel = \'\', memo = {}, on_error = None, follow_links = True\n\n    def _iter_tree_entries_next(root_full, dir_rel, memo=None, on_error=None, follow_links=False):\n        if memo is None:\n            memo = set()\n        try:\n            full_path = os.path.join(root_full, dir_rel)\n            if os.path.islink(full_path) and follow_links:\n                real_path = os.path.realpath(full_path)\n                if os.path.isdir(real_path):\n                    dir_rel = os.path.relpath(real_path, root_full)\n            if dir_rel not in memo:\n>               memo.add(dir_rel)\nE               AttributeError: \'dict\' object has no attribute \'add\'\n\nrepos\\python-pathspec\\pathspec\\util.py:164: AttributeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_entries>\n\n    def test_05_match_entries(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tentries = iter_tree_entries(self.temp_dir)\n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_entries(entries)\n    \t}\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:500: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:244: in match_entries\n    for entry in entries:\nrepos\\python-pathspec\\pathspec\\util.py:152: in iter_tree_entries\n    yield from _iter_tree_entries_next(os.path.abspath(root), \'\', {}, on_error, follow_links)\nrepos\\python-pathspec\\pathspec\\util.py:173: in _iter_tree_entries_next\n    raise e\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot_full = \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmplwdbpm2n\'\ndir_rel = \'\', memo = {}, on_error = None, follow_links = True\n\n    def _iter_tree_entries_next(root_full, dir_rel, memo=None, on_error=None, follow_links=False):\n        if memo is None:\n            memo = set()\n        try:\n            full_path = os.path.join(root_full, dir_rel)\n            if os.path.islink(full_path) and follow_links:\n                real_path = os.path.realpath(full_path)\n                if os.path.isdir(real_path):\n                    dir_rel = os.path.relpath(real_path, root_full)\n            if dir_rel not in memo:\n>               memo.add(dir_rel)\nE               AttributeError: \'dict\' object has no attribute \'add\'\n\nrepos\\python-pathspec\\pathspec\\util.py:164: AttributeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_entries>\n\n    def test_05_match_tree_entries(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_tree_entries(self.temp_dir)\n    \t}\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:586: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:355: in match_tree_entries\n    yield from self.match_entries(entries, negate=negate)\nrepos\\python-pathspec\\pathspec\\pathspec.py:244: in match_entries\n    for entry in entries:\nrepos\\python-pathspec\\pathspec\\util.py:152: in iter_tree_entries\n    yield from _iter_tree_entries_next(os.path.abspath(root), \'\', {}, on_error, follow_links)\nrepos\\python-pathspec\\pathspec\\util.py:173: in _iter_tree_entries_next\n    raise e\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot_full = \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp145w73ai\'\ndir_rel = \'\', memo = {}, on_error = None, follow_links = True\n\n    def _iter_tree_entries_next(root_full, dir_rel, memo=None, on_error=None, follow_links=False):\n        if memo is None:\n            memo = set()\n        try:\n            full_path = os.path.join(root_full, dir_rel)\n            if os.path.islink(full_path) and follow_links:\n                real_path = os.path.realpath(full_path)\n                if os.path.isdir(real_path):\n                    dir_rel = os.path.relpath(real_path, root_full)\n            if dir_rel not in memo:\n>               memo.add(dir_rel)\nE               AttributeError: \'dict\' object has no attribute \'add\'\n\nrepos\\python-pathspec\\pathspec\\util.py:164: AttributeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_files>\n\n    def test_05_match_tree_files(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n>   \tincludes = set(spec.match_tree_files(self.temp_dir))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:619: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:390: in match_tree_files\n    yield from self.match_files(files, negate=negate)\nrepos\\python-pathspec\\pathspec\\pathspec.py:312: in match_files\n    for orig_file in files:\nrepos\\python-pathspec\\pathspec\\util.py:197: in iter_tree_files\n    for entry in iter_tree_entries(root, on_error=on_error, follow_links=follow_links):\nrepos\\python-pathspec\\pathspec\\util.py:152: in iter_tree_entries\n    yield from _iter_tree_entries_next(os.path.abspath(root), \'\', {}, on_error, follow_links)\nrepos\\python-pathspec\\pathspec\\util.py:173: in _iter_tree_entries_next\n    raise e\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot_full = \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp5pe0uozx\'\ndir_rel = \'\', memo = {}, on_error = None, follow_links = True\n\n    def _iter_tree_entries_next(root_full, dir_rel, memo=None, on_error=None, follow_links=False):\n        if memo is None:\n            memo = set()\n        try:\n            full_path = os.path.join(root_full, dir_rel)\n            if os.path.islink(full_path) and follow_links:\n                real_path = os.path.realpath(full_path)\n                if os.path.isdir(real_path):\n                    dir_rel = os.path.relpath(real_path, root_full)\n            if dir_rel not in memo:\n>               memo.add(dir_rel)\nE               AttributeError: \'dict\' object has no attribute \'add\'\n\nrepos\\python-pathspec\\pathspec\\util.py:164: AttributeError']"
python-pathspec,_iter_tree_entries_next,"def _iter_tree_entries_next(root_full: str, dir_rel: str, memo: Dict[str, str], on_error: Callable[[OSError], None], follow_links: bool) -> Iterator['TreeEntry']:
    """"""
	Scan the directory for all descendant files.

	*root_full* (:class:`str`) the absolute path to the root directory.

	*dir_rel* (:class:`str`) the path to the directory to scan relative to
	*root_full*.

	*memo* (:class:`dict`) keeps track of ancestor directories
	encountered. Maps each ancestor real path (:class:`str`) to relative
	path (:class:`str`).

	*on_error* (:class:`~collections.abc.Callable` or :data:`None`)
	optionally is the error handler for file-system exceptions.

	*follow_links* (:class:`bool`) is whether to walk symbolic links that
	resolve to directories.

	Yields each entry (:class:`.TreeEntry`).
	""""""
    dir_full = os.path.join(root_full, dir_rel)
    dir_real = os.path.realpath(dir_full)
    if dir_real not in memo:
        memo[dir_real] = dir_rel
    else:
        raise RecursionError(real_path=dir_real, first_path=memo[dir_real], second_path=dir_rel)
    with os.scandir(dir_full) as scan_iter:
        node_ent: os.DirEntry
        for node_ent in scan_iter:
            node_rel = os.path.join(dir_rel, node_ent.name)
            try:
                node_lstat = node_ent.stat(follow_symlinks=False)
            except OSError as e:
                if on_error is not None:
                    on_error(e)
                continue
            if node_ent.is_symlink():
                try:
                    node_stat = node_ent.stat()
                except OSError as e:
                    if on_error is not None:
                        on_error(e)
                    continue
            else:
                node_stat = node_lstat
            if node_ent.is_dir(follow_symlinks=follow_links):
                yield TreeEntry(node_ent.name, node_rel, node_lstat, node_stat)
                yield from _iter_tree_entries_next(root_full, node_rel, memo, on_error, follow_links)
            elif node_ent.is_file() or node_ent.is_symlink():
                yield TreeEntry(node_ent.name, node_rel, node_lstat, node_stat)
    del memo[dir_real]","The goal of the function is to recursively scan a directory and its descendant files, yielding each entry as a TreeEntry object. It keeps track of encountered ancestor directories to prevent infinite recursion and handles errors using an optional error handler. The function also supports following symbolic links that resolve to directories. It iterates through the directory entries, checking for directories, files, and symbolic links, and yields the corresponding TreeEntry objects for each entry found.",2,"def _iter_tree_entries_next(root_full, dir_rel, memo, on_error=None, follow_links=False):
    if root_full in memo:
        return
    
    memo.add(root_full)
    
    try:
        entries = os.scandir(root_full)
    except OSError as e:
        if on_error:
            on_error(e)
        return
    
    for entry in entries:
        if entry.is_dir():
            yield TreeEntry(entry.path, 'directory')
            if follow_links and entry.is_symlink() and os.path.isdir(entry.path):
                yield from _iter_tree_entries_next(entry.path, os.path.join(dir_rel, entry.name), memo, on_error, follow_links)
        elif entry.is_file():
            yield TreeEntry(entry.path, 'file')
        elif entry.is_symlink():
            yield TreeEntry(entry.path, 'symbolic_link')
            if follow_links and os.path.isdir(entry.path):
                yield from _iter_tree_entries_next(entry.path, os.path.join(dir_rel, entry.name), memo, on_error, follow_links)",['./repos/python-pathspec\\tests'],"107 Passed, 5 Failed",107,5,"['tests/test_01_util.py::IterTreeTest::test_01_files', 'tests/test_01_util.py::IterTreeTest::test_03_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_files']","['self = <tests.test_01_util.IterTreeTest testMethod=test_01_files>\n\n    def test_01_files(self):\n    \t""""""\n    \tTests to make sure all files are found.\n    \t""""""\n    \tself.make_dirs([\n    \t\t\'Empty\',\n    \t\t\'Dir\',\n    \t\t\'Dir/Inner\',\n    \t])\n    \tself.make_files([\n    \t\t\'a\',\n    \t\t\'b\',\n    \t\t\'Dir/c\',\n    \t\t\'Dir/d\',\n    \t\t\'Dir/Inner/e\',\n    \t\t\'Dir/Inner/f\',\n    \t])\n>   \tresults = set(iter_tree_files(self.temp_dir))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:172: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\util.py:198: in iter_tree_files\n    for entry in iter_tree_entries(root, on_error=on_error, follow_links=follow_links):\nrepos\\python-pathspec\\pathspec\\util.py:152: in iter_tree_entries\n    yield from _iter_tree_entries_next(os.path.abspath(root), \'\', {}, on_error, follow_links)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot_full = \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp6txieim7\'\ndir_rel = \'\', memo = {}, on_error = None, follow_links = True\n\n    def _iter_tree_entries_next(root_full, dir_rel, memo, on_error=None, follow_links=False):\n        if root_full in memo:\n            return\n>       memo.add(root_full)\nE       AttributeError: \'dict\' object has no attribute \'add\'\n\nrepos\\python-pathspec\\pathspec\\util.py:157: AttributeError', 'self = <tests.test_01_util.IterTreeTest testMethod=test_03_entries>\n\n    def test_03_entries(self):\n    \t""""""\n    \tTests to make sure all files are found.\n    \t""""""\n    \tself.make_dirs([\n    \t\t\'Empty\',\n    \t\t\'Dir\',\n    \t\t\'Dir/Inner\',\n    \t])\n    \tself.make_files([\n    \t\t\'a\',\n    \t\t\'b\',\n    \t\t\'Dir/c\',\n    \t\t\'Dir/d\',\n    \t\t\'Dir/Inner/e\',\n    \t\t\'Dir/Inner/f\',\n    \t])\n>   \tresults = {entry.path for entry in iter_tree_entries(self.temp_dir)}\n\nrepos\\python-pathspec\\tests\\test_01_util.py:405: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\util.py:152: in iter_tree_entries\n    yield from _iter_tree_entries_next(os.path.abspath(root), \'\', {}, on_error, follow_links)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot_full = \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp2p_4g7ur\'\ndir_rel = \'\', memo = {}, on_error = None, follow_links = True\n\n    def _iter_tree_entries_next(root_full, dir_rel, memo, on_error=None, follow_links=False):\n        if root_full in memo:\n            return\n>       memo.add(root_full)\nE       AttributeError: \'dict\' object has no attribute \'add\'\n\nrepos\\python-pathspec\\pathspec\\util.py:157: AttributeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_entries>\n\n    def test_05_match_entries(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tentries = iter_tree_entries(self.temp_dir)\n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_entries(entries)\n    \t}\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:500: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:244: in match_entries\n    for entry in entries:\nrepos\\python-pathspec\\pathspec\\util.py:152: in iter_tree_entries\n    yield from _iter_tree_entries_next(os.path.abspath(root), \'\', {}, on_error, follow_links)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot_full = \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp1b3zkxxz\'\ndir_rel = \'\', memo = {}, on_error = None, follow_links = True\n\n    def _iter_tree_entries_next(root_full, dir_rel, memo, on_error=None, follow_links=False):\n        if root_full in memo:\n            return\n>       memo.add(root_full)\nE       AttributeError: \'dict\' object has no attribute \'add\'\n\nrepos\\python-pathspec\\pathspec\\util.py:157: AttributeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_entries>\n\n    def test_05_match_tree_entries(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_tree_entries(self.temp_dir)\n    \t}\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:586: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:355: in match_tree_entries\n    yield from self.match_entries(entries, negate=negate)\nrepos\\python-pathspec\\pathspec\\pathspec.py:244: in match_entries\n    for entry in entries:\nrepos\\python-pathspec\\pathspec\\util.py:152: in iter_tree_entries\n    yield from _iter_tree_entries_next(os.path.abspath(root), \'\', {}, on_error, follow_links)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot_full = \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmpjc9onyf6\'\ndir_rel = \'\', memo = {}, on_error = None, follow_links = True\n\n    def _iter_tree_entries_next(root_full, dir_rel, memo, on_error=None, follow_links=False):\n        if root_full in memo:\n            return\n>       memo.add(root_full)\nE       AttributeError: \'dict\' object has no attribute \'add\'\n\nrepos\\python-pathspec\\pathspec\\util.py:157: AttributeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_files>\n\n    def test_05_match_tree_files(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n>   \tincludes = set(spec.match_tree_files(self.temp_dir))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:619: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:390: in match_tree_files\n    yield from self.match_files(files, negate=negate)\nrepos\\python-pathspec\\pathspec\\pathspec.py:312: in match_files\n    for orig_file in files:\nrepos\\python-pathspec\\pathspec\\util.py:198: in iter_tree_files\n    for entry in iter_tree_entries(root, on_error=on_error, follow_links=follow_links):\nrepos\\python-pathspec\\pathspec\\util.py:152: in iter_tree_entries\n    yield from _iter_tree_entries_next(os.path.abspath(root), \'\', {}, on_error, follow_links)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot_full = \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmpllip3zgi\'\ndir_rel = \'\', memo = {}, on_error = None, follow_links = True\n\n    def _iter_tree_entries_next(root_full, dir_rel, memo, on_error=None, follow_links=False):\n        if root_full in memo:\n            return\n>       memo.add(root_full)\nE       AttributeError: \'dict\' object has no attribute \'add\'\n\nrepos\\python-pathspec\\pathspec\\util.py:157: AttributeError']"
python-pathspec,_iter_tree_entries_next,"def _iter_tree_entries_next(root_full: str, dir_rel: str, memo: Dict[str, str], on_error: Callable[[OSError], None], follow_links: bool) -> Iterator['TreeEntry']:
    """"""
	Scan the directory for all descendant files.

	*root_full* (:class:`str`) the absolute path to the root directory.

	*dir_rel* (:class:`str`) the path to the directory to scan relative to
	*root_full*.

	*memo* (:class:`dict`) keeps track of ancestor directories
	encountered. Maps each ancestor real path (:class:`str`) to relative
	path (:class:`str`).

	*on_error* (:class:`~collections.abc.Callable` or :data:`None`)
	optionally is the error handler for file-system exceptions.

	*follow_links* (:class:`bool`) is whether to walk symbolic links that
	resolve to directories.

	Yields each entry (:class:`.TreeEntry`).
	""""""
    dir_full = os.path.join(root_full, dir_rel)
    dir_real = os.path.realpath(dir_full)
    if dir_real not in memo:
        memo[dir_real] = dir_rel
    else:
        raise RecursionError(real_path=dir_real, first_path=memo[dir_real], second_path=dir_rel)
    with os.scandir(dir_full) as scan_iter:
        node_ent: os.DirEntry
        for node_ent in scan_iter:
            node_rel = os.path.join(dir_rel, node_ent.name)
            try:
                node_lstat = node_ent.stat(follow_symlinks=False)
            except OSError as e:
                if on_error is not None:
                    on_error(e)
                continue
            if node_ent.is_symlink():
                try:
                    node_stat = node_ent.stat()
                except OSError as e:
                    if on_error is not None:
                        on_error(e)
                    continue
            else:
                node_stat = node_lstat
            if node_ent.is_dir(follow_symlinks=follow_links):
                yield TreeEntry(node_ent.name, node_rel, node_lstat, node_stat)
                yield from _iter_tree_entries_next(root_full, node_rel, memo, on_error, follow_links)
            elif node_ent.is_file() or node_ent.is_symlink():
                yield TreeEntry(node_ent.name, node_rel, node_lstat, node_stat)
    del memo[dir_real]","The goal of the function is to recursively scan a directory and its descendant files, yielding each entry as a TreeEntry object. It keeps track of encountered ancestor directories to prevent infinite recursion and handles errors using an optional error handler. The function also supports following symbolic links that resolve to directories. It iterates through the directory entries, checking for directories, files, and symbolic links, and yields the corresponding TreeEntry objects for each entry found.",3,"def _iter_tree_entries_next(root_full, dir_rel, memo, on_error=None, follow_links=False):
    if not memo:
        memo = set()
        
    try:
        full_path = os.path.join(root_full, dir_rel)
        st = os.lstat(full_path)
    except OSError as err:
        if on_error:
            on_error(err)
        return
    
    if stat.S_ISLNK(st.st_mode) and follow_links:
        try:
            path = os.path.realpath(full_path)
        except OSError as err:
            if on_error:
                on_error(err)
            return
        dir_rel = os.path.relpath(path, start=root_full)
    
    if stat.S_ISDIR(st.st_mode) and full_path not in memo:
        memo.add(full_path)
        yield TreeEntry(full_path)
        for entry in os.listdir(full_path):
            yield from _iter_tree_entries_next(root_full, os.path.join(dir_rel, entry), memo, on_error, follow_links)
    elif stat.S_ISREG(st.st_mode):
        yield TreeEntry(full_path)
    elif stat.S_ISLNK(st.st_mode):
        yield TreeEntry(full_path)",['./repos/python-pathspec\\tests'],"107 Passed, 5 Failed",107,5,"['tests/test_01_util.py::IterTreeTest::test_01_files', 'tests/test_01_util.py::IterTreeTest::test_03_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_files']","['self = <tests.test_01_util.IterTreeTest testMethod=test_01_files>\n\n    def test_01_files(self):\n    \t""""""\n    \tTests to make sure all files are found.\n    \t""""""\n    \tself.make_dirs([\n    \t\t\'Empty\',\n    \t\t\'Dir\',\n    \t\t\'Dir/Inner\',\n    \t])\n    \tself.make_files([\n    \t\t\'a\',\n    \t\t\'b\',\n    \t\t\'Dir/c\',\n    \t\t\'Dir/d\',\n    \t\t\'Dir/Inner/e\',\n    \t\t\'Dir/Inner/f\',\n    \t])\n>   \tresults = set(iter_tree_files(self.temp_dir))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:172: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\util.py:204: in iter_tree_files\n    for entry in iter_tree_entries(root, on_error=on_error, follow_links=follow_links):\nrepos\\python-pathspec\\pathspec\\util.py:152: in iter_tree_entries\n    yield from _iter_tree_entries_next(os.path.abspath(root), \'\', {}, on_error, follow_links)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot_full = \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmpjzu465n1\'\ndir_rel = \'\'\nmemo = {\'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmpjzu465n1\\\\\'}\non_error = None, follow_links = True\n\n    def _iter_tree_entries_next(root_full, dir_rel, memo, on_error=None, follow_links=False):\n        if not memo:\n            memo = set()\n        try:\n            full_path = os.path.join(root_full, dir_rel)\n            st = os.lstat(full_path)\n        except OSError as err:\n            if on_error:\n                on_error(err)\n            return\n        if stat.S_ISLNK(st.st_mode) and follow_links:\n            try:\n                path = os.path.realpath(full_path)\n            except OSError as err:\n                if on_error:\n                    on_error(err)\n                return\n            dir_rel = os.path.relpath(path, start=root_full)\n        if stat.S_ISDIR(st.st_mode) and full_path not in memo:\n            memo.add(full_path)\n>           yield TreeEntry(full_path)\nE           TypeError: TreeEntry.__init__() missing 3 required positional arguments: \'path\', \'lstat\', and \'stat\'\n\nrepos\\python-pathspec\\pathspec\\util.py:174: TypeError', 'self = <tests.test_01_util.IterTreeTest testMethod=test_03_entries>\n\n    def test_03_entries(self):\n    \t""""""\n    \tTests to make sure all files are found.\n    \t""""""\n    \tself.make_dirs([\n    \t\t\'Empty\',\n    \t\t\'Dir\',\n    \t\t\'Dir/Inner\',\n    \t])\n    \tself.make_files([\n    \t\t\'a\',\n    \t\t\'b\',\n    \t\t\'Dir/c\',\n    \t\t\'Dir/d\',\n    \t\t\'Dir/Inner/e\',\n    \t\t\'Dir/Inner/f\',\n    \t])\n>   \tresults = {entry.path for entry in iter_tree_entries(self.temp_dir)}\n\nrepos\\python-pathspec\\tests\\test_01_util.py:405: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\util.py:152: in iter_tree_entries\n    yield from _iter_tree_entries_next(os.path.abspath(root), \'\', {}, on_error, follow_links)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot_full = \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmplfmaobq3\'\ndir_rel = \'\'\nmemo = {\'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmplfmaobq3\\\\\'}\non_error = None, follow_links = True\n\n    def _iter_tree_entries_next(root_full, dir_rel, memo, on_error=None, follow_links=False):\n        if not memo:\n            memo = set()\n        try:\n            full_path = os.path.join(root_full, dir_rel)\n            st = os.lstat(full_path)\n        except OSError as err:\n            if on_error:\n                on_error(err)\n            return\n        if stat.S_ISLNK(st.st_mode) and follow_links:\n            try:\n                path = os.path.realpath(full_path)\n            except OSError as err:\n                if on_error:\n                    on_error(err)\n                return\n            dir_rel = os.path.relpath(path, start=root_full)\n        if stat.S_ISDIR(st.st_mode) and full_path not in memo:\n            memo.add(full_path)\n>           yield TreeEntry(full_path)\nE           TypeError: TreeEntry.__init__() missing 3 required positional arguments: \'path\', \'lstat\', and \'stat\'\n\nrepos\\python-pathspec\\pathspec\\util.py:174: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_entries>\n\n    def test_05_match_entries(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tentries = iter_tree_entries(self.temp_dir)\n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_entries(entries)\n    \t}\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:500: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:244: in match_entries\n    for entry in entries:\nrepos\\python-pathspec\\pathspec\\util.py:152: in iter_tree_entries\n    yield from _iter_tree_entries_next(os.path.abspath(root), \'\', {}, on_error, follow_links)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot_full = \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmpjumgp9sr\'\ndir_rel = \'\'\nmemo = {\'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmpjumgp9sr\\\\\'}\non_error = None, follow_links = True\n\n    def _iter_tree_entries_next(root_full, dir_rel, memo, on_error=None, follow_links=False):\n        if not memo:\n            memo = set()\n        try:\n            full_path = os.path.join(root_full, dir_rel)\n            st = os.lstat(full_path)\n        except OSError as err:\n            if on_error:\n                on_error(err)\n            return\n        if stat.S_ISLNK(st.st_mode) and follow_links:\n            try:\n                path = os.path.realpath(full_path)\n            except OSError as err:\n                if on_error:\n                    on_error(err)\n                return\n            dir_rel = os.path.relpath(path, start=root_full)\n        if stat.S_ISDIR(st.st_mode) and full_path not in memo:\n            memo.add(full_path)\n>           yield TreeEntry(full_path)\nE           TypeError: TreeEntry.__init__() missing 3 required positional arguments: \'path\', \'lstat\', and \'stat\'\n\nrepos\\python-pathspec\\pathspec\\util.py:174: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_entries>\n\n    def test_05_match_tree_entries(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_tree_entries(self.temp_dir)\n    \t}\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:586: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:355: in match_tree_entries\n    yield from self.match_entries(entries, negate=negate)\nrepos\\python-pathspec\\pathspec\\pathspec.py:244: in match_entries\n    for entry in entries:\nrepos\\python-pathspec\\pathspec\\util.py:152: in iter_tree_entries\n    yield from _iter_tree_entries_next(os.path.abspath(root), \'\', {}, on_error, follow_links)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot_full = \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmpmakrrie7\'\ndir_rel = \'\'\nmemo = {\'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmpmakrrie7\\\\\'}\non_error = None, follow_links = True\n\n    def _iter_tree_entries_next(root_full, dir_rel, memo, on_error=None, follow_links=False):\n        if not memo:\n            memo = set()\n        try:\n            full_path = os.path.join(root_full, dir_rel)\n            st = os.lstat(full_path)\n        except OSError as err:\n            if on_error:\n                on_error(err)\n            return\n        if stat.S_ISLNK(st.st_mode) and follow_links:\n            try:\n                path = os.path.realpath(full_path)\n            except OSError as err:\n                if on_error:\n                    on_error(err)\n                return\n            dir_rel = os.path.relpath(path, start=root_full)\n        if stat.S_ISDIR(st.st_mode) and full_path not in memo:\n            memo.add(full_path)\n>           yield TreeEntry(full_path)\nE           TypeError: TreeEntry.__init__() missing 3 required positional arguments: \'path\', \'lstat\', and \'stat\'\n\nrepos\\python-pathspec\\pathspec\\util.py:174: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_files>\n\n    def test_05_match_tree_files(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n>   \tincludes = set(spec.match_tree_files(self.temp_dir))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:619: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:390: in match_tree_files\n    yield from self.match_files(files, negate=negate)\nrepos\\python-pathspec\\pathspec\\pathspec.py:312: in match_files\n    for orig_file in files:\nrepos\\python-pathspec\\pathspec\\util.py:204: in iter_tree_files\n    for entry in iter_tree_entries(root, on_error=on_error, follow_links=follow_links):\nrepos\\python-pathspec\\pathspec\\util.py:152: in iter_tree_entries\n    yield from _iter_tree_entries_next(os.path.abspath(root), \'\', {}, on_error, follow_links)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nroot_full = \'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp_rrr452j\'\ndir_rel = \'\'\nmemo = {\'C:\\\\Users\\\\SERINE~1.SEF\\\\AppData\\\\Local\\\\Temp\\\\tmp_rrr452j\\\\\'}\non_error = None, follow_links = True\n\n    def _iter_tree_entries_next(root_full, dir_rel, memo, on_error=None, follow_links=False):\n        if not memo:\n            memo = set()\n        try:\n            full_path = os.path.join(root_full, dir_rel)\n            st = os.lstat(full_path)\n        except OSError as err:\n            if on_error:\n                on_error(err)\n            return\n        if stat.S_ISLNK(st.st_mode) and follow_links:\n            try:\n                path = os.path.realpath(full_path)\n            except OSError as err:\n                if on_error:\n                    on_error(err)\n                return\n            dir_rel = os.path.relpath(path, start=root_full)\n        if stat.S_ISDIR(st.st_mode) and full_path not in memo:\n            memo.add(full_path)\n>           yield TreeEntry(full_path)\nE           TypeError: TreeEntry.__init__() missing 3 required positional arguments: \'path\', \'lstat\', and \'stat\'\n\nrepos\\python-pathspec\\pathspec\\util.py:174: TypeError']"
python-pathspec,match_file,"def match_file(patterns: Iterable[Pattern], file: str) -> bool:
    """"""
	Matches the file to the patterns.

	*patterns* (:class:`~collections.abc.Iterable` of :class:`~pathspec.pattern.Pattern`)
	contains the patterns to use.

	*file* (:class:`str`) is the normalized file path to be matched
	against *patterns*.

	Returns :data:`True` if *file* matched; otherwise, :data:`False`.
	""""""
    matched = False
    for pattern in patterns:
        if pattern.include is not None and pattern.match_file(file) is not None:
            matched = pattern.include
    return matched","The function `match_file` takes a set of patterns and a specific file path as input, and checks if the file matches any of the patterns. It iterates through each pattern and if the file matches the inclusion criteria of a pattern, it returns `True`; otherwise, it returns `False`. This function is useful for checking if a file complies with specific criteria specified by a set of patterns.",1,"def match_file(patterns, file):
    for pattern in patterns:
        if pattern in file:
            return True
    return False",['./repos/python-pathspec\\tests'],"108 Passed, 4 Failed",108,4,"['tests/test_01_util.py::MatchFileTest::test_01_single_1_include', 'tests/test_01_util.py::MatchFileTest::test_01_single_2_exclude', 'tests/test_01_util.py::MatchFileTest::test_01_single_3_unmatch', 'tests/test_01_util.py::MatchFileTest::test_02_many']","['self = <tests.test_01_util.MatchFileTest testMethod=test_01_single_1_include>\n\n    def test_01_single_1_include(self):\n    \t""""""\n    \tTest checking a single file that is included.\n    \t""""""\n    \tpatterns = list(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t]))\n    \n>   \tinclude = match_file(patterns, ""include.txt"")\n\nrepos\\python-pathspec\\tests\\test_01_util.py:434: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [<pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000205CA621C40>, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000205CA621CC0>]\nfile = \'include.txt\'\n\n    def match_file(patterns, file):\n        for pattern in patterns:\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not GitWildMatchPattern\n\nrepos\\python-pathspec\\pathspec\\util.py:254: TypeError', 'self = <tests.test_01_util.MatchFileTest testMethod=test_01_single_2_exclude>\n\n    def test_01_single_2_exclude(self):\n    \t""""""\n    \tTest checking a single file that is excluded.\n    \t""""""\n    \tpatterns = list(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t]))\n    \n>   \tinclude = match_file(patterns, ""test/exclude.txt"")\n\nrepos\\python-pathspec\\tests\\test_01_util.py:447: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [<pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000205CA5FB3C0>, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000205CA5FB540>]\nfile = \'test/exclude.txt\'\n\n    def match_file(patterns, file):\n        for pattern in patterns:\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not GitWildMatchPattern\n\nrepos\\python-pathspec\\pathspec\\util.py:254: TypeError', 'self = <tests.test_01_util.MatchFileTest testMethod=test_01_single_3_unmatch>\n\n    def test_01_single_3_unmatch(self):\n    \t""""""\n    \tTest checking a single file that is ignored.\n    \t""""""\n    \tpatterns = list(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t]))\n    \n>   \tinclude = match_file(patterns, ""unmatch.bin"")\n\nrepos\\python-pathspec\\tests\\test_01_util.py:460: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [<pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000205CA5DD880>, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000205CA5DE740>]\nfile = \'unmatch.bin\'\n\n    def match_file(patterns, file):\n        for pattern in patterns:\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not GitWildMatchPattern\n\nrepos\\python-pathspec\\pathspec\\util.py:254: TypeError', 'self = <tests.test_01_util.MatchFileTest testMethod=test_02_many>\n\n    def test_02_many(self):\n    \t""""""\n    \tTest matching files individually.\n    \t""""""\n    \tpatterns = list(map(GitWildMatchPattern, [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t]))\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tincludes = set(filter(partial(match_file, patterns), files))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:481: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [<pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000205CA44BAC0>, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x00000205CA44B980>]\nfile = \'X/a.txt\'\n\n    def match_file(patterns, file):\n        for pattern in patterns:\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not GitWildMatchPattern\n\nrepos\\python-pathspec\\pathspec\\util.py:254: TypeError']"
python-pathspec,match_file,"def match_file(patterns: Iterable[Pattern], file: str) -> bool:
    """"""
	Matches the file to the patterns.

	*patterns* (:class:`~collections.abc.Iterable` of :class:`~pathspec.pattern.Pattern`)
	contains the patterns to use.

	*file* (:class:`str`) is the normalized file path to be matched
	against *patterns*.

	Returns :data:`True` if *file* matched; otherwise, :data:`False`.
	""""""
    matched = False
    for pattern in patterns:
        if pattern.include is not None and pattern.match_file(file) is not None:
            matched = pattern.include
    return matched","The function `match_file` takes a set of patterns and a specific file path as input, and checks if the file matches any of the patterns. It iterates through each pattern and if the file matches the inclusion criteria of a pattern, it returns `True`; otherwise, it returns `False`. This function is useful for checking if a file complies with specific criteria specified by a set of patterns.",2,"def match_file(patterns, file):
    for pattern in patterns:
        if pattern in file:
            return True
    return False",['./repos/python-pathspec\\tests'],"108 Passed, 4 Failed",108,4,"['tests/test_01_util.py::MatchFileTest::test_01_single_1_include', 'tests/test_01_util.py::MatchFileTest::test_01_single_2_exclude', 'tests/test_01_util.py::MatchFileTest::test_01_single_3_unmatch', 'tests/test_01_util.py::MatchFileTest::test_02_many']","['self = <tests.test_01_util.MatchFileTest testMethod=test_01_single_1_include>\n\n    def test_01_single_1_include(self):\n    \t""""""\n    \tTest checking a single file that is included.\n    \t""""""\n    \tpatterns = list(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t]))\n    \n>   \tinclude = match_file(patterns, ""include.txt"")\n\nrepos\\python-pathspec\\tests\\test_01_util.py:434: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [<pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000022DD9F31CC0>, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000022DD9F31D40>]\nfile = \'include.txt\'\n\n    def match_file(patterns, file):\n        for pattern in patterns:\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not GitWildMatchPattern\n\nrepos\\python-pathspec\\pathspec\\util.py:254: TypeError', 'self = <tests.test_01_util.MatchFileTest testMethod=test_01_single_2_exclude>\n\n    def test_01_single_2_exclude(self):\n    \t""""""\n    \tTest checking a single file that is excluded.\n    \t""""""\n    \tpatterns = list(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t]))\n    \n>   \tinclude = match_file(patterns, ""test/exclude.txt"")\n\nrepos\\python-pathspec\\tests\\test_01_util.py:447: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [<pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000022DD9F0B0C0>, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000022DD9F0BEC0>]\nfile = \'test/exclude.txt\'\n\n    def match_file(patterns, file):\n        for pattern in patterns:\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not GitWildMatchPattern\n\nrepos\\python-pathspec\\pathspec\\util.py:254: TypeError', 'self = <tests.test_01_util.MatchFileTest testMethod=test_01_single_3_unmatch>\n\n    def test_01_single_3_unmatch(self):\n    \t""""""\n    \tTest checking a single file that is ignored.\n    \t""""""\n    \tpatterns = list(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t]))\n    \n>   \tinclude = match_file(patterns, ""unmatch.bin"")\n\nrepos\\python-pathspec\\tests\\test_01_util.py:460: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [<pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000022DD9F16D80>, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000022DD9F14800>]\nfile = \'unmatch.bin\'\n\n    def match_file(patterns, file):\n        for pattern in patterns:\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not GitWildMatchPattern\n\nrepos\\python-pathspec\\pathspec\\util.py:254: TypeError', 'self = <tests.test_01_util.MatchFileTest testMethod=test_02_many>\n\n    def test_02_many(self):\n    \t""""""\n    \tTest matching files individually.\n    \t""""""\n    \tpatterns = list(map(GitWildMatchPattern, [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t]))\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tincludes = set(filter(partial(match_file, patterns), files))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:481: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [<pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000022DD9D583C0>, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000022DD9D5BC00>]\nfile = \'X/Z/c.txt\'\n\n    def match_file(patterns, file):\n        for pattern in patterns:\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not GitWildMatchPattern\n\nrepos\\python-pathspec\\pathspec\\util.py:254: TypeError']"
python-pathspec,match_file,"def match_file(patterns: Iterable[Pattern], file: str) -> bool:
    """"""
	Matches the file to the patterns.

	*patterns* (:class:`~collections.abc.Iterable` of :class:`~pathspec.pattern.Pattern`)
	contains the patterns to use.

	*file* (:class:`str`) is the normalized file path to be matched
	against *patterns*.

	Returns :data:`True` if *file* matched; otherwise, :data:`False`.
	""""""
    matched = False
    for pattern in patterns:
        if pattern.include is not None and pattern.match_file(file) is not None:
            matched = pattern.include
    return matched","The function `match_file` takes a set of patterns and a specific file path as input, and checks if the file matches any of the patterns. It iterates through each pattern and if the file matches the inclusion criteria of a pattern, it returns `True`; otherwise, it returns `False`. This function is useful for checking if a file complies with specific criteria specified by a set of patterns.",3,"def match_file(patterns, file):
    for pattern in patterns:
        if pattern in file:
            return True
    return False",['./repos/python-pathspec\\tests'],"108 Passed, 4 Failed",108,4,"['tests/test_01_util.py::MatchFileTest::test_01_single_1_include', 'tests/test_01_util.py::MatchFileTest::test_01_single_2_exclude', 'tests/test_01_util.py::MatchFileTest::test_01_single_3_unmatch', 'tests/test_01_util.py::MatchFileTest::test_02_many']","['self = <tests.test_01_util.MatchFileTest testMethod=test_01_single_1_include>\n\n    def test_01_single_1_include(self):\n    \t""""""\n    \tTest checking a single file that is included.\n    \t""""""\n    \tpatterns = list(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t]))\n    \n>   \tinclude = match_file(patterns, ""include.txt"")\n\nrepos\\python-pathspec\\tests\\test_01_util.py:434: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [<pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000002516D931B80>, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000002516D931C00>]\nfile = \'include.txt\'\n\n    def match_file(patterns, file):\n        for pattern in patterns:\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not GitWildMatchPattern\n\nrepos\\python-pathspec\\pathspec\\util.py:254: TypeError', 'self = <tests.test_01_util.MatchFileTest testMethod=test_01_single_2_exclude>\n\n    def test_01_single_2_exclude(self):\n    \t""""""\n    \tTest checking a single file that is excluded.\n    \t""""""\n    \tpatterns = list(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t]))\n    \n>   \tinclude = match_file(patterns, ""test/exclude.txt"")\n\nrepos\\python-pathspec\\tests\\test_01_util.py:447: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [<pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000002516D8EE8C0>, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000002516D8ED880>]\nfile = \'test/exclude.txt\'\n\n    def match_file(patterns, file):\n        for pattern in patterns:\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not GitWildMatchPattern\n\nrepos\\python-pathspec\\pathspec\\util.py:254: TypeError', 'self = <tests.test_01_util.MatchFileTest testMethod=test_01_single_3_unmatch>\n\n    def test_01_single_3_unmatch(self):\n    \t""""""\n    \tTest checking a single file that is ignored.\n    \t""""""\n    \tpatterns = list(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t]))\n    \n>   \tinclude = match_file(patterns, ""unmatch.bin"")\n\nrepos\\python-pathspec\\tests\\test_01_util.py:460: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [<pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000002516D933A80>, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000002516D9313C0>]\nfile = \'unmatch.bin\'\n\n    def match_file(patterns, file):\n        for pattern in patterns:\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not GitWildMatchPattern\n\nrepos\\python-pathspec\\pathspec\\util.py:254: TypeError', 'self = <tests.test_01_util.MatchFileTest testMethod=test_02_many>\n\n    def test_02_many(self):\n    \t""""""\n    \tTest matching files individually.\n    \t""""""\n    \tpatterns = list(map(GitWildMatchPattern, [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t]))\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tincludes = set(filter(partial(match_file, patterns), files))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:481: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npatterns = [<pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000002516D755680>, <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000002516D755A80>]\nfile = \'Y/a.txt\'\n\n    def match_file(patterns, file):\n        for pattern in patterns:\n>           if pattern in file:\nE           TypeError: \'in <string>\' requires string as left operand, not GitWildMatchPattern\n\nrepos\\python-pathspec\\pathspec\\util.py:254: TypeError']"
python-pathspec,match_files,"def match_files(patterns: Iterable[Pattern], files: Iterable[str]) -> Set[str]:
    """"""
	DEPRECATED: This is an old function no longer used. Use the
	:func:`~pathspec.util.match_file` function with a loop for better results.

	Matches the files to the patterns.

	*patterns* (:class:`~collections.abc.Iterable` of :class:`~pathspec.pattern.Pattern`)
	contains the patterns to use.

	*files* (:class:`~collections.abc.Iterable` of :class:`str`) contains
	the normalized file paths to be matched against *patterns*.

	Returns the matched files (:class:`set` of :class:`str`).
	""""""
    warnings.warn(f'{__name__}.match_files() is deprecated. Use {__name__}.match_file() with a loop for better results.', DeprecationWarning, stacklevel=2)
    use_patterns = [__pat for __pat in patterns if __pat.include is not None]
    return_files = set()
    for file in files:
        if match_file(use_patterns, file):
            return_files.add(file)
    return return_files","The goal of the function is to match a set of files against a set of patterns. It takes in a collection of patterns and a collection of file paths, then returns a set of files that match the given patterns. This function is deprecated and recommends using the `match_file` function with a loop for better results. It filters out the patterns that have an 'include' property and checks each file against these filtered patterns to determine if it matches. The matched file paths are then added to a set and returned.",1,"def match_files(patterns, files):
    matched_files = set()
    
    for pattern in patterns:
        if pattern.get('include', False):
            for file in files:
                if pattern['pattern'] in file:
                    matched_files.add(file)
    
    return matched_files",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,match_files,"def match_files(patterns: Iterable[Pattern], files: Iterable[str]) -> Set[str]:
    """"""
	DEPRECATED: This is an old function no longer used. Use the
	:func:`~pathspec.util.match_file` function with a loop for better results.

	Matches the files to the patterns.

	*patterns* (:class:`~collections.abc.Iterable` of :class:`~pathspec.pattern.Pattern`)
	contains the patterns to use.

	*files* (:class:`~collections.abc.Iterable` of :class:`str`) contains
	the normalized file paths to be matched against *patterns*.

	Returns the matched files (:class:`set` of :class:`str`).
	""""""
    warnings.warn(f'{__name__}.match_files() is deprecated. Use {__name__}.match_file() with a loop for better results.', DeprecationWarning, stacklevel=2)
    use_patterns = [__pat for __pat in patterns if __pat.include is not None]
    return_files = set()
    for file in files:
        if match_file(use_patterns, file):
            return_files.add(file)
    return return_files","The goal of the function is to match a set of files against a set of patterns. It takes in a collection of patterns and a collection of file paths, then returns a set of files that match the given patterns. This function is deprecated and recommends using the `match_file` function with a loop for better results. It filters out the patterns that have an 'include' property and checks each file against these filtered patterns to determine if it matches. The matched file paths are then added to a set and returned.",2,"def match_files(patterns, files):
    filtered_patterns = [pattern for pattern in patterns if pattern.get('include')]
    matched_files = set()

    for file in files:
        for pattern in filtered_patterns:
            if pattern['pattern'] in file:
                matched_files.add(file)
                break

    return matched_files",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,match_files,"def match_files(patterns: Iterable[Pattern], files: Iterable[str]) -> Set[str]:
    """"""
	DEPRECATED: This is an old function no longer used. Use the
	:func:`~pathspec.util.match_file` function with a loop for better results.

	Matches the files to the patterns.

	*patterns* (:class:`~collections.abc.Iterable` of :class:`~pathspec.pattern.Pattern`)
	contains the patterns to use.

	*files* (:class:`~collections.abc.Iterable` of :class:`str`) contains
	the normalized file paths to be matched against *patterns*.

	Returns the matched files (:class:`set` of :class:`str`).
	""""""
    warnings.warn(f'{__name__}.match_files() is deprecated. Use {__name__}.match_file() with a loop for better results.', DeprecationWarning, stacklevel=2)
    use_patterns = [__pat for __pat in patterns if __pat.include is not None]
    return_files = set()
    for file in files:
        if match_file(use_patterns, file):
            return_files.add(file)
    return return_files","The goal of the function is to match a set of files against a set of patterns. It takes in a collection of patterns and a collection of file paths, then returns a set of files that match the given patterns. This function is deprecated and recommends using the `match_file` function with a loop for better results. It filters out the patterns that have an 'include' property and checks each file against these filtered patterns to determine if it matches. The matched file paths are then added to a set and returned.",3,"def match_files(patterns, files):
    matched_files = set()

    def match_file(pattern, file_path):
        if 'include' in pattern:
            if pattern['include']:
                if pattern['pattern'] in file_path:
                    return True
            else:
                if pattern['pattern'] not in file_path:
                    return True
        else:
            if pattern['pattern'] in file_path:
                return True

        return False

    for pattern in patterns:
        for file_path in files:
            if match_file(pattern, file_path):
                matched_files.add(file_path)

    return matched_files",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,normalize_file,"def normalize_file(file: StrPath, separators: Optional[Collection[str]]=None) -> str:
    """"""
	Normalizes the file path to use the POSIX path separator (i.e.,
	``""/""``), and make the paths relative (remove leading ``""/""``).

	*file* (:class:`str` or :class:`os.PathLike`) is the file path.

	*separators* (:class:`~collections.abc.Collection` of :class:`str`; or
	``None``) optionally contains the path separators to normalize.
	This does not need to include the POSIX path separator (``""/""``),
	but including it will not affect the results. Default is ``None``
	for ``NORMALIZE_PATH_SEPS``. To prevent normalization, pass an
	empty container (e.g., an empty tuple ``()``).

	Returns the normalized file path (:class:`str`).
	""""""
    if separators is None:
        separators = NORMALIZE_PATH_SEPS
    norm_file: str = os.fspath(file)
    for sep in separators:
        norm_file = norm_file.replace(sep, posixpath.sep)
    if norm_file.startswith('/'):
        norm_file = norm_file[1:]
    elif norm_file.startswith('./'):
        norm_file = norm_file[2:]
    return norm_file","The goal of the function `normalize_file` is to normalize a given file path by using the POSIX path separator (""/"") and making the path relative (removing any leading ""/""). The function allows for optional customization of the path separators to be normalized, but by default it uses the standard path separators. This function is useful for ensuring consistency in file path representations across different platforms or systems.",1,"def normalize_file(file, separators=None):
    if separators is None:
        separators = ""/""
    
    if file.startswith(""/""):
        file = file[1:]
    
    for separator in separators:
        file = file.replace(separator, ""/"")
    
    return file",['./repos/python-pathspec\\tests'],"108 Passed, 4 Failed",108,4,"['tests/test_01_util.py::NormalizeFileTest::test_01_purepath', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_files']","['self = <tests.test_01_util.NormalizeFileTest testMethod=test_01_purepath>\n\n    def test_01_purepath(self):\n    \t""""""\n    \tTests normalizing a :class:`pathlib.PurePath` as argument.\n    \t""""""\n>   \tfirst_spec = normalize_file(pathlib.PurePath(\'a.txt\'))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:501: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = PureWindowsPath(\'a.txt\'), separators = \'/\'\n\n    def normalize_file(file, separators=None):\n        if separators is None:\n            separators = \'/\'\n>       if file.startswith(\'/\'):\nE       AttributeError: \'PureWindowsPath\' object has no attribute \'startswith\'\n\nrepos\\python-pathspec\\pathspec\\util.py:296: AttributeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_entries>\n\n    def test_05_match_entries(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tentries = iter_tree_entries(self.temp_dir)\n    \tincludes = {\n    \t\t__entry.path for __entry in spec.match_entries(entries)\n    \t}\n    \n>   \tself.assertEqual(includes, set(map(ospath, [\n    \t\t\'X/a.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])))\nE    AssertionError: Items in the first set but not the second:\nE    \'X\\\\b.txt\'\nE    \'Y\\\\b.txt\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:503: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_entries>\n\n    def test_05_match_tree_entries(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tincludes = {\n    \t\t__entry.path for __entry in spec.match_tree_entries(self.temp_dir)\n    \t}\n    \n>   \tself.assertEqual(includes, set(map(ospath, [\n    \t\t\'X/a.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])))\nE    AssertionError: Items in the first set but not the second:\nE    \'X\\\\b.txt\'\nE    \'Y\\\\b.txt\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:589: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_files>\n\n    def test_05_match_tree_files(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tincludes = set(spec.match_tree_files(self.temp_dir))\n    \n>   \tself.assertEqual(includes, set(map(ospath, [\n    \t\t\'X/a.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])))\nE    AssertionError: Items in the first set but not the second:\nE    \'X\\\\b.txt\'\nE    \'Y\\\\b.txt\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:621: AssertionError']"
python-pathspec,normalize_file,"def normalize_file(file: StrPath, separators: Optional[Collection[str]]=None) -> str:
    """"""
	Normalizes the file path to use the POSIX path separator (i.e.,
	``""/""``), and make the paths relative (remove leading ``""/""``).

	*file* (:class:`str` or :class:`os.PathLike`) is the file path.

	*separators* (:class:`~collections.abc.Collection` of :class:`str`; or
	``None``) optionally contains the path separators to normalize.
	This does not need to include the POSIX path separator (``""/""``),
	but including it will not affect the results. Default is ``None``
	for ``NORMALIZE_PATH_SEPS``. To prevent normalization, pass an
	empty container (e.g., an empty tuple ``()``).

	Returns the normalized file path (:class:`str`).
	""""""
    if separators is None:
        separators = NORMALIZE_PATH_SEPS
    norm_file: str = os.fspath(file)
    for sep in separators:
        norm_file = norm_file.replace(sep, posixpath.sep)
    if norm_file.startswith('/'):
        norm_file = norm_file[1:]
    elif norm_file.startswith('./'):
        norm_file = norm_file[2:]
    return norm_file","The goal of the function `normalize_file` is to normalize a given file path by using the POSIX path separator (""/"") and making the path relative (removing any leading ""/""). The function allows for optional customization of the path separators to be normalized, but by default it uses the standard path separators. This function is useful for ensuring consistency in file path representations across different platforms or systems.",2,"def normalize_file(file, separators=None):
    if separators is None:
        separators = ""/""
    
    normalized_file = file.lstrip(""/"")
    normalized_file = normalized_file.replace(""\\"", separators)
    
    return normalized_file",['./repos/python-pathspec\\tests'],"109 Passed, 3 Failed",109,3,"['tests/test_01_util.py::NormalizeFileTest::test_01_purepath', 'tests/test_03_pathspec.py::PathSpecTest::test_01_windows_current_dir_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_01_windows_paths']","['self = <tests.test_01_util.NormalizeFileTest testMethod=test_01_purepath>\n\n    def test_01_purepath(self):\n    \t""""""\n    \tTests normalizing a :class:`pathlib.PurePath` as argument.\n    \t""""""\n>   \tfirst_spec = normalize_file(pathlib.PurePath(\'a.txt\'))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:501: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = PureWindowsPath(\'a.txt\'), separators = \'/\'\n\n    def normalize_file(file, separators=None):\n        if separators is None:\n            separators = \'/\'\n>       normalized_file = file.lstrip(\'/\')\nE       AttributeError: \'PureWindowsPath\' object has no attribute \'lstrip\'\n\nrepos\\python-pathspec\\pathspec\\util.py:296: AttributeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_windows_current_dir_paths>\n\n    def test_01_windows_current_dir_paths(self):\n    \t""""""\n    \tTests that paths referencing the current directory will be properly\n    \tnormalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'.\\\\test1\\\\a.txt\',\n    \t\t\'.\\\\test1\\\\b.txt\',\n    \t\t\'.\\\\test1\\\\c\\\\c.txt\',\n    \t\t\'.\\\\test2\\\\a.txt\',\n    \t\t\'.\\\\test2\\\\b.txt\',\n    \t\t\'.\\\\test2\\\\c\\\\c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files, separators=[\'\\\\\']))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:341: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'.\\\\test2\\\\b.txt\', separators = [\'\\\\\']\n\n    def normalize_file(file, separators=None):\n        if separators is None:\n            separators = \'/\'\n        normalized_file = file.lstrip(\'/\')\n>       normalized_file = normalized_file.replace(\'\\\\\', separators)\nE       TypeError: replace() argument 2 must be str, not list\n\nrepos\\python-pathspec\\pathspec\\util.py:297: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_windows_paths>\n\n    def test_01_windows_paths(self):\n    \t""""""\n    \tTests that Windows paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1\\\\a.txt\',\n    \t\t\'test1\\\\b.txt\',\n    \t\t\'test1\\\\c\\\\c.txt\',\n    \t\t\'test2\\\\a.txt\',\n    \t\t\'test2\\\\b.txt\',\n    \t\t\'test2\\\\c\\\\c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files, separators=[\'\\\\\']))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'test2\\\\c\\\\c.txt\', separators = [\'\\\\\']\n\n    def normalize_file(file, separators=None):\n        if separators is None:\n            separators = \'/\'\n        normalized_file = file.lstrip(\'/\')\n>       normalized_file = normalized_file.replace(\'\\\\\', separators)\nE       TypeError: replace() argument 2 must be str, not list\n\nrepos\\python-pathspec\\pathspec\\util.py:297: TypeError']"
python-pathspec,normalize_file,"def normalize_file(file: StrPath, separators: Optional[Collection[str]]=None) -> str:
    """"""
	Normalizes the file path to use the POSIX path separator (i.e.,
	``""/""``), and make the paths relative (remove leading ``""/""``).

	*file* (:class:`str` or :class:`os.PathLike`) is the file path.

	*separators* (:class:`~collections.abc.Collection` of :class:`str`; or
	``None``) optionally contains the path separators to normalize.
	This does not need to include the POSIX path separator (``""/""``),
	but including it will not affect the results. Default is ``None``
	for ``NORMALIZE_PATH_SEPS``. To prevent normalization, pass an
	empty container (e.g., an empty tuple ``()``).

	Returns the normalized file path (:class:`str`).
	""""""
    if separators is None:
        separators = NORMALIZE_PATH_SEPS
    norm_file: str = os.fspath(file)
    for sep in separators:
        norm_file = norm_file.replace(sep, posixpath.sep)
    if norm_file.startswith('/'):
        norm_file = norm_file[1:]
    elif norm_file.startswith('./'):
        norm_file = norm_file[2:]
    return norm_file","The goal of the function `normalize_file` is to normalize a given file path by using the POSIX path separator (""/"") and making the path relative (removing any leading ""/""). The function allows for optional customization of the path separators to be normalized, but by default it uses the standard path separators. This function is useful for ensuring consistency in file path representations across different platforms or systems.",3,"def normalize_file(file, separators='/'):
    if file.startswith(separators):
        file = file.lstrip(separators)
    file = file.replace('\\', separators).replace('//', separators)
    return file",['./repos/python-pathspec\\tests'],"65 Passed, 47 Failed",65,47,"['tests/test_01_util.py::NormalizeFileTest::test_01_purepath', 'tests/test_03_pathspec.py::PathSpecTest::test_01_absolute_dir_paths_1', 'tests/test_03_pathspec.py::PathSpecTest::test_01_absolute_dir_paths_2', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_1_include', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_2_exclude', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_3_unmatch', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_4_many', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_01_current_dir_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_01_empty_path_1', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_1_include', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_2_exclude', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_3_unmatch', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_01_windows_current_dir_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_01_windows_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_03_add', 'tests/test_03_pathspec.py::PathSpecTest::test_03_iadd', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_file', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_files', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_a', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_b', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_c', 'tests/test_03_pathspec.py::PathSpecTest::test_07_issue_62', 'tests/test_03_pathspec.py::PathSpecTest::test_08_issue_39', 'tests/test_03_pathspec.py::PathSpecTest::test_09_issue_80_a', 'tests/test_03_pathspec.py::PathSpecTest::test_09_issue_80_b', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_01_reversed_args', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_dir_exclusions', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_file_exclusions', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_issue_41_a', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_issue_41_b', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_issue_41_c', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_issue_19_a', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_issue_19_b', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_issue_19_c', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_subdir', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_04_issue_62', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_05_issue_39', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_06_issue_64', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_07_issue_74', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_08_issue_81_a', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_08_issue_81_b', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_08_issue_81_c']","['self = <tests.test_01_util.NormalizeFileTest testMethod=test_01_purepath>\n\n    def test_01_purepath(self):\n    \t""""""\n    \tTests normalizing a :class:`pathlib.PurePath` as argument.\n    \t""""""\n>   \tfirst_spec = normalize_file(pathlib.PurePath(\'a.txt\'))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:501: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = PureWindowsPath(\'a.txt\'), separators = \'/\'\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       AttributeError: \'PureWindowsPath\' object has no attribute \'startswith\'\n\nrepos\\python-pathspec\\pathspec\\util.py:294: AttributeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_absolute_dir_paths_1>\n\n    def test_01_absolute_dir_paths_1(self):\n    \t""""""\n    \tTests that absolute paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'foo\',\n    \t])\n    \tfiles = {\n    \t\t\'/a.py\',\n    \t\t\'/foo/a.py\',\n    \t\t\'/x/a.py\',\n    \t\t\'/x/foo/a.py\',\n    \t\t\'a.py\',\n    \t\t\'foo/a.py\',\n    \t\t\'x/a.py\',\n    \t\t\'x/foo/a.py\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:75: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'foo/a.py\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_absolute_dir_paths_2>\n\n    def test_01_absolute_dir_paths_2(self):\n    \t""""""\n    \tTests that absolute paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'/foo\',\n    \t])\n    \tfiles = {\n    \t\t\'/a.py\',\n    \t\t\'/foo/a.py\',\n    \t\t\'/x/a.py\',\n    \t\t\'/x/foo/a.py\',\n    \t\t\'a.py\',\n    \t\t\'foo/a.py\',\n    \t\t\'x/a.py\',\n    \t\t\'x/foo/a.py\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:104: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'foo/a.py\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_1_include>\n\n    def test_01_check_file_1_include(self):\n    \t""""""\n    \tTest checking a single file that is included.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""include.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:122: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:117: in check_file\n    norm_file = normalize_file(file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'include.txt\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_2_exclude>\n\n    def test_01_check_file_2_exclude(self):\n    \t""""""\n    \tTest checking a single file that is excluded.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""test/exclude.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:135: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:117: in check_file\n    norm_file = normalize_file(file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'test/exclude.txt\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_3_unmatch>\n\n    def test_01_check_file_3_unmatch(self):\n    \t""""""\n    \tTest checking a single file that is unmatched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tresult = spec.check_file(""unmatch.bin"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:117: in check_file\n    norm_file = normalize_file(file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'unmatch.bin\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_4_many>\n\n    def test_01_check_file_4_many(self):\n    \t""""""\n    \tTest that checking files one at a time yields the same results as checking\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tsingle_results = set(map(spec.check_file, files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:170: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:117: in check_file\n    norm_file = normalize_file(file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'test1/a.txt\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_match_files>\n\n    def test_01_check_match_files(self):\n    \t""""""\n    \tTest that checking files and matching files yield the same results.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/**\',\n    \t])\n    \tfiles = {\n    \t\t\'src/test1/a.txt\',\n    \t\t\'src/test1/b.txt\',\n    \t\t\'src/test1/c/c.txt\',\n    \t\t\'src/test2/a.txt\',\n    \t\t\'src/test2/b.txt\',\n    \t\t\'src/test2/c/c.txt\',\n    \t}\n    \n>   \tcheck_results = set(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:192: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'src/test2/c/c.txt\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_current_dir_paths>\n\n    def test_01_current_dir_paths(self):\n    \t""""""\n    \tTests that paths referencing the current directory will be properly\n    \tnormalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'./src/test1/a.txt\',\n    \t\t\'./src/test1/b.txt\',\n    \t\t\'./src/test1/c/c.txt\',\n    \t\t\'./src/test2/a.txt\',\n    \t\t\'./src/test2/b.txt\',\n    \t\t\'./src/test2/c/c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:216: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'./src/test1/a.txt\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_empty_path_1>\n\n    def test_01_empty_path_1(self):\n    \t""""""\n    \tTests that patterns that end with an escaped space will be treated properly.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'\\\\ \',\n    \t\t\'abc\\\\ \'\n    \t])\n    \tfiles = {\n    \t\t\' \',\n    \t\t\'  \',\n    \t\t\'abc \',\n    \t\t\'somefile\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:241: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \' \', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_1_include>\n\n    def test_01_match_file_1_include(self):\n    \t""""""\n    \tTest matching a single file that is included.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""include.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:270: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:278: in match_file\n    norm_file = normalize_file(file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'include.txt\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_2_exclude>\n\n    def test_01_match_file_2_exclude(self):\n    \t""""""\n    \tTest matching a single file that is excluded.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""test/exclude.txt"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:283: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:278: in match_file\n    norm_file = normalize_file(file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'test/exclude.txt\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_3_unmatch>\n\n    def test_01_match_file_3_unmatch(self):\n    \t""""""\n    \tTest match a single file that is unmatched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n    \n>   \tinclude = spec.match_file(""unmatch.bin"")\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:296: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:278: in match_file\n    norm_file = normalize_file(file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'unmatch.bin\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_files>\n\n    def test_01_match_files(self):\n    \t""""""\n    \tTest that matching files one at a time yields the same results as matching\n    \tmultiples files at once.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tsingle_files = set(filter(spec.match_file, files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:318: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:278: in match_file\n    norm_file = normalize_file(file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'test1/a.txt\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_windows_current_dir_paths>\n\n    def test_01_windows_current_dir_paths(self):\n    \t""""""\n    \tTests that paths referencing the current directory will be properly\n    \tnormalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'.\\\\test1\\\\a.txt\',\n    \t\t\'.\\\\test1\\\\b.txt\',\n    \t\t\'.\\\\test1\\\\c\\\\c.txt\',\n    \t\t\'.\\\\test2\\\\a.txt\',\n    \t\t\'.\\\\test2\\\\b.txt\',\n    \t\t\'.\\\\test2\\\\c\\\\c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files, separators=[\'\\\\\']))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:341: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'.\\\\test2\\\\c\\\\c.txt\', separators = [\'\\\\\']\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not list\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_windows_paths>\n\n    def test_01_windows_paths(self):\n    \t""""""\n    \tTests that Windows paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1\\\\a.txt\',\n    \t\t\'test1\\\\b.txt\',\n    \t\t\'test1\\\\c\\\\c.txt\',\n    \t\t\'test2\\\\a.txt\',\n    \t\t\'test2\\\\b.txt\',\n    \t\t\'test2\\\\c\\\\c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files, separators=[\'\\\\\']))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'test1\\\\c\\\\c.txt\', separators = [\'\\\\\']\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not list\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_03_add>\n\n    def test_03_add(self):\n    \t""""""\n    \tTest spec addition using :data:`+` operator.\n    \t""""""\n    \tfirst_spec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t])\n    \tsecond_spec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t])\n    \tcombined_spec = first_spec + second_spec\n    \tfiles = {\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t}\n    \n>   \tresults = list(combined_spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:424: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'test.png\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_03_iadd>\n\n    def test_03_iadd(self):\n    \t""""""\n    \tTest spec addition using :data:`+=` operator.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t])\n    \tspec += PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t])\n    \tfiles = {\n    \t\t\'test.html\',\n    \t\t\'test.jpg\',\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:454: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'test.png\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_entries>\n\n    def test_05_match_entries(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tentries = iter_tree_entries(self.temp_dir)\n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_entries(entries)\n    \t}\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:500: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:245: in match_entries\n    norm_file = normalize_file(entry.path, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'X\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_file>\n\n    def test_05_match_file(self):\n    \t""""""\n    \tTest matching files individually.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tincludes = set(filter(spec.match_file, files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:527: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:278: in match_file\n    norm_file = normalize_file(file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'Y/b.txt\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_files>\n\n    def test_05_match_files(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tincludes = set(spec.match_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:553: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:313: in match_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'Y/b.txt\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_entries>\n\n    def test_05_match_tree_entries(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tincludes = {\n>   \t\t__entry.path for __entry in spec.match_tree_entries(self.temp_dir)\n    \t}\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:586: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:355: in match_tree_entries\n    yield from self.match_entries(entries, negate=negate)\nrepos\\python-pathspec\\pathspec\\pathspec.py:245: in match_entries\n    norm_file = normalize_file(entry.path, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'X\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_files>\n\n    def test_05_match_tree_files(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n>   \tincludes = set(spec.match_tree_files(self.temp_dir))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:619: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:390: in match_tree_files\n    yield from self.match_files(files, negate=negate)\nrepos\\python-pathspec\\pathspec\\pathspec.py:313: in match_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'X\\\\a.txt\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_a>\n\n    def test_06_issue_41_a(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario A.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.yaml\',\n    \t\t\'!*.yaml/\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:647: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'dir.yaml/file.sql\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_b>\n\n    def test_06_issue_41_b(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name\n    \tpattern, scenario B.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'!*.yaml/\',\n    \t\t\'*.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:683: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'dir.yaml/file.sql\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_c>\n\n    def test_06_issue_41_c(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name\n    \tpattern, scenario C.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.yaml\',\n    \t\t\'!dir.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir.yaml/index.txt\',\n    \t\t\'dir/file.sql\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'dir/index.txt\',\n    \t\t\'file.yaml\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:718: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'dir.yaml/file.sql\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_07_issue_62>\n\n    def test_07_issue_62(self):\n    \t""""""\n    \tTest including all files and excluding a directory.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*\',\n    \t\t\'!product_dir/\',\n    \t])\n    \tfiles = {\n    \t\t\'anydir/file.txt\',\n    \t\t\'product_dir/file.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:748: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'product_dir/file.txt\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_08_issue_39>\n\n    def test_08_issue_39(self):\n    \t""""""\n    \tTest excluding files in a directory.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.log\',\n    \t\t\'!important/*.log\',\n    \t\t\'trace.*\',\n    \t])\n    \tfiles = {\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'important/d.log\',\n    \t\t\'important/e.txt\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:773: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'a.log\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_09_issue_80_a>\n\n    def test_09_issue_80_a(self):\n    \t""""""\n    \tTest negating patterns.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'build\',\n    \t\t\'*.log\',\n    \t\t\'.*\',\n    \t\t\'!.gitignore\',\n    \t])\n    \tfiles = {\n    \t\t\'.c-tmp\',\n    \t\t\'.gitignore\',\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'build/d.log\',\n    \t\t\'build/trace.bin\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tkeeps = set(spec.match_files(files, negate=True))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:807: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:313: in match_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'a.log\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_09_issue_80_b>\n\n    def test_09_issue_80_b(self):\n    \t""""""\n    \tTest negating patterns.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'build\',\n    \t\t\'*.log\',\n    \t\t\'.*\',\n    \t\t\'!.gitignore\',\n    \t])\n    \tfiles = {\n    \t\t\'.c-tmp\',\n    \t\t\'.gitignore\',\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'build/d.log\',\n    \t\t\'build/trace.bin\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tkeeps = set(spec.match_files(files, negate=True))\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:835: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:313: in match_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'a.log\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_01_reversed_args>\n\n    def test_01_reversed_args(self):\n    \t""""""\n    \tTest reversed args for `.from_lines()`.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines(\'gitwildmatch\', [\'*.txt\'])\n    \tfiles = {\n    \t\t\'a.txt\',\n    \t\t\'b.bin\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:30: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'b.bin\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_dir_exclusions>\n\n    def test_02_dir_exclusions(self):\n    \t""""""\n    \tTest directory exclusions.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.bin\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.bin\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:55: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'test2/b.bin\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_file_exclusions>\n\n    def test_02_file_exclusions(self):\n    \t""""""\n    \tTest file exclusions.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:87: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'Y/b.txt\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_issue_41_a>\n\n    def test_02_issue_41_a(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario A.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.yaml\',\n    \t\t\'!*.yaml/\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',   # -\n    \t\t\'dir.yaml/file.yaml\',  # 1:*.yaml\n    \t\t\'dir.yaml/index.txt\',  # -\n    \t\t\'dir/file.sql\',        # -\n    \t\t\'dir/file.yaml\',       # 1:*.yaml\n    \t\t\'dir/index.txt\',       # -\n    \t\t\'file.yaml\',           # 1:*.yaml\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:122: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'dir.yaml/file.sql\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_issue_41_b>\n\n    def test_02_issue_41_b(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario B.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'!*.yaml/\',\n    \t\t\'*.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',   # 2:*.yaml\n    \t\t\'dir.yaml/file.yaml\',  # 2:*.yaml\n    \t\t\'dir.yaml/index.txt\',  # 2:*.yaml\n    \t\t\'dir/file.sql\',        # -\n    \t\t\'dir/file.yaml\',       # 2:*.yaml\n    \t\t\'dir/index.txt\',       # -\n    \t\t\'file.yaml\',           # 2:*.yaml\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:158: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'dir.yaml/file.sql\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_issue_41_c>\n\n    def test_02_issue_41_c(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario C.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.yaml\',\n    \t\t\'!dir.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',   # -\n    \t\t\'dir.yaml/file.yaml\',  # 1:*.yaml\n    \t\t\'dir.yaml/index.txt\',  # -\n    \t\t\'dir/file.sql\',        # -\n    \t\t\'dir/file.yaml\',       # 1:*.yaml\n    \t\t\'dir/index.txt\',       # -\n    \t\t\'file.yaml\',           # 1:*.yaml\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:194: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'dir.yaml/file.sql\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_issue_19_a>\n\n    def test_03_issue_19_a(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory, scenario A.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/"",\n    \t])\n    \tfiles = {\n    \t\t\'fileA\',\n    \t\t\'fileB\',\n    \t\t\'dirD/fileE\',\n    \t\t\'dirD/fileF\',\n    \t\t\'dirG/dirH/fileI\',\n    \t\t\'dirG/dirH/fileJ\',\n    \t\t\'dirG/fileO\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:260: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'dirG/fileO\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_issue_19_b>\n\n    def test_03_issue_19_b(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory, scenario B.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/*"",\n    \t])\n    \tfiles = {\n    \t\t\'fileA\',\n    \t\t\'fileB\',\n    \t\t\'dirD/fileE\',\n    \t\t\'dirD/fileF\',\n    \t\t\'dirG/dirH/fileI\',\n    \t\t\'dirG/dirH/fileJ\',\n    \t\t\'dirG/fileO\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:293: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'dirG/fileO\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_issue_19_c>\n\n    def test_03_issue_19_c(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory, scenario C.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/**"",\n    \t])\n    \tfiles = {\n    \t\t\'fileA\',\n    \t\t\'fileB\',\n    \t\t\'dirD/fileE\',\n    \t\t\'dirD/fileF\',\n    \t\t\'dirG/dirH/fileI\',\n    \t\t\'dirG/dirH/fileJ\',\n    \t\t\'dirG/fileO\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:326: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'dirG/fileO\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_subdir>\n\n    def test_03_subdir(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/"",\n    \t])\n    \tfiles = {\n    \t\t\'fileA\',\n    \t\t\'fileB\',\n    \t\t\'dirD/fileE\',\n    \t\t\'dirD/fileF\',\n    \t\t\'dirG/dirH/fileI\',\n    \t\t\'dirG/dirH/fileJ\',\n    \t\t\'dirG/fileO\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:227: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'dirG/fileO\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_04_issue_62>\n\n    def test_04_issue_62(self):\n    \t""""""\n    \tTest including all files and excluding a directory.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*\',\n    \t\t\'!product_dir/\',\n    \t])\n    \tfiles = {\n    \t\t\'anydir/file.txt\',\n    \t\t\'product_dir/file.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:355: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'product_dir/file.txt\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_05_issue_39>\n\n    def test_05_issue_39(self):\n    \t""""""\n    \tTest excluding files in a directory.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.log\',\n    \t\t\'!important/*.log\',\n    \t\t\'trace.*\',\n    \t])\n    \tfiles = {\n    \t\t\'a.log\',\n    \t\t\'b.txt\',\n    \t\t\'important/d.log\',\n    \t\t\'important/e.txt\',\n    \t\t\'trace.c\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:381: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'a.log\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_06_issue_64>\n\n    def test_06_issue_64(self):\n    \t""""""\n    \tTest using a double asterisk pattern.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""**"",\n    \t])\n    \tfiles = {\n    \t\t\'x\',\n    \t\t\'y.py\',\n    \t\t\'A/x\',\n    \t\t\'A/y.py\',\n    \t\t\'A/B/x\',\n    \t\t\'A/B/y.py\',\n    \t\t\'A/B/C/x\',\n    \t\t\'A/B/C/y.py\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:413: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'A/B/y.py\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_07_issue_74>\n\n    def test_07_issue_74(self):\n    \t""""""\n    \tTest include directory should override exclude file.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*\',  # Ignore all files by default\n    \t\t\'!*/\',  # but scan all directories\n    \t\t\'!*.txt\',  # Text files\n    \t\t\'/test1/**\',  # ignore all in the directory\n    \t])\n    \tfiles = {\n    \t\t\'test1/b.bin\',\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.bin\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:438: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'test2/b.bin\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_08_issue_81_a>\n\n    def test_08_issue_81_a(self):\n    \t""""""\n    \tTest issue 81 whitelist, scenario A.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""*"",\n    \t\t""!libfoo"",\n    \t\t""!libfoo/**"",\n    \t])\n    \tfiles = {\n    \t\t""ignore.txt"",          # 1:*\n    \t\t""libfoo/__init__.py"",  # 3:!libfoo/**\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'ignore.txt\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_08_issue_81_b>\n\n    def test_08_issue_81_b(self):\n    \t""""""\n    \tTest issue 81 whitelist, scenario B.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""*"",\n    \t\t""!libfoo"",\n    \t\t""!libfoo/*"",\n    \t])\n    \tfiles = {\n    \t\t""ignore.txt"",          # 1:*\n    \t\t""libfoo/__init__.py"",  # 3:!libfoo/*\n    \t}\n    \n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:494: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'ignore.txt\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_08_issue_81_c>\n\n    def test_08_issue_81_c(self):\n    \t""""""\n    \tTest issue 81 whitelist, scenario C.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""*"",\n    \t\t""!libfoo"",\n    \t\t""!libfoo/"",\n    \t])\n    \tfiles = {\n    \t\t""ignore.txt"",          # 1:*\n    \t\t""libfoo/__init__.py"",  # 1:*\n    \t}\n>   \tresults = list(spec.check_files(files))\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:519: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:145: in check_files\n    norm_file = normalize_file(orig_file, separators)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = \'ignore.txt\', separators = None\n\n    def normalize_file(file, separators=\'/\'):\n>       if file.startswith(separators):\nE       TypeError: startswith first arg must be str or a tuple of str, not NoneType\n\nrepos\\python-pathspec\\pathspec\\util.py:294: TypeError']"
python-pathspec,normalize_files,"def normalize_files(files: Iterable[StrPath], separators: Optional[Collection[str]]=None) -> Dict[str, List[StrPath]]:
    """"""
	DEPRECATED: This function is no longer used. Use the :func:`.normalize_file`
	function with a loop for better results.

	Normalizes the file paths to use the POSIX path separator.

	*files* (:class:`~collections.abc.Iterable` of :class:`str` or
	:class:`os.PathLike`) contains the file paths to be normalized.

	*separators* (:class:`~collections.abc.Collection` of :class:`str`; or
	:data:`None`) optionally contains the path separators to normalize.
	See :func:`normalize_file` for more information.

	Returns a :class:`dict` mapping each normalized file path (:class:`str`)
	to the original file paths (:class:`list` of :class:`str` or
	:class:`os.PathLike`).
	""""""
    warnings.warn('util.normalize_files() is deprecated. Use util.normalize_file() with a loop for better results.', DeprecationWarning, stacklevel=2)
    norm_files = {}
    for path in files:
        norm_file = normalize_file(path, separators=separators)
        if norm_file in norm_files:
            norm_files[norm_file].append(path)
        else:
            norm_files[norm_file] = [path]
    return norm_files","The function `normalize_files` is designed to normalize a list of file paths by converting them to use the POSIX path separator. It takes in a list of file paths and an optional collection of path separators as input, and then returns a dictionary where each normalized file path is mapped to a list of original file paths. This function has been deprecated in favor of using the `normalize_file` function with a loop for better results.",1,"def normalize_files(files, separators=[os.path.sep]):
    normalized_files = {}
    for file_path in files:
        normalized_path = file_path.replace(separators[0], '/')
        if normalized_path not in normalized_files:
            normalized_files[normalized_path] = [file_path]
        else:
            normalized_files[normalized_path].append(file_path)
    return normalized_files",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,normalize_files,"def normalize_files(files: Iterable[StrPath], separators: Optional[Collection[str]]=None) -> Dict[str, List[StrPath]]:
    """"""
	DEPRECATED: This function is no longer used. Use the :func:`.normalize_file`
	function with a loop for better results.

	Normalizes the file paths to use the POSIX path separator.

	*files* (:class:`~collections.abc.Iterable` of :class:`str` or
	:class:`os.PathLike`) contains the file paths to be normalized.

	*separators* (:class:`~collections.abc.Collection` of :class:`str`; or
	:data:`None`) optionally contains the path separators to normalize.
	See :func:`normalize_file` for more information.

	Returns a :class:`dict` mapping each normalized file path (:class:`str`)
	to the original file paths (:class:`list` of :class:`str` or
	:class:`os.PathLike`).
	""""""
    warnings.warn('util.normalize_files() is deprecated. Use util.normalize_file() with a loop for better results.', DeprecationWarning, stacklevel=2)
    norm_files = {}
    for path in files:
        norm_file = normalize_file(path, separators=separators)
        if norm_file in norm_files:
            norm_files[norm_file].append(path)
        else:
            norm_files[norm_file] = [path]
    return norm_files","The function `normalize_files` is designed to normalize a list of file paths by converting them to use the POSIX path separator. It takes in a list of file paths and an optional collection of path separators as input, and then returns a dictionary where each normalized file path is mapped to a list of original file paths. This function has been deprecated in favor of using the `normalize_file` function with a loop for better results.",2,"def normalize_files(files, separators=['/']):
    normalized_files = {}
    for file_path in files:
        normalized_path = file_path.replace(""\\"", ""/"")
        for separator in separators:
            normalized_path = normalized_path.replace(separator, ""/"")
        if normalized_path not in normalized_files:
            normalized_files[normalized_path] = [file_path]
        else:
            normalized_files[normalized_path].append(file_path)
    return normalized_files",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,normalize_files,"def normalize_files(files: Iterable[StrPath], separators: Optional[Collection[str]]=None) -> Dict[str, List[StrPath]]:
    """"""
	DEPRECATED: This function is no longer used. Use the :func:`.normalize_file`
	function with a loop for better results.

	Normalizes the file paths to use the POSIX path separator.

	*files* (:class:`~collections.abc.Iterable` of :class:`str` or
	:class:`os.PathLike`) contains the file paths to be normalized.

	*separators* (:class:`~collections.abc.Collection` of :class:`str`; or
	:data:`None`) optionally contains the path separators to normalize.
	See :func:`normalize_file` for more information.

	Returns a :class:`dict` mapping each normalized file path (:class:`str`)
	to the original file paths (:class:`list` of :class:`str` or
	:class:`os.PathLike`).
	""""""
    warnings.warn('util.normalize_files() is deprecated. Use util.normalize_file() with a loop for better results.', DeprecationWarning, stacklevel=2)
    norm_files = {}
    for path in files:
        norm_file = normalize_file(path, separators=separators)
        if norm_file in norm_files:
            norm_files[norm_file].append(path)
        else:
            norm_files[norm_file] = [path]
    return norm_files","The function `normalize_files` is designed to normalize a list of file paths by converting them to use the POSIX path separator. It takes in a list of file paths and an optional collection of path separators as input, and then returns a dictionary where each normalized file path is mapped to a list of original file paths. This function has been deprecated in favor of using the `normalize_file` function with a loop for better results.",3,"def normalize_files(files, separators=None):
    normalized_files = {}
    
    for file_path in files:
        normalized_path = file_path.replace('\\', '/')

        if separators:
            for separator in separators:
                normalized_path = normalized_path.replace(separator, '/')

        if normalized_path not in normalized_files:
            normalized_files[normalized_path] = [file_path]
        else:
            normalized_files[normalized_path].append(file_path)

    return normalized_files",['./repos/python-pathspec\\tests'],"112 Passed, 0 Failed",112,0,[],[]
python-pathspec,register_pattern,"def register_pattern(name: str, pattern_factory: Callable[[AnyStr], Pattern], override: Optional[bool]=None) -> None:
    """"""
	Registers the specified pattern factory.

	*name* (:class:`str`) is the name to register the pattern factory
	under.

	*pattern_factory* (:class:`~collections.abc.Callable`) is used to
	compile patterns. It must accept an uncompiled pattern (:class:`str`)
	and return the compiled pattern (:class:`.Pattern`).

	*override* (:class:`bool` or :data:`None`) optionally is whether to
	allow overriding an already registered pattern under the same name
	(:data:`True`), instead of raising an :exc:`AlreadyRegisteredError`
	(:data:`False`). Default is :data:`None` for :data:`False`.
	""""""
    if not isinstance(name, str):
        raise TypeError(f'name:{name!r} is not a string.')
    if not callable(pattern_factory):
        raise TypeError(f'pattern_factory:{pattern_factory!r} is not callable.')
    if name in _registered_patterns and (not override):
        raise AlreadyRegisteredError(name, _registered_patterns[name])
    _registered_patterns[name] = pattern_factory",The function `register_pattern` is used to register a pattern factory under a specified name. The pattern factory is responsible for compiling patterns based on uncompiled strings. It allows for the registration of different pattern factories under unique names. The function also provides an option to override an already registered pattern under the same name if needed.,1,"def register_pattern(name, pattern_factory, override=False):
    if name in registered_patterns and not override:
        raise ValueError(f""Pattern '{name}' is already registered. Use override=True to update."")
    registered_patterns[name] = pattern_factory",['./repos/python-pathspec\\tests'],"0 Passed, 0 Failed",0,0,[],[]
python-pathspec,register_pattern,"def register_pattern(name: str, pattern_factory: Callable[[AnyStr], Pattern], override: Optional[bool]=None) -> None:
    """"""
	Registers the specified pattern factory.

	*name* (:class:`str`) is the name to register the pattern factory
	under.

	*pattern_factory* (:class:`~collections.abc.Callable`) is used to
	compile patterns. It must accept an uncompiled pattern (:class:`str`)
	and return the compiled pattern (:class:`.Pattern`).

	*override* (:class:`bool` or :data:`None`) optionally is whether to
	allow overriding an already registered pattern under the same name
	(:data:`True`), instead of raising an :exc:`AlreadyRegisteredError`
	(:data:`False`). Default is :data:`None` for :data:`False`.
	""""""
    if not isinstance(name, str):
        raise TypeError(f'name:{name!r} is not a string.')
    if not callable(pattern_factory):
        raise TypeError(f'pattern_factory:{pattern_factory!r} is not callable.')
    if name in _registered_patterns and (not override):
        raise AlreadyRegisteredError(name, _registered_patterns[name])
    _registered_patterns[name] = pattern_factory",The function `register_pattern` is used to register a pattern factory under a specified name. The pattern factory is responsible for compiling patterns based on uncompiled strings. It allows for the registration of different pattern factories under unique names. The function also provides an option to override an already registered pattern under the same name if needed.,2,"def register_pattern(name, pattern_factory, override=False):
    if override or name not in registered_patterns:
        registered_patterns[name] = pattern_factory
    else:
        raise ValueError(f""Pattern already registered under the name '{name}'"")
    
registered_patterns = {}",['./repos/python-pathspec\\tests'],"0 Passed, 0 Failed",0,0,[],[]
python-pathspec,register_pattern,"def register_pattern(name: str, pattern_factory: Callable[[AnyStr], Pattern], override: Optional[bool]=None) -> None:
    """"""
	Registers the specified pattern factory.

	*name* (:class:`str`) is the name to register the pattern factory
	under.

	*pattern_factory* (:class:`~collections.abc.Callable`) is used to
	compile patterns. It must accept an uncompiled pattern (:class:`str`)
	and return the compiled pattern (:class:`.Pattern`).

	*override* (:class:`bool` or :data:`None`) optionally is whether to
	allow overriding an already registered pattern under the same name
	(:data:`True`), instead of raising an :exc:`AlreadyRegisteredError`
	(:data:`False`). Default is :data:`None` for :data:`False`.
	""""""
    if not isinstance(name, str):
        raise TypeError(f'name:{name!r} is not a string.')
    if not callable(pattern_factory):
        raise TypeError(f'pattern_factory:{pattern_factory!r} is not callable.')
    if name in _registered_patterns and (not override):
        raise AlreadyRegisteredError(name, _registered_patterns[name])
    _registered_patterns[name] = pattern_factory",The function `register_pattern` is used to register a pattern factory under a specified name. The pattern factory is responsible for compiling patterns based on uncompiled strings. It allows for the registration of different pattern factories under unique names. The function also provides an option to override an already registered pattern under the same name if needed.,3,"def register_pattern(name, pattern_factory, override=False):
    if override or name not in patterns:
        patterns[name] = pattern_factory
    else:
        raise ValueError(f""A pattern with the name '{name}' is already registered."")
        
patterns = {}",['./repos/python-pathspec\\tests'],"0 Passed, 0 Failed",0,0,[],[]
python-pathspec,pattern_to_regex,"@classmethod
def pattern_to_regex(cls, pattern: AnyStr) -> Tuple[Optional[AnyStr], Optional[bool]]:
    """"""
		Convert the pattern into a regular expression.

		*pattern* (:class:`str` or :class:`bytes`) is the pattern to convert into a
		regular expression.

		Returns the uncompiled regular expression (:class:`str`, :class:`bytes`, or
		:data:`None`); and whether matched files should be included (:data:`True`),
		excluded (:data:`False`), or if it is a null-operation (:data:`None`).
		""""""
    if isinstance(pattern, str):
        return_type = str
    elif isinstance(pattern, bytes):
        return_type = bytes
        pattern = pattern.decode(_BYTES_ENCODING)
    else:
        raise TypeError(f'pattern:{pattern!r} is not a unicode or byte string.')
    original_pattern = pattern
    if pattern.endswith('\\ '):
        pattern = pattern.lstrip()
    else:
        pattern = pattern.strip()
    regex: Optional[str]
    include: Optional[bool]
    if pattern.startswith('#'):
        regex = None
        include = None
    elif pattern == '/':
        regex = None
        include = None
    elif pattern:
        if pattern.startswith('!'):
            include = False
            pattern = pattern[1:]
        else:
            include = True
        override_regex: Optional[str] = None
        pattern_segs = pattern.split('/')
        is_dir_pattern = not pattern_segs[-1]
        for i in range(len(pattern_segs) - 1, 0, -1):
            prev = pattern_segs[i - 1]
            seg = pattern_segs[i]
            if prev == '**' and seg == '**':
                del pattern_segs[i]
        if len(pattern_segs) == 2 and pattern_segs[0] == '**' and (not pattern_segs[1]):
            override_regex = f'^.+(?P<{_DIR_MARK}>/).*$'
        if not pattern_segs[0]:
            del pattern_segs[0]
        elif len(pattern_segs) == 1 or (len(pattern_segs) == 2 and (not pattern_segs[1])):
            if pattern_segs[0] != '**':
                pattern_segs.insert(0, '**')
        else:
            pass
        if not pattern_segs:
            raise GitWildMatchPatternError(f'Invalid git pattern: {original_pattern!r}')
        if not pattern_segs[-1] and len(pattern_segs) > 1:
            pattern_segs[-1] = '**'
        if override_regex is None:
            output = ['^']
            need_slash = False
            end = len(pattern_segs) - 1
            for i, seg in enumerate(pattern_segs):
                if seg == '**':
                    if i == 0 and i == end:
                        output.append(f'[^/]+(?:/.*)?')
                    elif i == 0:
                        output.append('(?:.+/)?')
                        need_slash = False
                    elif i == end:
                        if is_dir_pattern:
                            output.append(f'(?P<{_DIR_MARK}>/).*')
                        else:
                            output.append(f'/.*')
                    else:
                        output.append('(?:/.+)?')
                        need_slash = True
                elif seg == '*':
                    if need_slash:
                        output.append('/')
                    output.append('[^/]+')
                    if i == end:
                        output.append(f'(?:(?P<{_DIR_MARK}>/).*)?')
                    need_slash = True
                else:
                    if need_slash:
                        output.append('/')
                    try:
                        output.append(cls._translate_segment_glob(seg))
                    except ValueError as e:
                        raise GitWildMatchPatternError(f'Invalid git pattern: {original_pattern!r}') from e
                    if i == end:
                        output.append(f'(?:(?P<{_DIR_MARK}>/).*)?')
                    need_slash = True
            output.append('$')
            regex = ''.join(output)
        else:
            regex = override_regex
    else:
        regex = None
        include = None
    if regex is not None and return_type is bytes:
        regex = regex.encode(_BYTES_ENCODING)
    return (regex, include)","The goal of the function is to convert a given pattern into a regular expression. The function determines whether files matching the pattern should be included, excluded, or if it is a null-operation. It handles different types of patterns and constructs the regular expression based on the pattern logic, ultimately returning the compiled regular expression and the inclusion/exclusion status. This function is designed to be used within a class context and interacts with class attributes or other methods to properly handle and convert the patterns into regular expressions.",1,"def pattern_to_regex(cls, pattern):
    regex_pattern = convert_pattern_to_regex(pattern)
    inclusion_status = determine_inclusion_status(pattern)
    return regex_pattern, inclusion_status

def convert_pattern_to_regex(pattern):
    # logic to convert pattern to regular expression
    return compiled_regex

def determine_inclusion_status(pattern):
    # logic to determine if pattern should be included, excluded, or null-operation
    return inclusion_status",['./repos/python-pathspec\\tests'],"10 Passed, 102 Failed",10,102,"['tests/test_01_util.py::CheckMatchFileTest::test_01_single_1_include', 'tests/test_01_util.py::CheckMatchFileTest::test_01_single_2_exclude', 'tests/test_01_util.py::CheckMatchFileTest::test_01_single_3_unmatch', 'tests/test_01_util.py::CheckMatchFileTest::test_02_many', 'tests/test_01_util.py::MatchFileTest::test_01_single_1_include', 'tests/test_01_util.py::MatchFileTest::test_01_single_2_exclude', 'tests/test_01_util.py::MatchFileTest::test_01_single_3_unmatch', 'tests/test_01_util.py::MatchFileTest::test_02_many', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_00_empty', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_01_absolute', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_01_absolute_ignore', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_01_absolute_root', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_01_relative', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_01_relative_nested', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_02_comment', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_02_ignore', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_03_child_double_asterisk', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_03_double_asterisk_trailing_slash_edge_case', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_03_duplicate_leading_double_asterisk_edge_case', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_03_inner_double_asterisk', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_03_only_double_asterisk', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_03_parent_double_asterisk', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_04_infix_wildcard', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_04_postfix_wildcard', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_04_prefix_wildcard', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_05_directory', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_07_match_bytes_and_bytes', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_07_match_bytes_and_bytes_complete', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_07_match_bytes_and_unicode_fail', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_07_match_unicode_and_bytes_fail', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_07_match_unicode_and_unicode', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_09_single_escape_fail', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_09_single_exclamation_mark_fail', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_10_escape_asterisk_end', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_10_escape_asterisk_mid', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_10_escape_asterisk_start', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_10_escape_exclamation_mark_start', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_10_escape_pound_start', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_11_issue_19_directory_a', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_11_issue_19_directory_b', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_11_issue_19_directory_c', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_12_asterisk_1_regex', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_12_asterisk_2_regex_equivalent', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_12_asterisk_3_child', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_12_asterisk_4_descendant', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_12_issue_62', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_13_issue_77_1_negate_with_caret', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_13_issue_77_1_negate_with_exclamation_mark', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_13_issue_77_2_regex', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_14_issue_81_a', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_14_issue_81_b', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_14_issue_81_c', 'tests/test_03_pathspec.py::PathSpecTest::test_01_absolute_dir_paths_1', 'tests/test_03_pathspec.py::PathSpecTest::test_01_absolute_dir_paths_2', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_1_include', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_2_exclude', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_3_unmatch', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_file_4_many', 'tests/test_03_pathspec.py::PathSpecTest::test_01_check_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_01_current_dir_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_01_empty_path_1', 'tests/test_03_pathspec.py::PathSpecTest::test_01_empty_path_2', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_1_include', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_2_exclude', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_file_3_unmatch', 'tests/test_03_pathspec.py::PathSpecTest::test_01_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_01_windows_current_dir_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_01_windows_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_02_eq', 'tests/test_03_pathspec.py::PathSpecTest::test_02_ne', 'tests/test_03_pathspec.py::PathSpecTest::test_03_add', 'tests/test_03_pathspec.py::PathSpecTest::test_03_iadd', 'tests/test_03_pathspec.py::PathSpecTest::test_04_len', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_file', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_files', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_a', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_b', 'tests/test_03_pathspec.py::PathSpecTest::test_06_issue_41_c', 'tests/test_03_pathspec.py::PathSpecTest::test_07_issue_62', 'tests/test_03_pathspec.py::PathSpecTest::test_08_issue_39', 'tests/test_03_pathspec.py::PathSpecTest::test_09_issue_80_a', 'tests/test_03_pathspec.py::PathSpecTest::test_09_issue_80_b', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_01_reversed_args', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_dir_exclusions', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_file_exclusions', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_issue_41_a', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_issue_41_b', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_issue_41_c', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_issue_19_a', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_issue_19_b', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_issue_19_c', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_03_subdir', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_04_issue_62', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_05_issue_39', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_06_issue_64', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_07_issue_74', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_08_issue_81_a', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_08_issue_81_b', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_08_issue_81_c']","['self = <tests.test_01_util.CheckMatchFileTest testMethod=test_01_single_1_include>\n\n    def test_01_single_1_include(self):\n    \t""""""\n    \tTest checking a single file that is included.\n    \t""""""\n>   \tpatterns = list(enumerate(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34763E40>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_01_util.CheckMatchFileTest testMethod=test_01_single_2_exclude>\n\n    def test_01_single_2_exclude(self):\n    \t""""""\n    \tTest checking a single file that is excluded.\n    \t""""""\n>   \tpatterns = list(enumerate(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:59: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34872800>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_01_util.CheckMatchFileTest testMethod=test_01_single_3_unmatch>\n\n    def test_01_single_3_unmatch(self):\n    \t""""""\n    \tTest checking a single file that is ignored.\n    \t""""""\n>   \tpatterns = list(enumerate(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3483B6C0>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_01_util.CheckMatchFileTest testMethod=test_02_many>\n\n    def test_02_many(self):\n    \t""""""\n    \tTest matching files individually.\n    \t""""""\n>   \tpatterns = list(enumerate(map(GitWildMatchPattern, [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:85: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A348C8B80>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_01_util.MatchFileTest testMethod=test_01_single_1_include>\n\n    def test_01_single_1_include(self):\n    \t""""""\n    \tTest checking a single file that is included.\n    \t""""""\n>   \tpatterns = list(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t]))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:429: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A348AD7C0>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_01_util.MatchFileTest testMethod=test_01_single_2_exclude>\n\n    def test_01_single_2_exclude(self):\n    \t""""""\n    \tTest checking a single file that is excluded.\n    \t""""""\n>   \tpatterns = list(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t]))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:442: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A348E74C0>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_01_util.MatchFileTest testMethod=test_01_single_3_unmatch>\n\n    def test_01_single_3_unmatch(self):\n    \t""""""\n    \tTest checking a single file that is ignored.\n    \t""""""\n>   \tpatterns = list(map(GitWildMatchPattern, [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t]))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:455: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3462C200>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_01_util.MatchFileTest testMethod=test_02_many>\n\n    def test_02_many(self):\n    \t""""""\n    \tTest matching files individually.\n    \t""""""\n>   \tpatterns = list(map(GitWildMatchPattern, [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t]))\n\nrepos\\python-pathspec\\tests\\test_01_util.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A348877C0>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_00_empty>\n\n    def test_00_empty(self):\n    \t""""""\n    \tTests an empty pattern.\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:44: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_01_absolute>\n\n    def test_01_absolute(self):\n    \t""""""\n    \tTests an absolute path pattern.\n    \n    \tThis should match:\n    \n    \t\tan/absolute/file/path\n    \t\tan/absolute/file/path/foo\n    \n    \tThis should NOT match:\n    \n    \t\tfoo/an/absolute/file/path\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'/an/absolute/file/path\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:61: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_01_absolute_ignore>\n\n    def test_01_absolute_ignore(self):\n    \t""""""\n    \tTests an ignore absolute path pattern.\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'!/foo/build\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:80: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_01_absolute_root>\n\n    def test_01_absolute_root(self):\n    \t""""""\n    \tTests a single root absolute path pattern.\n    \n    \tThis should NOT match any file (according to git check-ignore\n    \t(v2.4.1)).\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'/\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:102: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_01_relative>\n\n    def test_01_relative(self):\n    \t""""""\n    \tTests a relative path pattern.\n    \n    \tThis should match:\n    \n    \t\tspam\n    \t\tspam/\n    \t\tfoo/spam\n    \t\tspam/foo\n    \t\tfoo/spam/bar\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'spam\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:118: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_01_relative_nested>\n\n    def test_01_relative_nested(self):\n    \t""""""\n    \tTests a relative nested path pattern.\n    \n    \tThis should match:\n    \n    \t\tfoo/spam\n    \t\tfoo/spam/bar\n    \n    \tThis should **not** match (according to git check-ignore (v2.4.1)):\n    \n    \t\tbar/foo/spam\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'foo/spam\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:151: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_02_comment>\n\n    def test_02_comment(self):\n    \t""""""\n    \tTests a comment pattern.\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'# Cork soakers.\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:170: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_02_ignore>\n\n    def test_02_ignore(self):\n    \t""""""\n    \tTests an exclude pattern.\n    \n    \tThis should NOT match (according to git check-ignore (v2.4.1)):\n    \n    \t\ttemp/foo\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'!temp\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:182: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_03_child_double_asterisk>\n\n    def test_03_child_double_asterisk(self):\n    \t""""""\n    \tTests a directory name with a double-asterisk child\n    \tdirectory.\n    \n    \tThis should match:\n    \n    \t\tspam/bar\n    \n    \tThis should **not** match (according to git check-ignore (v2.4.1)):\n    \n    \t\tfoo/spam/bar\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'spam/**\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:209: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_03_double_asterisk_trailing_slash_edge_case>\n\n    def test_03_double_asterisk_trailing_slash_edge_case(self):\n    \t""""""\n    \tTests the edge-case **/ pattern.\n    \n    \tThis should match everything except individual files in the root directory.\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'**/\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:357: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_03_duplicate_leading_double_asterisk_edge_case>\n\n    def test_03_duplicate_leading_double_asterisk_edge_case(self):\n    \t""""""\n    \tRegression test for duplicate leading **/ bug.\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'**\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:315: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_03_inner_double_asterisk>\n\n    def test_03_inner_double_asterisk(self):\n    \t""""""\n    \tTests a path with an inner double-asterisk directory.\n    \n    \tThis should match:\n    \n    \t\tleft/right\n    \t\tleft/bar/right\n    \t\tleft/foo/bar/right\n    \t\tleft/bar/right/foo\n    \n    \tThis should **not** match (according to git check-ignore (v2.4.1)):\n    \n    \t\tfoo/left/bar/right\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'left/**/right\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:235: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_03_only_double_asterisk>\n\n    def test_03_only_double_asterisk(self):\n    \t""""""\n    \tTests a double-asterisk pattern which matches everything.\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'**\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:258: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_03_parent_double_asterisk>\n\n    def test_03_parent_double_asterisk(self):\n    \t""""""\n    \tTests a file name with a double-asterisk parent directory.\n    \n    \tThis should match:\n    \n    \t\tspam\n    \t\tfoo/spam\n    \t\tfoo/spam/bar\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'**/spam\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:295: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_04_infix_wildcard>\n\n    def test_04_infix_wildcard(self):\n    \t""""""\n    \tTests a pattern with an infix wildcard.\n    \n    \tThis should match:\n    \n    \t\tfoo--bar\n    \t\tfoo-hello-bar\n    \t\ta/foo-hello-bar\n    \t\tfoo-hello-bar/b\n    \t\ta/foo-hello-bar/b\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'foo-*-bar\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:377: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_04_postfix_wildcard>\n\n    def test_04_postfix_wildcard(self):\n    \t""""""\n    \tTests a pattern with a postfix wildcard.\n    \n    \tThis should match:\n    \n    \t\t~temp-\n    \t\t~temp-foo\n    \t\t~temp-foo/bar\n    \t\tfoo/~temp-bar\n    \t\tfoo/~temp-bar/baz\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'~temp-*\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:409: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_04_prefix_wildcard>\n\n    def test_04_prefix_wildcard(self):\n    \t""""""\n    \tTests a pattern with a prefix wildcard.\n    \n    \tThis should match:\n    \n    \t\tbar.py\n    \t\tbar.py/\n    \t\tfoo/bar.py\n    \t\tfoo/bar.py/baz\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'*.py\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:440: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_05_directory>\n\n    def test_05_directory(self):\n    \t""""""\n    \tTests a directory pattern.\n    \n    \tThis should match:\n    \n    \t\tdir/\n    \t\tfoo/dir/\n    \t\tfoo/dir/bar\n    \n    \tThis should **not** match:\n    \n    \t\tdir\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'dir/\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:472: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_07_match_bytes_and_bytes>\n\n    def test_07_match_bytes_and_bytes(self):\n    \t""""""\n    \tTest byte string patterns matching byte string paths.\n    \t""""""\n>   \tpattern = GitWildMatchPattern(b\'*.py\')\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:557: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3496D000>\npattern = b\'*.py\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_07_match_bytes_and_bytes_complete>\n\n    def test_07_match_bytes_and_bytes_complete(self):\n    \t""""""\n    \tTest byte string patterns matching byte string paths.\n    \t""""""\n    \tencoded = bytes(bytearray(range(0, 256)))\n    \n    \t# Forward slashes cannot be escaped with the current implementation.\n    \t# Remove ASCII 47.\n    \tfs_ord = ord(\'/\')\n    \tencoded = encoded[:fs_ord] + encoded[fs_ord+1:]\n    \n    \tescaped = b"""".join(b""\\\\"" + encoded[i:i+1] for i in range(len(encoded)))\n    \n>   \tpattern = GitWildMatchPattern(escaped)\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:574: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34941F00>\npattern = b\'\\\\\\x00\\\\\\x01\\\\\\x02\\\\\\x03\\\\\\x04\\\\\\x05\\\\\\x06\\\\\\x07\\\\\\x08\\\\\\t\\\\\\n\\\\\\x0b\\\\\\x0c\\\\\\r\\\\\\x0e\\\\\\x0f\\\\\\x10\\\\\\x11\\\\\\x12\\\\\\x13\\\\...\\xec\\\\\\xed\\\\\\xee\\\\\\xef\\\\\\xf0\\\\\\xf1\\\\\\xf2\\\\\\xf3\\\\\\xf4\\\\\\xf5\\\\\\xf6\\\\\\xf7\\\\\\xf8\\\\\\xf9\\\\\\xfa\\\\\\xfb\\\\\\xfc\\\\\\xfd\\\\\\xfe\\\\\\xff\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_07_match_bytes_and_unicode_fail>\n\n    def test_07_match_bytes_and_unicode_fail(self):\n    \t""""""\n    \tTest byte string patterns matching byte string paths.\n    \t""""""\n>   \tpattern = GitWildMatchPattern(b\'*.py\')\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:582: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34751F40>\npattern = b\'*.py\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_07_match_unicode_and_bytes_fail>\n\n    def test_07_match_unicode_and_bytes_fail(self):\n    \t""""""\n    \tTest unicode patterns with byte paths.\n    \t""""""\n>   \tpattern = GitWildMatchPattern(\'*.py\')\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:590: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34615940>\npattern = \'*.py\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_07_match_unicode_and_unicode>\n\n    def test_07_match_unicode_and_unicode(self):\n    \t""""""\n    \tTest unicode patterns with unicode paths.\n    \t""""""\n>   \tpattern = GitWildMatchPattern(\'*.py\')\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:598: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A348E64C0>\npattern = \'*.py\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_09_single_escape_fail>\n\n    def test_09_single_escape_fail(self):\n    \t""""""\n    \tTest an escape on a line by itself.\n    \t""""""\n>   \tself._check_invalid_pattern(""\\\\"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:615: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:38: in _check_invalid_pattern\n    GitWildMatchPattern(git_ignore_pattern)\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_09_single_exclamation_mark_fail>\n\n    def test_09_single_exclamation_mark_fail(self):\n    \t""""""\n    \tTest an escape on a line by itself.\n    \t""""""\n>   \tself._check_invalid_pattern(""!"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:621: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:38: in _check_invalid_pattern\n    GitWildMatchPattern(git_ignore_pattern)\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_10_escape_asterisk_end>\n\n    def test_10_escape_asterisk_end(self):\n    \t""""""\n    \tTest escaping an asterisk at the end of a line.\n    \t""""""\n>   \tpattern = GitWildMatchPattern(""asteris\\\\*"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:627: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34753D40>\npattern = \'asteris\\\\*\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_10_escape_asterisk_mid>\n\n    def test_10_escape_asterisk_mid(self):\n    \t""""""\n    \tTest escaping an asterisk in the middle of a line.\n    \t""""""\n>   \tpattern = GitWildMatchPattern(""as\\\\*erisk"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:638: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3488B540>\npattern = \'as\\\\*erisk\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_10_escape_asterisk_start>\n\n    def test_10_escape_asterisk_start(self):\n    \t""""""\n    \tTest escaping an asterisk at the start of a line.\n    \t""""""\n>   \tpattern = GitWildMatchPattern(""\\\\*sterisk"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:649: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34738D00>\npattern = \'\\\\*sterisk\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_10_escape_exclamation_mark_start>\n\n    def test_10_escape_exclamation_mark_start(self):\n    \t""""""\n    \tTest escaping an exclamation mark at the start of a line.\n    \t""""""\n>   \tpattern = GitWildMatchPattern(""\\\\!mark"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:660: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3495F4C0>\npattern = \'\\\\!mark\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_10_escape_pound_start>\n\n    def test_10_escape_pound_start(self):\n    \t""""""\n    \tTest escaping a pound sign at the start of a line.\n    \t""""""\n>   \tpattern = GitWildMatchPattern(""\\\\#sign"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:670: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34839780>\npattern = \'\\\\#sign\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_11_issue_19_directory_a>\n\n    def test_11_issue_19_directory_a(self):\n    \t""""""\n    \tTest a directory discrepancy, scenario A.\n    \t""""""\n    \t# NOTE: The result from GitWildMatchPattern will differ from GitIgnoreSpec.\n>   \tpattern = GitWildMatchPattern(""dirG/"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:681: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34752680>\npattern = \'dirG/\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_11_issue_19_directory_b>\n\n    def test_11_issue_19_directory_b(self):\n    \t""""""\n    \tTest a directory discrepancy, scenario B.\n    \t""""""\n    \t# NOTE: The result from GitWildMatchPattern will differ from GitIgnoreSpec.\n>   \tpattern = GitWildMatchPattern(""dirG/*"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:702: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A349875C0>\npattern = \'dirG/*\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_11_issue_19_directory_c>\n\n    def test_11_issue_19_directory_c(self):\n    \t""""""\n    \tTest a directory discrepancy, scenario C.\n    \t""""""\n    \t# NOTE: The result from GitWildMatchPattern will differ from GitIgnoreSpec.\n>   \tpattern = GitWildMatchPattern(""dirG/**"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:723: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34739000>\npattern = \'dirG/**\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_12_asterisk_1_regex>\n\n    def test_12_asterisk_1_regex(self):\n    \t""""""\n    \tTest a relative asterisk path pattern\'s regular expression.\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'*\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:743: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_12_asterisk_2_regex_equivalent>\n\n    def test_12_asterisk_2_regex_equivalent(self):\n    \t""""""\n    \tTest a path pattern equivalent to the relative asterisk using double\n    \tasterisk.\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'*\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:752: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_12_asterisk_3_child>\n\n    def test_12_asterisk_3_child(self):\n    \t""""""\n    \tTest a relative asterisk path pattern matching a direct child path.\n    \t""""""\n>   \tpattern = GitWildMatchPattern(""*"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:764: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34982980>\npattern = \'*\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_12_asterisk_4_descendant>\n\n    def test_12_asterisk_4_descendant(self):\n    \t""""""\n    \tTest a relative asterisk path pattern matching a descendant path.\n    \t""""""\n>   \tpattern = GitWildMatchPattern(""*"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:771: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3495C3C0>\npattern = \'*\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_12_issue_62>\n\n    def test_12_issue_62(self):\n    \t""""""\n    \tTest including all files, scenario A.\n    \t""""""\n>   \tpattern = GitWildMatchPattern(""*"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:778: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34878140>\npattern = \'*\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_13_issue_77_1_negate_with_caret>\n\n    def test_13_issue_77_1_negate_with_caret(self):\n    \t""""""\n    \tTest negation using the caret symbol (""^"").\n    \t""""""\n>   \tpattern = GitWildMatchPattern(""a[^gy]c"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:792: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3464F4C0>\npattern = \'a[^gy]c\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_13_issue_77_1_negate_with_exclamation_mark>\n\n    def test_13_issue_77_1_negate_with_exclamation_mark(self):\n    \t""""""\n    \tTest negation using the exclamation mark (""!"").\n    \t""""""\n>   \tpattern = GitWildMatchPattern(""a[!gy]c"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:808: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34983440>\npattern = \'a[!gy]c\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_13_issue_77_2_regex>\n\n    def test_13_issue_77_2_regex(self):\n    \t""""""\n    \tTest the resulting regex for regex bracket expression negation.\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(""a[^b]c"")\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:824: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_14_issue_81_a>\n\n    def test_14_issue_81_a(self):\n    \t""""""\n    \tTest ignoring files in a directory, scenario A.\n    \t""""""\n>   \tpattern = GitWildMatchPattern(""!libfoo/**"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:836: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A349404C0>\npattern = \'!libfoo/**\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_14_issue_81_b>\n\n    def test_14_issue_81_b(self):\n    \t""""""\n    \tTest ignoring files in a directory, scenario B.\n    \t""""""\n>   \tpattern = GitWildMatchPattern(""!libfoo/*"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:846: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34981800>\npattern = \'!libfoo/*\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_14_issue_81_c>\n\n    def test_14_issue_81_c(self):\n    \t""""""\n    \tTest ignoring files in a directory, scenario C.\n    \t""""""\n    \t# GitWildMatchPattern will match the file, but GitIgnoreSpec should not.\n>   \tpattern = GitWildMatchPattern(""!libfoo/"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:857: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34950240>\npattern = \'!libfoo/\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_absolute_dir_paths_1>\n\n    def test_01_absolute_dir_paths_1(self):\n    \t""""""\n    \tTests that absolute paths will be properly normalized and matched.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'foo\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:61: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34722200>\npattern = \'foo\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_absolute_dir_paths_2>\n\n    def test_01_absolute_dir_paths_2(self):\n    \t""""""\n    \tTests that absolute paths will be properly normalized and matched.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'/foo\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:90: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A349FB4C0>\npattern = \'/foo\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_1_include>\n\n    def test_01_check_file_1_include(self):\n    \t""""""\n    \tTest checking a single file that is included.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:117: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34889940>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_2_exclude>\n\n    def test_01_check_file_2_exclude(self):\n    \t""""""\n    \tTest checking a single file that is excluded.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:130: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A346AAE00>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_3_unmatch>\n\n    def test_01_check_file_3_unmatch(self):\n    \t""""""\n    \tTest checking a single file that is unmatched.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:143: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A348AA2C0>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_file_4_many>\n\n    def test_01_check_file_4_many(self):\n    \t""""""\n    \tTest that checking files one at a time yields the same results as checking\n    \tmultiples files at once.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:157: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34985D80>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_check_match_files>\n\n    def test_01_check_match_files(self):\n    \t""""""\n    \tTest that checking files and matching files yield the same results.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/**\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:179: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3485E880>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_current_dir_paths>\n\n    def test_01_current_dir_paths(self):\n    \t""""""\n    \tTests that paths referencing the current directory will be properly\n    \tnormalized and matched.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:203: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A348C8640>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_empty_path_1>\n\n    def test_01_empty_path_1(self):\n    \t""""""\n    \tTests that patterns that end with an escaped space will be treated properly.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'\\\\ \',\n    \t\t\'abc\\\\ \'\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:230: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A346C2280>\npattern = \'\\\\ \'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_empty_path_2>\n\n    def test_01_empty_path_2(self):\n    \t""""""\n    \tTests that patterns that end with an escaped space will be treated properly.\n    \t""""""\n    \twith self.assertRaises(GitWildMatchPatternError):\n    \t\t# An escape with double spaces is invalid. Disallow it. Better to be safe\n    \t\t# than sorry.\n>   \t\tPathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\t\'\\\\  \',\n    \t\t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:257: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_1_include>\n\n    def test_01_match_file_1_include(self):\n    \t""""""\n    \tTest matching a single file that is included.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:265: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3462FC00>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_2_exclude>\n\n    def test_01_match_file_2_exclude(self):\n    \t""""""\n    \tTest matching a single file that is excluded.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:278: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A348B27C0>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_file_3_unmatch>\n\n    def test_01_match_file_3_unmatch(self):\n    \t""""""\n    \tTest match a single file that is unmatched.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t""*.txt"",\n    \t\t""!test/"",\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:291: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34980800>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_match_files>\n\n    def test_01_match_files(self):\n    \t""""""\n    \tTest that matching files one at a time yields the same results as matching\n    \tmultiples files at once.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:305: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34616780>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_windows_current_dir_paths>\n\n    def test_01_windows_current_dir_paths(self):\n    \t""""""\n    \tTests that paths referencing the current directory will be properly\n    \tnormalized and matched.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:328: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3465B840>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_windows_paths>\n\n    def test_01_windows_paths(self):\n    \t""""""\n    \tTests that Windows paths will be properly normalized and matched.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:355: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A349F3500>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_02_eq>\n\n    def test_02_eq(self):\n    \t""""""\n    \tTests equality.\n    \t""""""\n>   \tfirst_spec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/**\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:382: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34820A80>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_02_ne>\n\n    def test_02_ne(self):\n    \t""""""\n    \tTests inequality.\n    \t""""""\n>   \tfirst_spec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:396: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3488A3C0>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_03_add>\n\n    def test_03_add(self):\n    \t""""""\n    \tTest spec addition using :data:`+` operator.\n    \t""""""\n>   \tfirst_spec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:408: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3475A500>\npattern = \'test.png\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_03_iadd>\n\n    def test_03_iadd(self):\n    \t""""""\n    \tTest spec addition using :data:`+=` operator.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'test.png\',\n    \t\t\'test.txt\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:439: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A348E6000>\npattern = \'test.png\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_04_len>\n\n    def test_04_len(self):\n    \t""""""\n    \tTest spec length.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'foo\',\n    \t\t\'bar\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:469: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A348E4CC0>\npattern = \'foo\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_entries>\n\n    def test_05_match_entries(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:479: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A345FC440>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_file>\n\n    def test_05_match_file(self):\n    \t""""""\n    \tTest matching files individually.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:514: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3495EB00>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_files>\n\n    def test_05_match_files(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:540: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3499FBC0>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_entries>\n\n    def test_05_match_tree_entries(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:566: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A349AD500>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_files>\n\n    def test_05_match_tree_files(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:600: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3493A940>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_a>\n\n    def test_06_issue_41_a(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario A.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.yaml\',\n    \t\t\'!*.yaml/\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:633: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A346D7380>\npattern = \'*.yaml\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_b>\n\n    def test_06_issue_41_b(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name\n    \tpattern, scenario B.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'!*.yaml/\',\n    \t\t\'*.yaml\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:669: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A349C3600>\npattern = \'!*.yaml/\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_06_issue_41_c>\n\n    def test_06_issue_41_c(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name\n    \tpattern, scenario C.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.yaml\',\n    \t\t\'!dir.yaml\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:704: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34753400>\npattern = \'*.yaml\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_07_issue_62>\n\n    def test_07_issue_62(self):\n    \t""""""\n    \tTest including all files and excluding a directory.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*\',\n    \t\t\'!product_dir/\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:739: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A30EE9200>\npattern = \'*\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_08_issue_39>\n\n    def test_08_issue_39(self):\n    \t""""""\n    \tTest excluding files in a directory.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.log\',\n    \t\t\'!important/*.log\',\n    \t\t\'trace.*\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:760: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34744100>\npattern = \'*.log\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_09_issue_80_a>\n\n    def test_09_issue_80_a(self):\n    \t""""""\n    \tTest negating patterns.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'build\',\n    \t\t\'*.log\',\n    \t\t\'.*\',\n    \t\t\'!.gitignore\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:791: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34758680>\npattern = \'build\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_09_issue_80_b>\n\n    def test_09_issue_80_b(self):\n    \t""""""\n    \tTest negating patterns.\n    \t""""""\n>   \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'build\',\n    \t\t\'*.log\',\n    \t\t\'.*\',\n    \t\t\'!.gitignore\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:819: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34931800>\npattern = \'build\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_01_reversed_args>\n\n    def test_01_reversed_args(self):\n    \t""""""\n    \tTest reversed args for `.from_lines()`.\n    \t""""""\n>   \tspec = GitIgnoreSpec.from_lines(\'gitwildmatch\', [\'*.txt\'])\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\gitignore.py:103: in from_lines\n    self = super().from_lines(pattern_factory, lines)\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3494B400>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_dir_exclusions>\n\n    def test_02_dir_exclusions(self):\n    \t""""""\n    \tTest directory exclusions.\n    \t""""""\n>   \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:42: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\gitignore.py:103: in from_lines\n    self = super().from_lines(pattern_factory, lines)\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A349783C0>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_file_exclusions>\n\n    def test_02_file_exclusions(self):\n    \t""""""\n    \tTest file exclusions.\n    \t""""""\n>   \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:74: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\gitignore.py:103: in from_lines\n    self = super().from_lines(pattern_factory, lines)\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A349830C0>\npattern = \'*.txt\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_issue_41_a>\n\n    def test_02_issue_41_a(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario A.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n>   \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.yaml\',\n    \t\t\'!*.yaml/\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:108: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\gitignore.py:103: in from_lines\n    self = super().from_lines(pattern_factory, lines)\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34763F00>\npattern = \'*.yaml\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_issue_41_b>\n\n    def test_02_issue_41_b(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario B.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n>   \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'!*.yaml/\',\n    \t\t\'*.yaml\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:144: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\gitignore.py:103: in from_lines\n    self = super().from_lines(pattern_factory, lines)\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34A07280>\npattern = \'!*.yaml/\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_issue_41_c>\n\n    def test_02_issue_41_c(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario C.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n>   \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.yaml\',\n    \t\t\'!dir.yaml\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:180: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\gitignore.py:103: in from_lines\n    self = super().from_lines(pattern_factory, lines)\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A348C9440>\npattern = \'*.yaml\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_issue_19_a>\n\n    def test_03_issue_19_a(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory, scenario A.\n    \t""""""\n>   \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/"",\n    \t])\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:247: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\gitignore.py:103: in from_lines\n    self = super().from_lines(pattern_factory, lines)\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34760040>\npattern = \'dirG/\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_issue_19_b>\n\n    def test_03_issue_19_b(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory, scenario B.\n    \t""""""\n>   \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/*"",\n    \t])\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:280: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\gitignore.py:103: in from_lines\n    self = super().from_lines(pattern_factory, lines)\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A30EE8040>\npattern = \'dirG/*\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_issue_19_c>\n\n    def test_03_issue_19_c(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory, scenario C.\n    \t""""""\n>   \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/**"",\n    \t])\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:313: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\gitignore.py:103: in from_lines\n    self = super().from_lines(pattern_factory, lines)\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3473A800>\npattern = \'dirG/**\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_03_subdir>\n\n    def test_03_subdir(self):\n    \t""""""\n    \tTest matching files in a subdirectory of an included directory.\n    \t""""""\n>   \tspec = GitIgnoreSpec.from_lines([\n    \t\t""dirG/"",\n    \t])\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\gitignore.py:103: in from_lines\n    self = super().from_lines(pattern_factory, lines)\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34A3D300>\npattern = \'dirG/\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_04_issue_62>\n\n    def test_04_issue_62(self):\n    \t""""""\n    \tTest including all files and excluding a directory.\n    \t""""""\n>   \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*\',\n    \t\t\'!product_dir/\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:346: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\gitignore.py:103: in from_lines\n    self = super().from_lines(pattern_factory, lines)\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3495D240>\npattern = \'*\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_05_issue_39>\n\n    def test_05_issue_39(self):\n    \t""""""\n    \tTest excluding files in a directory.\n    \t""""""\n>   \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.log\',\n    \t\t\'!important/*.log\',\n    \t\t\'trace.*\',\n    \t])\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\gitignore.py:103: in from_lines\n    self = super().from_lines(pattern_factory, lines)\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A349C28C0>\npattern = \'*.log\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_06_issue_64>\n\n    def test_06_issue_64(self):\n    \t""""""\n    \tTest using a double asterisk pattern.\n    \t""""""\n>   \tspec = GitIgnoreSpec.from_lines([\n    \t\t""**"",\n    \t])\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:399: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\gitignore.py:103: in from_lines\n    self = super().from_lines(pattern_factory, lines)\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3499B1C0>\npattern = \'**\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_07_issue_74>\n\n    def test_07_issue_74(self):\n    \t""""""\n    \tTest include directory should override exclude file.\n    \t""""""\n>   \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*\',  # Ignore all files by default\n    \t\t\'!*/\',  # but scan all directories\n    \t\t\'!*.txt\',  # Text files\n    \t\t\'/test1/**\',  # ignore all in the directory\n    \t])\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:423: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\gitignore.py:103: in from_lines\n    self = super().from_lines(pattern_factory, lines)\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34951A40>\npattern = \'*\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_08_issue_81_a>\n\n    def test_08_issue_81_a(self):\n    \t""""""\n    \tTest issue 81 whitelist, scenario A.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n>   \tspec = GitIgnoreSpec.from_lines([\n    \t\t""*"",\n    \t\t""!libfoo"",\n    \t\t""!libfoo/**"",\n    \t])\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:458: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\gitignore.py:103: in from_lines\n    self = super().from_lines(pattern_factory, lines)\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3499A680>\npattern = \'*\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_08_issue_81_b>\n\n    def test_08_issue_81_b(self):\n    \t""""""\n    \tTest issue 81 whitelist, scenario B.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n>   \tspec = GitIgnoreSpec.from_lines([\n    \t\t""*"",\n    \t\t""!libfoo"",\n    \t\t""!libfoo/*"",\n    \t])\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:484: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\gitignore.py:103: in from_lines\n    self = super().from_lines(pattern_factory, lines)\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A3497B6C0>\npattern = \'*\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_08_issue_81_c>\n\n    def test_08_issue_81_c(self):\n    \t""""""\n    \tTest issue 81 whitelist, scenario C.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n>   \tspec = GitIgnoreSpec.from_lines([\n    \t\t""*"",\n    \t\t""!libfoo"",\n    \t\t""!libfoo/"",\n    \t])\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:510: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\gitignore.py:103: in from_lines\n    self = super().from_lines(pattern_factory, lines)\nrepos\\python-pathspec\\pathspec\\pathspec.py:212: in from_lines\n    patterns = [pattern_factory(line) for line in lines if line]\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x0000013A34940D80>\npattern = \'*\'\n\n    def pattern_to_regex(cls, pattern):\n>       regex_pattern = convert_pattern_to_regex(pattern)\nE       NameError: name \'convert_pattern_to_regex\' is not defined\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:30: NameError']"
python-pathspec,pattern_to_regex,"@classmethod
def pattern_to_regex(cls, pattern: AnyStr) -> Tuple[Optional[AnyStr], Optional[bool]]:
    """"""
		Convert the pattern into a regular expression.

		*pattern* (:class:`str` or :class:`bytes`) is the pattern to convert into a
		regular expression.

		Returns the uncompiled regular expression (:class:`str`, :class:`bytes`, or
		:data:`None`); and whether matched files should be included (:data:`True`),
		excluded (:data:`False`), or if it is a null-operation (:data:`None`).
		""""""
    if isinstance(pattern, str):
        return_type = str
    elif isinstance(pattern, bytes):
        return_type = bytes
        pattern = pattern.decode(_BYTES_ENCODING)
    else:
        raise TypeError(f'pattern:{pattern!r} is not a unicode or byte string.')
    original_pattern = pattern
    if pattern.endswith('\\ '):
        pattern = pattern.lstrip()
    else:
        pattern = pattern.strip()
    regex: Optional[str]
    include: Optional[bool]
    if pattern.startswith('#'):
        regex = None
        include = None
    elif pattern == '/':
        regex = None
        include = None
    elif pattern:
        if pattern.startswith('!'):
            include = False
            pattern = pattern[1:]
        else:
            include = True
        override_regex: Optional[str] = None
        pattern_segs = pattern.split('/')
        is_dir_pattern = not pattern_segs[-1]
        for i in range(len(pattern_segs) - 1, 0, -1):
            prev = pattern_segs[i - 1]
            seg = pattern_segs[i]
            if prev == '**' and seg == '**':
                del pattern_segs[i]
        if len(pattern_segs) == 2 and pattern_segs[0] == '**' and (not pattern_segs[1]):
            override_regex = f'^.+(?P<{_DIR_MARK}>/).*$'
        if not pattern_segs[0]:
            del pattern_segs[0]
        elif len(pattern_segs) == 1 or (len(pattern_segs) == 2 and (not pattern_segs[1])):
            if pattern_segs[0] != '**':
                pattern_segs.insert(0, '**')
        else:
            pass
        if not pattern_segs:
            raise GitWildMatchPatternError(f'Invalid git pattern: {original_pattern!r}')
        if not pattern_segs[-1] and len(pattern_segs) > 1:
            pattern_segs[-1] = '**'
        if override_regex is None:
            output = ['^']
            need_slash = False
            end = len(pattern_segs) - 1
            for i, seg in enumerate(pattern_segs):
                if seg == '**':
                    if i == 0 and i == end:
                        output.append(f'[^/]+(?:/.*)?')
                    elif i == 0:
                        output.append('(?:.+/)?')
                        need_slash = False
                    elif i == end:
                        if is_dir_pattern:
                            output.append(f'(?P<{_DIR_MARK}>/).*')
                        else:
                            output.append(f'/.*')
                    else:
                        output.append('(?:/.+)?')
                        need_slash = True
                elif seg == '*':
                    if need_slash:
                        output.append('/')
                    output.append('[^/]+')
                    if i == end:
                        output.append(f'(?:(?P<{_DIR_MARK}>/).*)?')
                    need_slash = True
                else:
                    if need_slash:
                        output.append('/')
                    try:
                        output.append(cls._translate_segment_glob(seg))
                    except ValueError as e:
                        raise GitWildMatchPatternError(f'Invalid git pattern: {original_pattern!r}') from e
                    if i == end:
                        output.append(f'(?:(?P<{_DIR_MARK}>/).*)?')
                    need_slash = True
            output.append('$')
            regex = ''.join(output)
        else:
            regex = override_regex
    else:
        regex = None
        include = None
    if regex is not None and return_type is bytes:
        regex = regex.encode(_BYTES_ENCODING)
    return (regex, include)","The goal of the function is to convert a given pattern into a regular expression. The function determines whether files matching the pattern should be included, excluded, or if it is a null-operation. It handles different types of patterns and constructs the regular expression based on the pattern logic, ultimately returning the compiled regular expression and the inclusion/exclusion status. This function is designed to be used within a class context and interacts with class attributes or other methods to properly handle and convert the patterns into regular expressions.",2,"def pattern_to_regex(cls, pattern):
    import re

    if pattern.startswith(""!""):
        pattern = pattern[1:]
        inclusion_status = False
    elif pattern.startswith(""+""):
        pattern = pattern[1:]
        inclusion_status = True
    else:
        inclusion_status = True

    pattern = pattern.replace(""."", ""\."").replace(""*"", "".*"").replace(""?"", ""."")

    regex = re.compile(pattern)
    
    return regex, inclusion_status",['./repos/python-pathspec\\tests'],"60 Passed, 52 Failed",60,52,"['tests/test_01_util.py::CheckMatchFileTest::test_02_many', 'tests/test_01_util.py::MatchFileTest::test_02_many', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_00_empty', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_01_absolute', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_01_absolute_ignore', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_01_absolute_root', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_01_relative', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_01_relative_nested', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_02_comment', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_02_ignore', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_03_child_double_asterisk', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_03_double_asterisk_trailing_slash_edge_case', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_03_duplicate_leading_double_asterisk_edge_case', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_03_inner_double_asterisk', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_03_only_double_asterisk', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_03_parent_double_asterisk', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_04_infix_wildcard', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_04_postfix_wildcard', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_04_prefix_wildcard', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_05_directory', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_07_match_bytes_and_bytes', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_07_match_bytes_and_bytes_complete', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_07_match_bytes_and_unicode_fail', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_09_single_escape_fail', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_09_single_exclamation_mark_fail', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_10_escape_asterisk_end', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_10_escape_asterisk_mid', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_10_escape_asterisk_start', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_12_asterisk_1_regex', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_12_asterisk_2_regex_equivalent', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_13_issue_77_1_negate_with_exclamation_mark', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_13_issue_77_2_regex', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_14_issue_81_a', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_14_issue_81_b', 'tests/test_02_gitwildmatch.py::GitWildMatchTest::test_14_issue_81_c', 'tests/test_03_pathspec.py::PathSpecTest::test_01_absolute_dir_paths_1', 'tests/test_03_pathspec.py::PathSpecTest::test_01_absolute_dir_paths_2', 'tests/test_03_pathspec.py::PathSpecTest::test_01_current_dir_paths', 'tests/test_03_pathspec.py::PathSpecTest::test_01_empty_path_1', 'tests/test_03_pathspec.py::PathSpecTest::test_01_empty_path_2', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_file', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_files', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_entries', 'tests/test_03_pathspec.py::PathSpecTest::test_05_match_tree_files', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_dir_exclusions', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_file_exclusions', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_issue_41_a', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_02_issue_41_c', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_04_issue_62', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_07_issue_74', 'tests/test_04_gitignore.py::GitIgnoreSpecTest::test_08_issue_81_c']","['self = <tests.test_01_util.CheckMatchFileTest testMethod=test_02_many>\n\n    def test_02_many(self):\n    \t""""""\n    \tTest matching files individually.\n    \t""""""\n    \tpatterns = list(enumerate(map(GitWildMatchPattern, [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])))\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n    \tincludes = {\n    \t\t__file\n    \t\tfor __file in files\n    \t\tif check_match_file(patterns, __file)[0]\n    \t}\n    \n>   \tself.assertEqual(includes, {\n    \t\t\'X/a.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t})\nE    AssertionError: Items in the first set but not the second:\nE    \'X/b.txt\'\nE    \'Y/b.txt\'\n\nrepos\\python-pathspec\\tests\\test_01_util.py:104: AssertionError', 'self = <tests.test_01_util.MatchFileTest testMethod=test_02_many>\n\n    def test_02_many(self):\n    \t""""""\n    \tTest matching files individually.\n    \t""""""\n    \tpatterns = list(map(GitWildMatchPattern, [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t]))\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n    \tincludes = set(filter(partial(match_file, patterns), files))\n    \n>   \tself.assertEqual(includes, {\n    \t\t\'X/a.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t})\nE    AssertionError: Items in the first set but not the second:\nE    \'X/b.txt\'\nE    \'Y/b.txt\'\n\nrepos\\python-pathspec\\tests\\test_01_util.py:483: AssertionError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_00_empty>\n\n    def test_00_empty(self):\n    \t""""""\n    \tTests an empty pattern.\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:44: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_01_absolute>\n\n    def test_01_absolute(self):\n    \t""""""\n    \tTests an absolute path pattern.\n    \n    \tThis should match:\n    \n    \t\tan/absolute/file/path\n    \t\tan/absolute/file/path/foo\n    \n    \tThis should NOT match:\n    \n    \t\tfoo/an/absolute/file/path\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'/an/absolute/file/path\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:61: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_01_absolute_ignore>\n\n    def test_01_absolute_ignore(self):\n    \t""""""\n    \tTests an ignore absolute path pattern.\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'!/foo/build\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:80: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_01_absolute_root>\n\n    def test_01_absolute_root(self):\n    \t""""""\n    \tTests a single root absolute path pattern.\n    \n    \tThis should NOT match any file (according to git check-ignore\n    \t(v2.4.1)).\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'/\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:102: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_01_relative>\n\n    def test_01_relative(self):\n    \t""""""\n    \tTests a relative path pattern.\n    \n    \tThis should match:\n    \n    \t\tspam\n    \t\tspam/\n    \t\tfoo/spam\n    \t\tspam/foo\n    \t\tfoo/spam/bar\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'spam\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:118: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_01_relative_nested>\n\n    def test_01_relative_nested(self):\n    \t""""""\n    \tTests a relative nested path pattern.\n    \n    \tThis should match:\n    \n    \t\tfoo/spam\n    \t\tfoo/spam/bar\n    \n    \tThis should **not** match (according to git check-ignore (v2.4.1)):\n    \n    \t\tbar/foo/spam\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'foo/spam\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:151: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_02_comment>\n\n    def test_02_comment(self):\n    \t""""""\n    \tTests a comment pattern.\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'# Cork soakers.\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:170: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_02_ignore>\n\n    def test_02_ignore(self):\n    \t""""""\n    \tTests an exclude pattern.\n    \n    \tThis should NOT match (according to git check-ignore (v2.4.1)):\n    \n    \t\ttemp/foo\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'!temp\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:182: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_03_child_double_asterisk>\n\n    def test_03_child_double_asterisk(self):\n    \t""""""\n    \tTests a directory name with a double-asterisk child\n    \tdirectory.\n    \n    \tThis should match:\n    \n    \t\tspam/bar\n    \n    \tThis should **not** match (according to git check-ignore (v2.4.1)):\n    \n    \t\tfoo/spam/bar\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'spam/**\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:209: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_03_double_asterisk_trailing_slash_edge_case>\n\n    def test_03_double_asterisk_trailing_slash_edge_case(self):\n    \t""""""\n    \tTests the edge-case **/ pattern.\n    \n    \tThis should match everything except individual files in the root directory.\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'**/\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:357: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_03_duplicate_leading_double_asterisk_edge_case>\n\n    def test_03_duplicate_leading_double_asterisk_edge_case(self):\n    \t""""""\n    \tRegression test for duplicate leading **/ bug.\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'**\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:315: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_03_inner_double_asterisk>\n\n    def test_03_inner_double_asterisk(self):\n    \t""""""\n    \tTests a path with an inner double-asterisk directory.\n    \n    \tThis should match:\n    \n    \t\tleft/right\n    \t\tleft/bar/right\n    \t\tleft/foo/bar/right\n    \t\tleft/bar/right/foo\n    \n    \tThis should **not** match (according to git check-ignore (v2.4.1)):\n    \n    \t\tfoo/left/bar/right\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'left/**/right\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:235: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_03_only_double_asterisk>\n\n    def test_03_only_double_asterisk(self):\n    \t""""""\n    \tTests a double-asterisk pattern which matches everything.\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'**\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:258: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_03_parent_double_asterisk>\n\n    def test_03_parent_double_asterisk(self):\n    \t""""""\n    \tTests a file name with a double-asterisk parent directory.\n    \n    \tThis should match:\n    \n    \t\tspam\n    \t\tfoo/spam\n    \t\tfoo/spam/bar\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'**/spam\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:295: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_04_infix_wildcard>\n\n    def test_04_infix_wildcard(self):\n    \t""""""\n    \tTests a pattern with an infix wildcard.\n    \n    \tThis should match:\n    \n    \t\tfoo--bar\n    \t\tfoo-hello-bar\n    \t\ta/foo-hello-bar\n    \t\tfoo-hello-bar/b\n    \t\ta/foo-hello-bar/b\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'foo-*-bar\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:377: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_04_postfix_wildcard>\n\n    def test_04_postfix_wildcard(self):\n    \t""""""\n    \tTests a pattern with a postfix wildcard.\n    \n    \tThis should match:\n    \n    \t\t~temp-\n    \t\t~temp-foo\n    \t\t~temp-foo/bar\n    \t\tfoo/~temp-bar\n    \t\tfoo/~temp-bar/baz\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'~temp-*\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:409: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_04_prefix_wildcard>\n\n    def test_04_prefix_wildcard(self):\n    \t""""""\n    \tTests a pattern with a prefix wildcard.\n    \n    \tThis should match:\n    \n    \t\tbar.py\n    \t\tbar.py/\n    \t\tfoo/bar.py\n    \t\tfoo/bar.py/baz\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'*.py\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:440: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_05_directory>\n\n    def test_05_directory(self):\n    \t""""""\n    \tTests a directory pattern.\n    \n    \tThis should match:\n    \n    \t\tdir/\n    \t\tfoo/dir/\n    \t\tfoo/dir/bar\n    \n    \tThis should **not** match:\n    \n    \t\tdir\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'dir/\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:472: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_07_match_bytes_and_bytes>\n\n    def test_07_match_bytes_and_bytes(self):\n    \t""""""\n    \tTest byte string patterns matching byte string paths.\n    \t""""""\n>   \tpattern = GitWildMatchPattern(b\'*.py\')\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:557: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001762B659880>\npattern = b\'*.py\'\n\n    def pattern_to_regex(cls, pattern):\n        import re\n>       if pattern.startswith(\'!\'):\nE       TypeError: startswith first arg must be bytes or a tuple of bytes, not str\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:31: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_07_match_bytes_and_bytes_complete>\n\n    def test_07_match_bytes_and_bytes_complete(self):\n    \t""""""\n    \tTest byte string patterns matching byte string paths.\n    \t""""""\n    \tencoded = bytes(bytearray(range(0, 256)))\n    \n    \t# Forward slashes cannot be escaped with the current implementation.\n    \t# Remove ASCII 47.\n    \tfs_ord = ord(\'/\')\n    \tencoded = encoded[:fs_ord] + encoded[fs_ord+1:]\n    \n    \tescaped = b"""".join(b""\\\\"" + encoded[i:i+1] for i in range(len(encoded)))\n    \n>   \tpattern = GitWildMatchPattern(escaped)\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:574: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001762B7B9E80>\npattern = b\'\\\\\\x00\\\\\\x01\\\\\\x02\\\\\\x03\\\\\\x04\\\\\\x05\\\\\\x06\\\\\\x07\\\\\\x08\\\\\\t\\\\\\n\\\\\\x0b\\\\\\x0c\\\\\\r\\\\\\x0e\\\\\\x0f\\\\\\x10\\\\\\x11\\\\\\x12\\\\\\x13\\\\...\\xec\\\\\\xed\\\\\\xee\\\\\\xef\\\\\\xf0\\\\\\xf1\\\\\\xf2\\\\\\xf3\\\\\\xf4\\\\\\xf5\\\\\\xf6\\\\\\xf7\\\\\\xf8\\\\\\xf9\\\\\\xfa\\\\\\xfb\\\\\\xfc\\\\\\xfd\\\\\\xfe\\\\\\xff\'\n\n    def pattern_to_regex(cls, pattern):\n        import re\n>       if pattern.startswith(\'!\'):\nE       TypeError: startswith first arg must be bytes or a tuple of bytes, not str\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:31: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_07_match_bytes_and_unicode_fail>\n\n    def test_07_match_bytes_and_unicode_fail(self):\n    \t""""""\n    \tTest byte string patterns matching byte string paths.\n    \t""""""\n>   \tpattern = GitWildMatchPattern(b\'*.py\')\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:582: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <pathspec.patterns.gitwildmatch.GitWildMatchPattern object at 0x000001762B6C0AC0>\npattern = b\'*.py\'\n\n    def pattern_to_regex(cls, pattern):\n        import re\n>       if pattern.startswith(\'!\'):\nE       TypeError: startswith first arg must be bytes or a tuple of bytes, not str\n\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:31: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_09_single_escape_fail>\n\n    def test_09_single_escape_fail(self):\n    \t""""""\n    \tTest an escape on a line by itself.\n    \t""""""\n>   \tself._check_invalid_pattern(""\\\\"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:615: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:38: in _check_invalid_pattern\n    GitWildMatchPattern(git_ignore_pattern)\nrepos\\python-pathspec\\pathspec\\pattern.py:118: in __init__\n    regex, include = self.pattern_to_regex(pattern)\nrepos\\python-pathspec\\pathspec\\patterns\\gitwildmatch.py:40: in pattern_to_regex\n    regex = re.compile(pattern)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\re\\__init__.py:289: in compile\n    return _compile(pattern, flags)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\re\\__init__.py:350: in _compile\n    p = _compiler.compile(pattern, flags)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\re\\_compiler.py:743: in compile\n    p = _parser.parse(p, flags)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\re\\_parser.py:973: in parse\n    source = Tokenizer(str)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\re\\_parser.py:238: in __init__\n    self.__next()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def __next(self):\n        index = self.index\n        try:\n            char = self.decoded_string[index]\n        except IndexError:\n            self.next = None\n            return\n        if char == ""\\\\"":\n            index += 1\n            try:\n                char += self.decoded_string[index]\n            except IndexError:\n>               raise error(""bad escape (end of pattern)"",\n                            self.string, len(self.string) - 1) from None\nE               re.PatternError: bad escape (end of pattern) at position 0\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\re\\_parser.py:251: PatternError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_09_single_exclamation_mark_fail>\n\n    def test_09_single_exclamation_mark_fail(self):\n    \t""""""\n    \tTest an escape on a line by itself.\n    \t""""""\n>   \tself._check_invalid_pattern(""!"")\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:621: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:37: in _check_invalid_pattern\n    with self.assertRaisesRegex(GitWildMatchPatternError, expected_message_pattern):\nE   AssertionError: GitWildMatchPatternError not raised', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_10_escape_asterisk_end>\n\n    def test_10_escape_asterisk_end(self):\n    \t""""""\n    \tTest escaping an asterisk at the end of a line.\n    \t""""""\n    \tpattern = GitWildMatchPattern(""asteris\\\\*"")\n    \tresults = set(filter(pattern.match_file, [\n    \t\t""asteris*"",\n    \t\t""asterisk"",\n    \t]))\n>   \tself.assertEqual(results, {""asteris*""})\nE    AssertionError: Items in the first set but not the second:\nE    \'asterisk\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:632: AssertionError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_10_escape_asterisk_mid>\n\n    def test_10_escape_asterisk_mid(self):\n    \t""""""\n    \tTest escaping an asterisk in the middle of a line.\n    \t""""""\n    \tpattern = GitWildMatchPattern(""as\\\\*erisk"")\n    \tresults = set(filter(pattern.match_file, [\n    \t\t""as*erisk"",\n    \t\t""asterisk"",\n    \t]))\n>   \tself.assertEqual(results, {""as*erisk""})\nE    AssertionError: Items in the second set but not the first:\nE    \'as*erisk\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:643: AssertionError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_10_escape_asterisk_start>\n\n    def test_10_escape_asterisk_start(self):\n    \t""""""\n    \tTest escaping an asterisk at the start of a line.\n    \t""""""\n    \tpattern = GitWildMatchPattern(""\\\\*sterisk"")\n    \tresults = set(filter(pattern.match_file, [\n    \t\t""*sterisk"",\n    \t\t""asterisk"",\n    \t]))\n>   \tself.assertEqual(results, {""*sterisk""})\nE    AssertionError: Items in the second set but not the first:\nE    \'*sterisk\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:654: AssertionError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_12_asterisk_1_regex>\n\n    def test_12_asterisk_1_regex(self):\n    \t""""""\n    \tTest a relative asterisk path pattern\'s regular expression.\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'*\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:743: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_12_asterisk_2_regex_equivalent>\n\n    def test_12_asterisk_2_regex_equivalent(self):\n    \t""""""\n    \tTest a path pattern equivalent to the relative asterisk using double\n    \tasterisk.\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(\'*\')\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:752: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_13_issue_77_1_negate_with_exclamation_mark>\n\n    def test_13_issue_77_1_negate_with_exclamation_mark(self):\n    \t""""""\n    \tTest negation using the exclamation mark (""!"").\n    \t""""""\n    \tpattern = GitWildMatchPattern(""a[!gy]c"")\n    \tresults = set(filter(pattern.match_file, [\n    \t\t""agc"",\n    \t\t""ayc"",\n    \t\t""abc"",\n    \t\t""adc"",\n    \t]))\n>   \tself.assertEqual(results, {\n    \t\t""abc"",\n    \t\t""adc"",\n    \t})\nE    AssertionError: Items in the first set but not the second:\nE    \'ayc\'\nE    \'agc\'\nE    Items in the second set but not the first:\nE    \'adc\'\nE    \'abc\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:815: AssertionError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_13_issue_77_2_regex>\n\n    def test_13_issue_77_2_regex(self):\n    \t""""""\n    \tTest the resulting regex for regex bracket expression negation.\n    \t""""""\n>   \tregex, include = GitWildMatchPattern.pattern_to_regex(""a[^b]c"")\nE    TypeError: GitWildMatchPattern.pattern_to_regex() missing 1 required positional argument: \'pattern\'\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:824: TypeError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_14_issue_81_a>\n\n    def test_14_issue_81_a(self):\n    \t""""""\n    \tTest ignoring files in a directory, scenario A.\n    \t""""""\n    \tpattern = GitWildMatchPattern(""!libfoo/**"")\n    \n>   \tself.assertEqual(pattern.regex.pattern, ""^libfoo/.*$"")\nE    AssertionError: \'libfoo/.*.*\' != \'^libfoo/.*$\'\nE    - libfoo/.*.*\nE    ?          ^^\nE    + ^libfoo/.*$\nE    ? +         ^\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:838: AssertionError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_14_issue_81_b>\n\n    def test_14_issue_81_b(self):\n    \t""""""\n    \tTest ignoring files in a directory, scenario B.\n    \t""""""\n    \tpattern = GitWildMatchPattern(""!libfoo/*"")\n    \n>   \tself.assertEqual(pattern.regex.pattern, f""^libfoo/[^/]+{RE_SUB}$"")\nE    AssertionError: \'libfoo/.*\' != \'^libfoo/[^/]+(?:(?P<ps_d>/).*)?$\'\nE    - libfoo/.*\nE    + ^libfoo/[^/]+(?:(?P<ps_d>/).*)?$\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:848: AssertionError', 'self = <tests.test_02_gitwildmatch.GitWildMatchTest testMethod=test_14_issue_81_c>\n\n    def test_14_issue_81_c(self):\n    \t""""""\n    \tTest ignoring files in a directory, scenario C.\n    \t""""""\n    \t# GitWildMatchPattern will match the file, but GitIgnoreSpec should not.\n    \tpattern = GitWildMatchPattern(""!libfoo/"")\n    \n>   \tself.assertEqual(pattern.regex.pattern, f""^(?:.+/)?libfoo{RE_DIR}.*$"")\nE    AssertionError: \'libfoo/\' != \'^(?:.+/)?libfoo(?P<ps_d>/).*$\'\nE    - libfoo/\nE    + ^(?:.+/)?libfoo(?P<ps_d>/).*$\n\nrepos\\python-pathspec\\tests\\test_02_gitwildmatch.py:859: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_absolute_dir_paths_1>\n\n    def test_01_absolute_dir_paths_1(self):\n    \t""""""\n    \tTests that absolute paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'foo\',\n    \t])\n    \tfiles = {\n    \t\t\'/a.py\',\n    \t\t\'/foo/a.py\',\n    \t\t\'/x/a.py\',\n    \t\t\'/x/foo/a.py\',\n    \t\t\'a.py\',\n    \t\t\'foo/a.py\',\n    \t\t\'x/a.py\',\n    \t\t\'x/foo/a.py\',\n    \t}\n    \n    \tresults = list(spec.check_files(files))\n    \tincludes = get_includes(results)\n    \tdebug = debug_results(spec, results)\n    \n>   \tself.assertEqual(includes, {\n    \t\t\'/foo/a.py\',\n    \t\t\'/x/foo/a.py\',\n    \t\t\'foo/a.py\',\n    \t\t\'x/foo/a.py\',\n    \t}, debug)\nE    AssertionError: Items in the second set but not the first:\nE    \'x/foo/a.py\'\nE    \'/x/foo/a.py\' : \nE    \nE    ------------ DEBUG -------------\nE     1:foo  \'foo\'\nE    --------------------------------\nE     -      /a.py\nE     1:foo  /foo/a.py\nE     -      /x/a.py\nE     -      /x/foo/a.py\nE     -      a.py\nE     1:foo  foo/a.py\nE     -      x/a.py\nE     -      x/foo/a.py\nE    --------------------------------\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:79: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_absolute_dir_paths_2>\n\n    def test_01_absolute_dir_paths_2(self):\n    \t""""""\n    \tTests that absolute paths will be properly normalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'/foo\',\n    \t])\n    \tfiles = {\n    \t\t\'/a.py\',\n    \t\t\'/foo/a.py\',\n    \t\t\'/x/a.py\',\n    \t\t\'/x/foo/a.py\',\n    \t\t\'a.py\',\n    \t\t\'foo/a.py\',\n    \t\t\'x/a.py\',\n    \t\t\'x/foo/a.py\',\n    \t}\n    \n    \tresults = list(spec.check_files(files))\n    \tincludes = get_includes(results)\n    \tdebug = debug_results(spec, results)\n    \n>   \tself.assertEqual(includes, {\n    \t\t\'/foo/a.py\',\n    \t\t\'foo/a.py\',\n    \t}, debug)\nE    AssertionError: Items in the second set but not the first:\nE    \'/foo/a.py\'\nE    \'foo/a.py\' : \nE    \nE    ------------ DEBUG -------------\nE     1:/foo  \'/foo\'\nE    --------------------------------\nE     -       /a.py\nE     -       /foo/a.py\nE     -       /x/a.py\nE     -       /x/foo/a.py\nE     -       a.py\nE     -       foo/a.py\nE     -       x/a.py\nE     -       x/foo/a.py\nE    --------------------------------\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:108: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_current_dir_paths>\n\n    def test_01_current_dir_paths(self):\n    \t""""""\n    \tTests that paths referencing the current directory will be properly\n    \tnormalized and matched.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'./src/test1/a.txt\',\n    \t\t\'./src/test1/b.txt\',\n    \t\t\'./src/test1/c/c.txt\',\n    \t\t\'./src/test2/a.txt\',\n    \t\t\'./src/test2/b.txt\',\n    \t\t\'./src/test2/c/c.txt\',\n    \t}\n    \n    \tresults = list(spec.check_files(files))\n    \tincludes = get_includes(results)\n    \tdebug = debug_results(spec, results)\n    \n>   \tself.assertEqual(includes, {\n    \t\t\'./src/test2/a.txt\',\n    \t\t\'./src/test2/b.txt\',\n    \t\t\'./src/test2/c/c.txt\',\n    \t}, debug)\nE    AssertionError: Items in the first set but not the second:\nE    \'./src/test1/b.txt\'\nE    \'./src/test1/c/c.txt\'\nE    \'./src/test1/a.txt\' : \nE    \nE    ------------ DEBUG -------------\nE     1:*.txt    \'.*\\\\.txt\'\nE     2:!test1/  \'test1/\'\nE    --------------------------------\nE     1:*.txt    ./src/test1/a.txt\nE     1:*.txt    ./src/test1/b.txt\nE     1:*.txt    ./src/test1/c/c.txt\nE     1:*.txt    ./src/test2/a.txt\nE     1:*.txt    ./src/test2/b.txt\nE     1:*.txt    ./src/test2/c/c.txt\nE    --------------------------------\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:220: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_empty_path_1>\n\n    def test_01_empty_path_1(self):\n    \t""""""\n    \tTests that patterns that end with an escaped space will be treated properly.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'\\\\ \',\n    \t\t\'abc\\\\ \'\n    \t])\n    \tfiles = {\n    \t\t\' \',\n    \t\t\'  \',\n    \t\t\'abc \',\n    \t\t\'somefile\',\n    \t}\n    \n    \tresults = list(spec.check_files(files))\n    \tincludes = get_includes(results)\n    \tdebug = debug_results(spec, results)\n    \n>   \tself.assertEqual(includes, {\n    \t\t\' \',\n    \t\t\'abc \'\n    \t}, debug)\nE    AssertionError: Items in the first set but not the second:\nE    \'  \' : \nE    \nE    ------------ DEBUG -------------\nE     1:\\      \'\\\\ \'\nE     2:abc\\   \'abc\\\\ \'\nE    --------------------------------\nE     1:\\       \nE     1:\\        \nE     2:abc\\   abc \nE     -        somefile\nE    --------------------------------\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:245: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_01_empty_path_2>\n\n    def test_01_empty_path_2(self):\n    \t""""""\n    \tTests that patterns that end with an escaped space will be treated properly.\n    \t""""""\n>   \twith self.assertRaises(GitWildMatchPatternError):\nE    AssertionError: GitWildMatchPatternError not raised\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:254: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_entries>\n\n    def test_05_match_entries(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tentries = iter_tree_entries(self.temp_dir)\n    \tincludes = {\n    \t\t__entry.path for __entry in spec.match_entries(entries)\n    \t}\n    \n>   \tself.assertEqual(includes, set(map(ospath, [\n    \t\t\'X/a.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])))\nE    AssertionError: Items in the first set but not the second:\nE    \'Y\\\\b.txt\'\nE    \'X\\\\b.txt\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:503: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_file>\n\n    def test_05_match_file(self):\n    \t""""""\n    \tTest matching files individually.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n    \tincludes = set(filter(spec.match_file, files))\n    \n>   \tself.assertEqual(includes, {\n    \t\t\'X/a.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t})\nE    AssertionError: Items in the first set but not the second:\nE    \'X/b.txt\'\nE    \'Y/b.txt\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:529: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_files>\n\n    def test_05_match_files(self):\n    \t""""""\n    \tTest matching files collectively.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n    \tincludes = set(spec.match_files(files))\n    \n>   \tself.assertEqual(includes, {\n    \t\t\'X/a.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t})\nE    AssertionError: Items in the first set but not the second:\nE    \'X/b.txt\'\nE    \'Y/b.txt\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:555: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_entries>\n\n    def test_05_match_tree_entries(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tincludes = {\n    \t\t__entry.path for __entry in spec.match_tree_entries(self.temp_dir)\n    \t}\n    \n>   \tself.assertEqual(includes, set(map(ospath, [\n    \t\t\'X/a.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])))\nE    AssertionError: Items in the first set but not the second:\nE    \'Y\\\\b.txt\'\nE    \'X\\\\b.txt\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:589: AssertionError', 'self = <tests.test_03_pathspec.PathSpecTest testMethod=test_05_match_tree_files>\n\n    def test_05_match_tree_files(self):\n    \t""""""\n    \tTest matching a file tree.\n    \t""""""\n    \tspec = PathSpec.from_lines(\'gitwildmatch\', [\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tself.make_dirs([\n    \t\t\'X\',\n    \t\t\'X/Z\',\n    \t\t\'Y\',\n    \t\t\'Y/Z\',\n    \t])\n    \tself.make_files([\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])\n    \n    \tincludes = set(spec.match_tree_files(self.temp_dir))\n    \n>   \tself.assertEqual(includes, set(map(ospath, [\n    \t\t\'X/a.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t])))\nE    AssertionError: Items in the first set but not the second:\nE    \'Y\\\\b.txt\'\nE    \'X\\\\b.txt\'\n\nrepos\\python-pathspec\\tests\\test_03_pathspec.py:621: AssertionError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_dir_exclusions>\n\n    def test_02_dir_exclusions(self):\n    \t""""""\n    \tTest directory exclusions.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.txt\',\n    \t\t\'!test1/\',\n    \t])\n    \tfiles = {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/b.bin\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.bin\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n    \tresults = list(spec.check_files(files))\n    \tignores = get_includes(results)\n    \tdebug = debug_results(spec, results)\n    \n>   \tself.assertEqual(ignores, {\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/c/c.txt\',\n    \t}, debug)\nE    AssertionError: Items in the second set but not the first:\nE    \'test1/c/c.txt\'\nE    \'test1/a.txt\' : \nE    \nE    ------------ DEBUG -------------\nE     1:*.txt    \'.*\\\\.txt\'\nE     2:!test1/  \'test1/\'\nE    --------------------------------\nE     2:!test1/  test1/a.txt\nE     2:!test1/  test1/b.bin\nE     2:!test1/  test1/c/c.txt\nE     1:*.txt    test2/a.txt\nE     -          test2/b.bin\nE     1:*.txt    test2/c/c.txt\nE    --------------------------------\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:59: AssertionError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_file_exclusions>\n\n    def test_02_file_exclusions(self):\n    \t""""""\n    \tTest file exclusions.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.txt\',\n    \t\t\'!b.txt\',\n    \t])\n    \tfiles = {\n    \t\t\'X/a.txt\',\n    \t\t\'X/b.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/b.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}\n    \n    \tresults = list(spec.check_files(files))\n    \tignores = get_includes(results)\n    \tdebug = debug_results(spec, results)\n    \n>   \tself.assertEqual(ignores, {\n    \t\t\'X/a.txt\',\n    \t\t\'X/Z/c.txt\',\n    \t\t\'Y/a.txt\',\n    \t\t\'Y/Z/c.txt\',\n    \t}, debug)\nE    AssertionError: Items in the first set but not the second:\nE    \'X/b.txt\'\nE    \'Y/b.txt\' : \nE    \nE    ------------ DEBUG -------------\nE     1:*.txt   \'.*\\\\.txt\'\nE     2:!b.txt  \'b\\\\.txt\'\nE    --------------------------------\nE     1:*.txt   X/Z/c.txt\nE     1:*.txt   X/a.txt\nE     1:*.txt   X/b.txt\nE     1:*.txt   Y/Z/c.txt\nE     1:*.txt   Y/a.txt\nE     1:*.txt   Y/b.txt\nE    --------------------------------\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:91: AssertionError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_issue_41_a>\n\n    def test_02_issue_41_a(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario A.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.yaml\',\n    \t\t\'!*.yaml/\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',   # -\n    \t\t\'dir.yaml/file.yaml\',  # 1:*.yaml\n    \t\t\'dir.yaml/index.txt\',  # -\n    \t\t\'dir/file.sql\',        # -\n    \t\t\'dir/file.yaml\',       # 1:*.yaml\n    \t\t\'dir/index.txt\',       # -\n    \t\t\'file.yaml\',           # 1:*.yaml\n    \t}\n    \n    \tresults = list(spec.check_files(files))\n    \tignores = get_includes(results)\n    \tdebug = debug_results(spec, results)\n    \n>   \tself.assertEqual(ignores, {\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'file.yaml\',\n    \t}, debug)\nE    AssertionError: Items in the second set but not the first:\nE    \'dir.yaml/file.yaml\' : \nE    \nE    ------------ DEBUG -------------\nE     1:*.yaml    \'.*\\\\.yaml\'\nE     2:!*.yaml/  \'.*\\\\.yaml/\'\nE    --------------------------------\nE     2:!*.yaml/  dir.yaml/file.sql\nE     2:!*.yaml/  dir.yaml/file.yaml\nE     2:!*.yaml/  dir.yaml/index.txt\nE     -           dir/file.sql\nE     1:*.yaml    dir/file.yaml\nE     -           dir/index.txt\nE     1:*.yaml    file.yaml\nE    --------------------------------\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:126: AssertionError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_02_issue_41_c>\n\n    def test_02_issue_41_c(self):\n    \t""""""\n    \tTest including a file and excluding a directory with the same name pattern,\n    \tscenario C.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*.yaml\',\n    \t\t\'!dir.yaml\',\n    \t])\n    \tfiles = {\n    \t\t\'dir.yaml/file.sql\',   # -\n    \t\t\'dir.yaml/file.yaml\',  # 1:*.yaml\n    \t\t\'dir.yaml/index.txt\',  # -\n    \t\t\'dir/file.sql\',        # -\n    \t\t\'dir/file.yaml\',       # 1:*.yaml\n    \t\t\'dir/index.txt\',       # -\n    \t\t\'file.yaml\',           # 1:*.yaml\n    \t}\n    \n    \tresults = list(spec.check_files(files))\n    \tignores = get_includes(results)\n    \tdebug = debug_results(spec, results)\n    \n>   \tself.assertEqual(ignores, {\n    \t\t\'dir.yaml/file.yaml\',\n    \t\t\'dir/file.yaml\',\n    \t\t\'file.yaml\',\n    \t}, debug)\nE    AssertionError: Items in the second set but not the first:\nE    \'dir.yaml/file.yaml\' : \nE    \nE    ------------ DEBUG -------------\nE     1:*.yaml     \'.*\\\\.yaml\'\nE     2:!dir.yaml  \'dir\\\\.yaml\'\nE    --------------------------------\nE     2:!dir.yaml  dir.yaml/file.sql\nE     2:!dir.yaml  dir.yaml/file.yaml\nE     2:!dir.yaml  dir.yaml/index.txt\nE     -            dir/file.sql\nE     1:*.yaml     dir/file.yaml\nE     -            dir/index.txt\nE     1:*.yaml     file.yaml\nE    --------------------------------\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:198: AssertionError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_04_issue_62>\n\n    def test_04_issue_62(self):\n    \t""""""\n    \tTest including all files and excluding a directory.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*\',\n    \t\t\'!product_dir/\',\n    \t])\n    \tfiles = {\n    \t\t\'anydir/file.txt\',\n    \t\t\'product_dir/file.txt\',\n    \t}\n    \n    \tresults = list(spec.check_files(files))\n    \tignores = get_includes(results)\n    \tdebug = debug_results(spec, results)\n    \n>   \tself.assertEqual(ignores, {\n    \t\t\'anydir/file.txt\',\n    \t\t\'product_dir/file.txt\',\n    \t}, debug)\nE    AssertionError: Items in the second set but not the first:\nE    \'product_dir/file.txt\' : \nE    \nE    ------------ DEBUG -------------\nE     1:*              \'.*\'\nE     2:!product_dir/  \'product_dir/\'\nE    --------------------------------\nE     1:*              anydir/file.txt\nE     2:!product_dir/  product_dir/file.txt\nE    --------------------------------\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:359: AssertionError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_07_issue_74>\n\n    def test_07_issue_74(self):\n    \t""""""\n    \tTest include directory should override exclude file.\n    \t""""""\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t\'*\',  # Ignore all files by default\n    \t\t\'!*/\',  # but scan all directories\n    \t\t\'!*.txt\',  # Text files\n    \t\t\'/test1/**\',  # ignore all in the directory\n    \t])\n    \tfiles = {\n    \t\t\'test1/b.bin\',\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/a.txt\',\n    \t\t\'test2/b.bin\',\n    \t\t\'test2/c/c.txt\',\n    \t}\n    \n    \tresults = list(spec.check_files(files))\n    \tignores = get_includes(results)\n    \tdebug = debug_results(spec, results)\n    \n>   \tself.assertEqual(ignores, {\n    \t\t\'test1/b.bin\',\n    \t\t\'test1/a.txt\',\n    \t\t\'test1/c/c.txt\',\n    \t\t\'test2/b.bin\',\n    \t}, debug)\nE    AssertionError: Items in the second set but not the first:\nE    \'test1/b.bin\'\nE    \'test1/c/c.txt\'\nE    \'test2/b.bin\'\nE    \'test1/a.txt\' : \nE    \nE    ------------ DEBUG -------------\nE     1:*          \'.*\'\nE     2:!*/        \'.*/\'\nE     3:!*.txt     \'.*\\\\.txt\'\nE     4:/test1/**  \'/test1/.*.*\'\nE    --------------------------------\nE     3:!*.txt     test1/a.txt\nE     2:!*/        test1/b.bin\nE     3:!*.txt     test1/c/c.txt\nE     3:!*.txt     test2/a.txt\nE     2:!*/        test2/b.bin\nE     3:!*.txt     test2/c/c.txt\nE    --------------------------------\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:442: AssertionError', 'self = <tests.test_04_gitignore.GitIgnoreSpecTest testMethod=test_08_issue_81_c>\n\n    def test_08_issue_81_c(self):\n    \t""""""\n    \tTest issue 81 whitelist, scenario C.\n    \t""""""\n    \t# Confirmed results with git (v2.42.0).\n    \tspec = GitIgnoreSpec.from_lines([\n    \t\t""*"",\n    \t\t""!libfoo"",\n    \t\t""!libfoo/"",\n    \t])\n    \tfiles = {\n    \t\t""ignore.txt"",          # 1:*\n    \t\t""libfoo/__init__.py"",  # 1:*\n    \t}\n    \tresults = list(spec.check_files(files))\n    \tignores = get_includes(results)\n    \tdebug = debug_results(spec, results)\n>   \tself.assertEqual(ignores, {\n    \t\t""ignore.txt"",\n    \t\t""libfoo/__init__.py"",\n    \t}, debug)\nE    AssertionError: Items in the second set but not the first:\nE    \'libfoo/__init__.py\' : \nE    \nE    ------------ DEBUG -------------\nE     1:*         \'.*\'\nE     2:!libfoo   \'libfoo\'\nE     3:!libfoo/  \'libfoo/\'\nE    --------------------------------\nE     1:*         ignore.txt\nE     3:!libfoo/  libfoo/__init__.py\nE    --------------------------------\n\nrepos\\python-pathspec\\tests\\test_04_gitignore.py:522: AssertionError']"
python-pathspec,pattern_to_regex,"@classmethod
def pattern_to_regex(cls, pattern: AnyStr) -> Tuple[Optional[AnyStr], Optional[bool]]:
    """"""
		Convert the pattern into a regular expression.

		*pattern* (:class:`str` or :class:`bytes`) is the pattern to convert into a
		regular expression.

		Returns the uncompiled regular expression (:class:`str`, :class:`bytes`, or
		:data:`None`); and whether matched files should be included (:data:`True`),
		excluded (:data:`False`), or if it is a null-operation (:data:`None`).
		""""""
    if isinstance(pattern, str):
        return_type = str
    elif isinstance(pattern, bytes):
        return_type = bytes
        pattern = pattern.decode(_BYTES_ENCODING)
    else:
        raise TypeError(f'pattern:{pattern!r} is not a unicode or byte string.')
    original_pattern = pattern
    if pattern.endswith('\\ '):
        pattern = pattern.lstrip()
    else:
        pattern = pattern.strip()
    regex: Optional[str]
    include: Optional[bool]
    if pattern.startswith('#'):
        regex = None
        include = None
    elif pattern == '/':
        regex = None
        include = None
    elif pattern:
        if pattern.startswith('!'):
            include = False
            pattern = pattern[1:]
        else:
            include = True
        override_regex: Optional[str] = None
        pattern_segs = pattern.split('/')
        is_dir_pattern = not pattern_segs[-1]
        for i in range(len(pattern_segs) - 1, 0, -1):
            prev = pattern_segs[i - 1]
            seg = pattern_segs[i]
            if prev == '**' and seg == '**':
                del pattern_segs[i]
        if len(pattern_segs) == 2 and pattern_segs[0] == '**' and (not pattern_segs[1]):
            override_regex = f'^.+(?P<{_DIR_MARK}>/).*$'
        if not pattern_segs[0]:
            del pattern_segs[0]
        elif len(pattern_segs) == 1 or (len(pattern_segs) == 2 and (not pattern_segs[1])):
            if pattern_segs[0] != '**':
                pattern_segs.insert(0, '**')
        else:
            pass
        if not pattern_segs:
            raise GitWildMatchPatternError(f'Invalid git pattern: {original_pattern!r}')
        if not pattern_segs[-1] and len(pattern_segs) > 1:
            pattern_segs[-1] = '**'
        if override_regex is None:
            output = ['^']
            need_slash = False
            end = len(pattern_segs) - 1
            for i, seg in enumerate(pattern_segs):
                if seg == '**':
                    if i == 0 and i == end:
                        output.append(f'[^/]+(?:/.*)?')
                    elif i == 0:
                        output.append('(?:.+/)?')
                        need_slash = False
                    elif i == end:
                        if is_dir_pattern:
                            output.append(f'(?P<{_DIR_MARK}>/).*')
                        else:
                            output.append(f'/.*')
                    else:
                        output.append('(?:/.+)?')
                        need_slash = True
                elif seg == '*':
                    if need_slash:
                        output.append('/')
                    output.append('[^/]+')
                    if i == end:
                        output.append(f'(?:(?P<{_DIR_MARK}>/).*)?')
                    need_slash = True
                else:
                    if need_slash:
                        output.append('/')
                    try:
                        output.append(cls._translate_segment_glob(seg))
                    except ValueError as e:
                        raise GitWildMatchPatternError(f'Invalid git pattern: {original_pattern!r}') from e
                    if i == end:
                        output.append(f'(?:(?P<{_DIR_MARK}>/).*)?')
                    need_slash = True
            output.append('$')
            regex = ''.join(output)
        else:
            regex = override_regex
    else:
        regex = None
        include = None
    if regex is not None and return_type is bytes:
        regex = regex.encode(_BYTES_ENCODING)
    return (regex, include)","The goal of the function is to convert a given pattern into a regular expression. The function determines whether files matching the pattern should be included, excluded, or if it is a null-operation. It handles different types of patterns and constructs the regular expression based on the pattern logic, ultimately returning the compiled regular expression and the inclusion/exclusion status. This function is designed to be used within a class context and interacts with class attributes or other methods to properly handle and convert the patterns into regular expressions.",3,Invalid Syntax / No valid code,N/A,Failed,[],[],0,0
